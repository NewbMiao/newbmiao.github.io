<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟Miao</title>
  <icon>https://www.gravatar.com/avatar/644a62fb3ee1c60061ebca1d0996b0ae</icon>
  <subtitle>start from a newb...(博客地址: https://newbmiao.github.io)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://newbmiao.github.io/"/>
  <updated>2024-04-24T05:59:01.950Z</updated>
  <id>https://newbmiao.github.io/</id>
  
  <author>
    <name>菜鸟Miao</name>
    <email>newbvirgil@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust设计模式：sealed trait</title>
    <link href="https://newbmiao.github.io/2024/04/22/rust-sealed-trait.html"/>
    <id>https://newbmiao.github.io/2024/04/22/rust-sealed-trait.html</id>
    <published>2024-04-22T09:26:42.000Z</published>
    <updated>2024-04-24T05:59:01.950Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>最近升级之前写的一个<a href="https://github.com/NewbMiao/axum-koans/" target="_blank" rel="noopener">oauth2相关</a>的依赖时， 发现新版<a href="https://github.com/ramosbugs/oauth2-rs" target="_blank" rel="noopener">oauth2-rs</a>有些实现pattern很有意思，可以展开看看。</p><p>今天先看下<code>sealed trait</code>。</p><a id="more"></a><p>这种pattern是用来当自己的trait想限定一些实现方法时使用。</p><p>常规的trait定义都是很灵活的，不限定实现</p><p>比如下边<code>nosealed_trait</code>可以分别为<code>usize</code>和<code>i32</code>实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> nosealed_trait &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MyTrait</span></span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> nosealed_trait::MyTrait <span class="keyword">for</span> <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"MyTrait for usize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> nosealed_trait::MyTrait <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"MyTrait for i32"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果只想为<code>i32</code>实现呢？</p><p>可以让自己<code>trait</code>依赖一个不暴露的<code>super trait</code>，由<code>super trait</code>限定能有哪些实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sealed_trait &#123;</span><br><span class="line">    <span class="keyword">mod</span> private &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sealed</span></span> &#123;&#125;</span><br><span class="line">        <span class="keyword">impl</span> Sealed <span class="keyword">for</span> <span class="built_in">i32</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MySealedTrait</span></span>: private::Sealed &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> sealed_trait::MySealedTrait <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"MySealedTrait for i32"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用方想实现不在限定实现列表中的方法就会被编译错误阻止。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> sealed_trait::MySealedTrait <span class="keyword">for</span> <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"MySealedTrait for usize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误如下, 其中的<code>note</code>说的很明白。</p><blockquote><p>note: <code>MySealedTrait</code> is a “sealed trait”, because to implement it you also need to implement <code>sealedtrait::private::Sealed</code>, which is not accessible; this is usually done to force you to use one of the provided types that already implement it</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `usize: Sealed` is not satisfied</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> src/main.rs:34:37</span></span><br><span class="line">   |</span><br><span class="line">34 | impl sealedtrait::MySealedTrait for usize &#123;</span><br><span class="line">   |                                     ^^^^^ the trait `Sealed` is not implemented for `usize`</span><br><span class="line">   |</span><br><span class="line">   = help: the trait `Sealed` is implemented for `i32`</span><br><span class="line">note: required by a bound in `MySealedTrait`</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> src/main.rs:23:30</span></span><br><span class="line">   |</span><br><span class="line">23 |     pub trait MySealedTrait: private::Sealed &#123;</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^ required by this bound in `MySealedTrait`</span><br><span class="line">   = note: `MySealedTrait` is a "sealed trait", because to implement it you also need to implement `sealedtrait::private::Sealed`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it</span><br><span class="line">   = help: the following type implements the trait:</span><br><span class="line">             i32</span><br></pre></td></tr></table></figure><p>下一篇再聊聊<code>typestate pattern</code>.</p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust设计模式：sealed trait
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="sealed-trait" scheme="https://newbmiao.github.io/tags/sealed-trait/"/>
    
  </entry>
  
  <entry>
    <title>如何用Rust快速构建AWS Lambda Function</title>
    <link href="https://newbmiao.github.io/2024/03/10/rust-lambda.html"/>
    <id>https://newbmiao.github.io/2024/03/10/rust-lambda.html</id>
    <published>2024-03-10T10:44:14.000Z</published>
    <updated>2024-03-10T12:11:31.964Z</updated>
    
    <content type="html"><![CDATA[<p><code>AWS Lambda Function</code>是轻量级的计算服务。优势是按需付费，专注于功能，服务本身如何构建暴露都有<code>AWS</code>都不需要自己操心。</p><p>而按需付费基本就是服务使用时长和内存占用了，这个优化的话那妥妥的是<code>Rust</code>的拿手好戏, 所以现在有好多<code>Serverless</code>服务都用<code>Rust</code>构建的<code>Lambda Function</code>来搞。</p><p>今天简单看下如何用<code>Rust</code>快速构建<code>Lambda Function</code>（别担心没aws环境，往下看，有本地沙箱可尝试）</p><a id="more"></a><!-- **文章目录** --><!-- [TOC] --><h2 id="cargo-lambda"><a href="#cargo-lambda" class="headerlink" title="cargo-lambda"></a>cargo-lambda</h2><p><code>cargo-lambda</code>这个库可以用来构建<code>Lambda Function</code> （也是官方推荐的工具）</p><p>如下代码安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap cargo-lambda/cargo-lambda</span><br><span class="line">brew install cargo-lambda</span><br></pre></td></tr></table></figure><p>然后初始化一个demo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo lambda new lambda-demo</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Is this <span class="keyword">function</span> an HTTP <span class="keyword">function</span>? Yes</span></span><br></pre></td></tr></table></figure><p>会自动生成初始化项目，引入相关依赖及运行时：<code>lambda-http</code>和<code>tokio</code>依赖</p><p>功能部分代码如下，提供一个<code>hello world</code>式请求处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lambda_http::&#123;run, service_fn, tracing, Body, Error, Request, RequestExt, Response&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">function_handler</span></span>(event: Request) -&gt; <span class="built_in">Result</span>&lt;Response&lt;Body&gt;, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> who = event</span><br><span class="line">        .query_string_parameters_ref()</span><br><span class="line">        .and_then(|params| params.first(<span class="string">"name"</span>))</span><br><span class="line">        .unwrap_or(<span class="string">"world"</span>);</span><br><span class="line">    <span class="keyword">let</span> message = <span class="built_in">format!</span>(<span class="string">"Hello &#123;who&#125;, this is an AWS Lambda HTTP request"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resp = Response::builder()</span><br><span class="line">        .status(<span class="number">200</span>)</span><br><span class="line">        .header(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">        .body(message.into())</span><br><span class="line">        .map_err(<span class="built_in">Box</span>::new)?;</span><br><span class="line">    <span class="literal">Ok</span>(resp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    tracing::init_default_subscriber();</span><br><span class="line"></span><br><span class="line">    run(service_fn(function_handler)).<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题外话，有没有感觉这个<code>service_fn</code>很眼熟?</p><p>这个接的<code>handler</code>也要求实现<code>Service trait</code>， 跟<code>tower service</code>一样。为啥呢，用了<code>hyper</code>库！<br>都说<code>hyper</code>基本就是<code>Rust</code>服务框架的基石不假。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>开发中用<code>watch</code>就能本地运行调试，支持变更重编译</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo lambda watch</span><br><span class="line">#  INFO invoke server listening on [::]:<span class="number">9000</span></span><br></pre></td></tr></table></figure><p>也可以命令行调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo lambda invoke lambda-demo --data-ascii "?name=newbmiao"</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo lambda build --release --arm64</span><br></pre></td></tr></table></figure><p>这样会将执行文件编译到<code>./target/lambda/lambda-demo/bootstrap</code></p><p>(注意：如果是<code>workspace</code>, 则需要去<code>workspace</code>下<code>target</code>目录找)</p><p>可执行文件压缩一下就可以用来部署了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip bootstrap.zip bootstrap</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>(这部分会设计比较多infrastructure，感兴趣的同学可以继续往下)</p><p>部署也很方便，不过难在不是所有人都有<code>aws</code>账户啊。</p><p>也好解决，<code>localstack</code>可以本地模拟<code>aws</code>环境</p><p>用<code>docker-compose up</code>起个<code>localstack</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3.8"</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  localstack:</span><br><span class="line">    container_name: <span class="string">"$&#123;LOCALSTACK_DOCKER_NAME:-localstack-main&#125;"</span></span><br><span class="line">    image: localstack/localstack</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"127.0.0.1:4566:4566"</span> <span class="comment"># LocalStack Gateway</span></span><br><span class="line">      - <span class="string">"127.0.0.1:4510-4559:4510-4559"</span> <span class="comment"># external services port range</span></span><br><span class="line">    environment:</span><br><span class="line">      <span class="comment"># LocalStack configuration: https://docs.localstack.cloud/references/configuration/</span></span><br><span class="line">      - DEBUG=$&#123;DEBUG:-<span class="number">0</span>&#125;</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">"$&#123;LOCALSTACK_VOLUME_DIR:-./volume&#125;:/var/lib/localstack"</span></span><br><span class="line">      - <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></span><br></pre></td></tr></table></figure><p>然后用<code>terraform</code>构建部署流程, 核心部分就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 构建</span><br><span class="line">resource &quot;aws_lambda_function&quot; &quot;lambda_demo&quot; &#123;</span><br><span class="line">  filename         &#x3D; &quot;bootstrap.zip&quot;</span><br><span class="line">  function_name    &#x3D; &quot;lambda_demo&quot;</span><br><span class="line">  role             &#x3D; aws_iam_role.iam_for_lambda_tf.arn</span><br><span class="line">  handler          &#x3D; &quot;bootstrap&quot;</span><br><span class="line">  source_code_hash &#x3D; filebase64sha256(&quot;bootstrap.zip&quot;)</span><br><span class="line">  runtime          &#x3D; &quot;provided.al2&quot;</span><br><span class="line">  architectures    &#x3D; [&quot;arm64&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下就是权限以及获取<code>lambda function</code>地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_lambda_function_url&quot; &quot;lambda_demo_url&quot; &#123;</span><br><span class="line">  function_name      &#x3D; aws_lambda_function.lambda_demo.arn</span><br><span class="line">  authorization_type &#x3D; &quot;NONE&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;function_url&quot; &#123;</span><br><span class="line">  description &#x3D; &quot;Function URL.&quot;</span><br><span class="line">  value       &#x3D; aws_lambda_function_url.lambda_demo_url.function_url</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_role&quot; &quot;iam_for_lambda_tf&quot; &#123;</span><br><span class="line">  name &#x3D; &quot;iam_for_lambda_tf&quot;</span><br><span class="line"></span><br><span class="line">  assume_role_policy &#x3D; &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Action&quot;: &quot;sts:AssumeRole&quot;,</span><br><span class="line">      &quot;Principal&quot;: &#123;</span><br><span class="line">        &quot;Service&quot;: &quot;lambda.amazonaws.com&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">      &quot;Sid&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样从<code>terraform apply</code> 部署结果中能拿到访问地址, 比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Apply complete! Resources: 3 added, 0 changed, 0 destroyed.</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">function_url = "http://h6v7ozz6ay3h6apr2hi5edsmnc0wpz80.lambda-url.us-east-1.localhost.localstack.cloud:4566/</span><br></pre></td></tr></table></figure><p>想上手试下的话，详细代码见<a href="https://github.com/NewbMiao/rust-koan/tree/master/aws-lambda/lambda-demo" target="_blank" rel="noopener">lambda-demo</a>, <code>build.sh</code>有详细打包流程</p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      如何用Rust快速构建Aws lambda
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="aws-lambda" scheme="https://newbmiao.github.io/tags/aws-lambda/"/>
    
  </entry>
  
  <entry>
    <title>Rust之tower如何构建请求中间件</title>
    <link href="https://newbmiao.github.io/2024/02/03/rust-tower-service.html"/>
    <id>https://newbmiao.github.io/2024/02/03/rust-tower-service.html</id>
    <published>2024-02-03T10:25:19.000Z</published>
    <updated>2024-02-03T14:50:33.958Z</updated>
    
    <content type="html"><![CDATA[<p>提到<code>Rust</code>请求中间件, 就不能不提<code>tower</code>。</p><p><code>tower</code>是一个请求协议无关的的中间件定义类库，主要定义了<code>Service</code>和<code>Layer</code>两个<code>trait</code>来帮助实现可重用的请求处理中间件。</p><p>今天拿聊聊它如何巧妙构建起中间件。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="初始请求"><a href="#初始请求" class="headerlink" title="初始请求"></a>初始请求</h2><p>假设我们有一个请求<code>handler</code>, 用<code>hyper</code>官方的<code>hello world</code>例子代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> http_body_util::Full;</span><br><span class="line"><span class="keyword">use</span> hyper::&#123;</span><br><span class="line">    body::&#123;Bytes, Incoming&#125;,</span><br><span class="line">    server::conn::http1,</span><br><span class="line">    Request, Response,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> hyper_util::rt::TokioIo;</span><br><span class="line"><span class="keyword">use</span> std::&#123;convert::Infallible, net::SocketAddr&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">handler</span></span>(_: Request&lt;Incoming&gt;) -&gt; <span class="built_in">Result</span>&lt;Response&lt;Full&lt;Bytes&gt;&gt;, Infallible&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(Response::new(Full::new(Bytes::from(<span class="string">"Hello, World!"</span>))))</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> addr = SocketAddr::from(([<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="number">3000</span>));</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(addr).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (stream, _) = listener.accept().<span class="keyword">await</span>?;</span><br><span class="line">        <span class="keyword">let</span> io = TokioIo::new(stream);</span><br><span class="line">        tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="comment">// 请求在这里转成了Service</span></span><br><span class="line">            <span class="keyword">let</span> svc = hyper::service::service_fn(handler);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(err) = http1::Builder::new().serve_connection(io, svc).<span class="keyword">await</span> &#123;</span><br><span class="line">                eprintln!(<span class="string">"server error: &#123;&#125;"</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>service_fn</code>将<code>handler</code>转成了<code>Service</code>，也就是<code>server</code>启动时要的是一个实现了<code>Service trait</code>的请求处理函数，这是后边构建中间件的基础。</p><blockquote><p>注意，在hyper 发布v1之后，这里的<code>Service</code>准确说不是<code>tower的Service trait</code>，但理念是一样，我们后边在讲他们接口的不同</p></blockquote><p>这时如果想在处理上边加上<code>Logger</code>，<code>Timeout</code>两个流程来分别记录请求日志和超时约束， 能很灵活的按如下方式组织</p><p><img src="/images/rust/tower-service.png" alt="tower-service"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = hyper::service::service_fn(handler);</span><br><span class="line"><span class="comment">// 增加两个layer中间件</span></span><br><span class="line"><span class="keyword">let</span> svc = ServiceBuilder::new()</span><br><span class="line">    .layer_fn(Logger::new)</span><br><span class="line">    .layer_fn(|s| Timeout::new(s, std::time::Duration::from_secs(<span class="number">5</span>)))</span><br><span class="line">    .service(svc);</span><br><span class="line"><span class="comment">// 先忽略下边为了接口转换，后边在展开这里</span></span><br><span class="line"><span class="comment">// let svc = TowerToHyperService::new(svc);</span></span><br></pre></td></tr></table></figure><h2 id="Service-trait"><a href="#Service-trait" class="headerlink" title="Service trait"></a>Service trait</h2><p>这样处理，就像是一个<code>service</code>链，一个<code>service</code>处理完，再调用下一个<code>service</code></p><p>所以<code>tower</code>定义了如下<code>Service trait</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Output = <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;;</span><br><span class="line">    <span class="comment">// 请求是否可以处理</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_ready</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;<span class="built_in">Result</span>&lt;(), Self::Error&gt;&gt;;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>poll_ready</code>是决定是否可以执行请求处理<code>call</code>前的判断。</p><p><code>call</code>拿到请求，返回一个异步处理的结果，这样当请求执行耗时时不阻塞其他请求的处理。</p><p>说个题外话，你可能会好奇为什么这里要返回一个<code>Future</code>而不是用<code>async</code>。</p><p>这是因为之前<code>Rust</code>不支持<code>trait</code>中定义异步函数。不过<code>Rust 1.75</code>开始支持了，如果后边换成下边的实现就不奇怪了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: Request) -&gt; <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现middleware"><a href="#实现middleware" class="headerlink" title="实现middleware"></a>实现middleware</h2><p>拿<code>Logger middleware</code>实现来看如何构建起<code>service</code>链</p><p>注释及代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tower::Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Logger</span></span>&lt;S&gt; &#123;</span><br><span class="line">    inner: S,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;S&gt; Logger&lt;S&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(inner: S) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Logger &#123; inner &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Req</span></span> = hyper::Request&lt;Incoming&gt;;</span><br><span class="line"><span class="keyword">impl</span>&lt;S&gt; Service&lt;Req&gt; <span class="keyword">for</span> Logger&lt;S&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: Service&lt;Req&gt; + <span class="built_in">Clone</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Logger拿到的也是一个Service，返回类型也没有变化，直接指定即可</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span> = S::Response;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = S::Error;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = S::Future;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_ready</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">'_</span>&gt;,</span><br><span class="line">    ) -&gt; std::task::Poll&lt;<span class="built_in">Result</span>&lt;(), Self::Error&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 直接可以处理，无需额外满足条件</span></span><br><span class="line">        <span class="keyword">self</span>.inner.poll_ready(cx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: Req) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"processing request: &#123;&#125; &#123;&#125;"</span>, req.method(), req.uri().path());</span><br><span class="line">        <span class="comment">// 处理完调用下一个Service</span></span><br><span class="line">        <span class="keyword">self</span>.inner.call(req)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样添加<code>Logger</code>可以这么添加</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = Logger::new(svc);</span><br></pre></td></tr></table></figure><p>再加个<code>Timeout</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = Timeout::new(svc, std::time::Duration::from_secs(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>不够优雅，而且执行顺序也是反的，最后添加的中间件先执行，要是链式操作就好了，这时就到<code>Layer trait</code>显身手了</p><h2 id="Layer-trait"><a href="#Layer-trait" class="headerlink" title="Layer trait"></a>Layer trait</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Layer</span></span>&lt;S&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Service</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">layer</span></span>(&amp;<span class="keyword">self</span>, inner: S) -&gt; Self::Service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要实现以上<code>Layer trait</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;S&gt; Layer&lt;S&gt; <span class="keyword">for</span> Logger&lt;S&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Service</span></span> = Logger&lt;S&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">layer</span></span>(&amp;<span class="keyword">self</span>, inner: S) -&gt; Self::Service &#123;</span><br><span class="line">        Logger &#123; inner &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就能用<code>ServiceBuilder</code>构建<code>service</code>链</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tower::ServiceBuilder::new()</span><br><span class="line">    .layer(LoggerLayer)</span><br><span class="line">    .layer_fn(|s| Timeout::new(s, std::time::Duration::from_secs(<span class="number">5</span>)))</span><br><span class="line">    .service(svc);</span><br></pre></td></tr></table></figure><p>当然<code>layer_fn</code>也可以直接将函数转为实现<code>Layer trait</code></p><p>最重要的是顺序是按调用顺序。</p><h2 id="hyper-Service-trait"><a href="#hyper-Service-trait" class="headerlink" title="hyper Service trait"></a>hyper Service trait</h2><p><code>hyper</code>之前依赖了<code>tower Service</code>，但v1稳定版发布前替换成了自己的<code>Service</code>。</p><p>一方面是<code>tower</code>还没有稳定版本</p><p>另一方面为了简化请求处理：</p><ul><li><p>移除了<code>poll_ready</code></p></li><li><p><code>call</code>也不再需要<code>&amp;mut self</code>，即不再考虑通过其修改请求，如果需要的话可以加<code>Arc&lt;Mutex&lt;_&gt;&gt;</code>的<code>state</code></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Output = <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, req: Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就是为什么如果你想直接复用<code>tower Serivice</code>（如<code>Timeout</code>等）需要<code>TowerToHyperService</code>转一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = TowerToHyperService::new(svc);</span><br></pre></td></tr></table></figure><p>另外<code>hyper</code>作为比较底层的请求库，很多<code>web</code>框架（<code>Axum</code>, <code>Actix web</code>等）都依赖他。 也就也支持了<code>tower</code>, 使得<code>tower</code>实现的中间件就更容易复用了。</p><p>总的来说，<code>tower</code>能用<code>Service trait</code>构建一个请求中间件的规范，确实很神奇。从目前实现反推似乎很简单，但其实设计过程中还是有很多考虑的，尤其像需要处理返回的<code>future</code>时。推荐看看官方的这篇<a href="https://tokio.rs/blog/2021-05-14-inventing-the-service-trait" target="_blank" rel="noopener">inventing-the-service-trait</a>。</p><p>想了解中间件实现过程的话也推荐看看David Pedersen的<code>Rust live coding</code><a href="https://www.youtube.com/watch?v=16sU1q8OeeI&t=4227s" target="_blank" rel="noopener">Tower deep dive</a> （看不了的同学可以B站找找…）</p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust之tower如何构建请求中间件
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="tower" scheme="https://newbmiao.github.io/tags/tower/"/>
    
  </entry>
  
  <entry>
    <title>tokio之如何观测Rust异步任务的调度</title>
    <link href="https://newbmiao.github.io/2024/01/26/rust-tokio-task-tracing.html"/>
    <id>https://newbmiao.github.io/2024/01/26/rust-tokio-task-tracing.html</id>
    <published>2024-01-26T11:02:37.000Z</published>
    <updated>2024-01-26T11:52:02.510Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>Rust</code>的异步是以<code>task</code>的调度来构建的。<code>task</code>作为抽象在语言层面的调度单元。</p><p>那如果想要观测其的调度执行有没有办法呢？。</p><p>有的！异步<code>runtime</code>库<code>tokio</code>就有个<code>tokio-console</code>可以实现对异步调度的观测和分析，其对了解调度的机制和性能分析都很有帮助。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>其调度的观测是需要依赖程序段添加 <code>console-subscriber</code> 来上报<code>runtime</code>的调度信息，然后由命令行程序<code>tokio-console</code>进行数据的统计展示。</p><p>这个功能还属于unstable，需要引入时做一些设置。</p><p>具体来说，需要在引入<code>tokio</code>时启用<code>tracing</code>, 如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">console-subscriber = <span class="string">"0.2.0"</span></span><br><span class="line">tokio = &#123; version = <span class="string">"1.35.1"</span>, features = [<span class="string">"full"</span>, <span class="string">"tracing"</span>] &#125;</span><br></pre></td></tr></table></figure><p>异步代码<code>main</code>中也需要初始化<code>console_subscriber</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    console_subscriber::init();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行时需要加上编译参数： <code>RUSTFLAGS=&quot;--cfg tokio_unstable&quot; cargo run</code></p><p>也可以在项目根目录用<code>.cargo/config.toml</code>全局配置, 如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[build]</span><br><span class="line">rustflags = [<span class="string">"--cfg"</span>, <span class="string">"tokio_unstable"</span>]</span><br></pre></td></tr></table></figure><p>这样同时运行<code>tokio-console</code>就能观测异步任务的调度了。</p><p>（<code>cargo install tokio-console</code>可以安装）</p><h2 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h2><p>以之前《Rust并发控制之Semaphore-两线程交替打印》代码来观测为例</p><p>修改部分详见代码注释:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;sync::Arc, time::Duration&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::&#123;sync::Semaphore, task, time::sleep&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 注意. 初始化tracing收集</span></span><br><span class="line">    console_subscriber::init();</span><br><span class="line">    <span class="comment">// 线程1的令牌桶1初始一个令牌，可以先打印1</span></span><br><span class="line">    <span class="keyword">let</span> semaphore = Arc::new(Semaphore::new(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> semaphore2 = semaphore.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2的令牌桶2初始没有令牌，直到1打印后增加令牌</span></span><br><span class="line">    <span class="keyword">let</span> semaphore_wait = Arc::new(Semaphore::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> semaphore_wait2 = semaphore_wait.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意. 使用task::Builder来增加task名字，否则等同tokio::spawn</span></span><br><span class="line">    <span class="keyword">let</span> t1 = task::Builder::default()</span><br><span class="line">        .name(<span class="string">"t1"</span>)</span><br><span class="line">        .spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="keyword">let</span> permit = semaphore.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">                 <span class="comment">// 注意. 增加等待时间，便于观测</span></span><br><span class="line">                sleep(Duration::from_secs(i)).<span class="keyword">await</span>;</span><br><span class="line">                <span class="comment">// 消耗令牌，不放回令牌桶1</span></span><br><span class="line">                permit.forget();</span><br><span class="line">                <span class="comment">// 令牌桶2增加令牌，可以打印2</span></span><br><span class="line">                semaphore_wait2.add_permits(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = task::Builder::default()</span><br><span class="line">        .name(<span class="string">"t2"</span>)</span><br><span class="line">        .spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="keyword">let</span> permit = semaphore_wait.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">                <span class="comment">// 注意. 增加等待时间，便于观测</span></span><br><span class="line">                sleep(Duration::from_secs(i)).<span class="keyword">await</span>;</span><br><span class="line">                <span class="comment">// 消耗令牌，不放回令牌桶2</span></span><br><span class="line">                permit.forget();</span><br><span class="line">                <span class="comment">// 令牌桶1增加令牌，可以打印1</span></span><br><span class="line">                semaphore2.add_permits(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    tokio::try_join!(t1, t2).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观测效果"><a href="#观测效果" class="headerlink" title="观测效果"></a>观测效果</h2><p>得到的观测结果如下，可以切换为<code>task</code>视图(按键<code>t</code>)和<code>resource</code>视图(按键<code>r</code>)：</p><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>对于<code>task</code>能看到调度时间（<code>Total, Busy, Sched, Idle</code>），次数(<code>Polls</code>)，状态(<code>state</code>)等。</p><blockquote><p>想详细了解时间可以看看这篇博客：<a href="https://hegdenu.net/posts/task-scheduled-time-in-console/" target="_blank" rel="noopener">task-scheduled-time-in-console</a></p></blockquote><p><img src="/images/rust/async-task.png" alt="task"></p><p>左右按键可以选择列，上下按键可以选择行，回车会展开对应行详情， 比如<code>task-t2</code></p><p>里边能看到相应waker的一些信息，也会有更细粒度的时间分布图</p><p>比较容易发现耗时不正常的<code>task</code>。</p><p><img src="/images/rust/async-task-detail.png" alt="task-detail"></p><h3 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h3><p>对于<code>resource</code>, 能看到执行了哪些类型的异步操作</p><p><img src="/images/rust/async-resource.png" alt="resource"></p><p>详情中是对这个操作不同时间调用的详细展开。</p><p>比如<code>t2</code>中<code>semaphore_wait.acquire</code>的三次调用</p><p><img src="/images/rust/async-resource-detail.png" alt="resource-details"></p><p>本文代码详见<a href="https://github.com/NewbMiao/rust-koan/tree/master/tokio-play" target="_blank" rel="noopener">tokio-play</a></p><p>想查看更多异步观测的例子建议查看下<a href="https://github.com/tokio-rs/console/tree/main/console-subscriber/examples" target="_blank" rel="noopener">官方的例子</a></p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      tokio之如何观测Rust异步任务的调度
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="tokio" scheme="https://newbmiao.github.io/tags/tokio/"/>
    
      <category term="tracing" scheme="https://newbmiao.github.io/tags/tracing/"/>
    
  </entry>
  
  <entry>
    <title>Rayon魔法：使Rust并行编程变得轻而易举</title>
    <link href="https://newbmiao.github.io/2024/01/13/rust-rayon-parallel.html"/>
    <id>https://newbmiao.github.io/2024/01/13/rust-rayon-parallel.html</id>
    <published>2024-01-13T03:43:34.000Z</published>
    <updated>2024-01-13T10:05:36.180Z</updated>
    
    <content type="html"><![CDATA[<p><code>Rayon</code>库是一个数据并行化（<code>data-parallelism</code>）的 <code>Rust</code>库。在并行编程里是一个很有趣的存在， 且非常的容易上手。它可以很轻松的将同步计算流程转化为并行计算。而且基本能保证编译通过就不会有<code>data race</code>。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="同步转并行"><a href="#同步转并行" class="headerlink" title="同步转并行"></a>同步转并行</h2><p>假设有个如下的求和的同步代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> sum: <span class="built_in">i32</span> = (<span class="number">0</span>..<span class="number">100</span>)</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|i| &#123;</span><br><span class="line">            <span class="comment">// Simulate some computation</span></span><br><span class="line">            sleep(Duration::from_nanos(<span class="number">1</span>));</span><br><span class="line">            i</span><br><span class="line">        &#125;)</span><br><span class="line">        .sum();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">4950</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要转成并行，只需要<code>into_iter</code>变成<code>into_par_iter</code></p><p><code>Rayon</code>会将同步的遍历转成并行的遍历，而且保证返回的顺序是一致的，瞬间并行是不是！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sum: <span class="built_in">i32</span> = (<span class="number">0</span>..<span class="number">100</span>)</span><br><span class="line">        .into_par_iter() <span class="comment">// 这里</span></span><br><span class="line">        .map(|i| &#123;</span><br><span class="line">            <span class="comment">// Simulate some computation</span></span><br><span class="line">            sleep(Duration::from_nanos(<span class="number">1</span>));</span><br><span class="line">            i</span><br><span class="line">        &#125;)</span><br><span class="line">        .sum();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">4950</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>divan</code>在 10核的M1 pro上测试结果如下，一行改变让代码速度提升了不少。</p><table><thead><tr><th>Benchmark</th><th>Fastest</th><th>Slowest</th><th>Median</th><th>Mean</th><th>Samples</th><th>Iterations</th></tr></thead><tbody><tr><td>iter</td><td>549.2 µs</td><td>1.244 ms</td><td>687.4 µs</td><td>738.5 µs</td><td>100</td><td>100</td></tr><tr><td>par_iter</td><td>195 µs</td><td>488.1 µs</td><td>315.1 µs</td><td>321.9 µs</td><td>100</td><td>100</td></tr></tbody></table><!-- ![bench](/images/rust/rayon_par_bench.png) --><h2 id="背后的魔法"><a href="#背后的魔法" class="headerlink" title="背后的魔法"></a>背后的魔法</h2><p>这个并行遍历是怎么处理的呢？</p><p><code>Rayon</code>利用一个可伸缩线程池来执行并行任务，默认情况下，线程池的大小与系统的逻辑核心数量相匹配。</p><p>在进行并行任务时，<code>Rayon</code>将当前任务拆分成多个子任务（依据线程池大小），并尽可能地将它们分配给空闲的线程以执行，每个线程有自己的本地任务队列。</p><p>如果当前有空闲线程，但已分配的任务仍在等待其线程完成当前任务，空闲线程将尝试执行<code>work stealing</code>，从其他线程任务队列中中窃取一些任务来执行，以确保最大程度地利用CPU资源。</p><p>最终，将并行任务的结果进行两两合并，将线程结果全部汇总以完成整个并行计算过程。</p><p>这里任务拆分和<code>work stealing</code>就是将并行任务分而治之的精髓。</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>其底层很多使用了<code>join</code>, 将两个任务并行执行，并等待任务结果一起返回：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (sum1, sum2) = rayon::join(</span><br><span class="line">        || v1.par_iter().sum::&lt;<span class="built_in">i32</span>&gt;(), </span><br><span class="line">        || v2.par_iter().sum::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"sum1: &#123;&#125;, sum2: &#123;&#125;"</span>, sum1, sum2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="par-bridge"><a href="#par-bridge" class="headerlink" title="par_bridge"></a>par_bridge</h2><p>常规能很容易并行化拆分的<code>par_iter</code>就可以了，但是如果遇到不容易并行化的（有阻塞等待等），如<code>channel</code>或者文件、网络IO的操作, 则可以用<code>par_bridge</code>。</p><p>性能会有些损耗，因为其执行的方式是每次获取下一个可遍历的内容，分发到线程池内可用线程上执行，同时也不保证结果返回的顺序。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::iter::ParallelBridge;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::ParallelIterator;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rx = &#123;</span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = channel();</span><br><span class="line"></span><br><span class="line">        (<span class="number">1</span>..=<span class="number">3</span>).into_iter().for_each(|i| &#123;</span><br><span class="line">            <span class="keyword">let</span> _ = tx.send(i);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rx</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> output: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = rx.into_iter().par_bridge().collect();</span><br><span class="line">    output.sort_unstable(); <span class="comment">// 重新保证顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;*output, &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，对于串行化遍历任务，一般都可以用<code>Rayon</code>转化为并行处理，当然也要看有没有转化的必要，常规简单遍历自然是不需要并行化的，毕竟线程和任务并行调度也是有开销的。</p><p>想了解更多，推荐看看<a href="https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/" target="_blank" rel="noopener">Rayon: data parallelism in Rust</a></p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rayon魔法：使Rust并行编程变得轻而易举
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rayon" scheme="https://newbmiao.github.io/tags/rayon/"/>
    
  </entry>
  
  <entry>
    <title>Rust异步编程之Future并发处理</title>
    <link href="https://newbmiao.github.io/2024/01/08/rust-async-multi-future-concurrency.html"/>
    <id>https://newbmiao.github.io/2024/01/08/rust-async-multi-future-concurrency.html</id>
    <published>2024-01-08T06:34:39.000Z</published>
    <updated>2024-01-06T17:02:59.781Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们知道，<code>Rust</code>的<code>Future</code>是异步执行，<code>await</code>时是阻塞在当前的异步任务<code>task</code>上，直到完成。</p><p>当多个异步任务执行时，如果只能都阻塞一个个执行，那就变成同步串行执行了，当然不是我们通常希望的并发处理方式，今天就来聊聊多个异步任务的一些并发处理方式。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>多个异步任务执行时，如果希望全部执行完成后统一返回，可以让他们都并发去执行，等全部完成后再一起返回。<code>join!</code>宏就可以实现它。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn1</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn2</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (first, second) = tokio::join!(async_fn1(), async_fn2());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(first, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(second, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-join"><a href="#try-join" class="headerlink" title="try_join"></a>try_join</h2><p>如果其中有失败的话，也会返回失败的<code>Err</code>。如果想一有失败就立马返回，不等待其他任务完成，可以使用<code>try_join!</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn1</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">u32</span>, &amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn2</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">u32</span>, &amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Err</span>(<span class="string">"async_fn2 failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> res = tokio::try_join!(async_fn1(), async_fn2());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> res &#123;</span><br><span class="line">        <span class="literal">Ok</span>((first, second)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"first = &#123;&#125;, second = &#123;&#125;"</span>, first, second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"error: &#123;&#125;"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p>上边<code>join</code>虽然是让多个异步任务并发执行，但其实际还是在同一个<code>task</code>上异步执行，如果想让每个异步任务都在一个新的<code>task</code>上<strong>独立</strong>执行，可以用<code>spawn</code>。</p><p>异步任务<code>spawn</code>后会在后台立即开始运行，即便没有对其返回的<code>JoinHandle</code>进行<code>await</code></p><p>这就有点像多线程里的<code>spawn</code>，只不过这里粒度不是线程，是<code>task</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::future::join_all;</span><br><span class="line"><span class="keyword">use</span> tokio::&#123;join, task::JoinHandle&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_op</span></span>(id: <span class="built_in">i32</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">"Start task &#123;&#125;"</span>, id);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> ops = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> tasks: <span class="built_in">Vec</span>&lt;JoinHandle&lt;<span class="built_in">String</span>&gt;&gt; = ops</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|op| tokio::spawn(async_op(op)))</span><br><span class="line">        .collect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// option 1</span></span><br><span class="line">    <span class="comment">// let outputs = join!(</span></span><br><span class="line">    <span class="comment">//     tasks.pop().unwrap(),</span></span><br><span class="line">    <span class="comment">//     tasks.pop().unwrap(),</span></span><br><span class="line">    <span class="comment">//     tasks.pop().unwrap()</span></span><br><span class="line">    <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!("&#123;:?&#125;", outputs);</span></span><br><span class="line">    <span class="comment">// tuple of results:</span></span><br><span class="line">    <span class="comment">// (Ok("Start task 3"), Ok("Start task 2"), Ok("Start task 1"))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// option 2</span></span><br><span class="line">    <span class="keyword">let</span> outputs = join_all(tasks).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, outputs);</span><br><span class="line">    <span class="comment">// vector of results:</span></span><br><span class="line">    <span class="comment">// [Ok("Start task 1"), Ok("Start task 2"), Ok("Start task 3")]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>如果是多个异步分支（<code>branch</code>）有一个完成就返回，并取消(<code>drop</code>来释放异步资源)其他异步分支的话，可以用<code>select</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn1</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn2</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        _ = async_fn1() =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"async_fn1() completed first"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        _ = async_fn2() =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"async_fn2() completed first"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><p>这里<code>select</code>会对每个分支随机执行，顺序是不保证的。如果期望顺序执行，可以用<code>biased</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            <span class="comment">// 顺序执行</span></span><br><span class="line">            biased;</span><br><span class="line"></span><br><span class="line">            _ = <span class="keyword">async</span> &#123;&#125;, <span class="keyword">if</span> count &lt; <span class="number">1</span> =&gt; &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">assert_eq!</span>(count, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            _ = <span class="keyword">async</span> &#123;&#125;, <span class="keyword">if</span> count &lt; <span class="number">2</span> =&gt; &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">assert_eq!</span>(count, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="precondition"><a href="#precondition" class="headerlink" title="precondition"></a>precondition</h3><p>上边例子中，分支使用了<code>if precondition</code>，如果当前<code>select</code>循环中运行到该分支，条件满足则执行；不满足的话会标记分支为失效（<code>disabled</code>）本次<code>select</code>中不会执行。</p><p>如果在<code>loop</code>中，下一次进入<code>select</code>循环会重新标记<code>disabled</code>状态</p><p>另外当前循环如果所以分支都被标记为<code>disabled</code>状态，就必须要有<code>else</code>分支，使<code>select</code>仍可运行。不然就会收到<code>panic</code>: <code>all branches are disabled and there is no else branch</code>.</p><h3 id="分支修改"><a href="#分支修改" class="headerlink" title="分支修改"></a>分支修改</h3><p><code>select</code>的分支也可修改， 比如下边通过<code>Pin::set</code>来修改<code>Pin</code>住的异步任务。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">action</span></span>(input: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> input &#123;</span><br><span class="line">        <span class="literal">Some</span>(input) =&gt; <span class="literal">Some</span>(input.to_string()),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = tokio::sync::mpsc::channel(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> operation = action(<span class="literal">None</span>);</span><br><span class="line">    tokio::pin!(operation);</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">1</span>).<span class="keyword">await</span>;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">3</span>).<span class="keyword">await</span>;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">2</span>).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">select!</span> &#123;</span><br><span class="line">            res = &amp;<span class="keyword">mut</span> operation, <span class="keyword">if</span> !done =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Got = &#123;:?&#125;"</span>, res);</span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(_) = res &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">Some</span>(v) = rx.recv() =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// `.set` is a method on `Pin`.</span></span><br><span class="line">                    operation.set(action(<span class="literal">Some</span>(v)));</span><br><span class="line">                    done = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第一个分支的<code>precondition</code>是必须的，不然就会有可能出现多次执行一个已完成的异步任务，会<code>panic</code>: <code>async fn resumed after completion</code>。</p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>最后在聊聊分支取消。</p><p>当<code>select</code>有分支完成时，其他分支会被取消。取消依托于<code>Drop</code>。当<code>future</code>被<code>drop</code>，其也会停止被异步调度。</p><p>比如下边代码，当<code>oneshot::Receiver</code>被取消而<code>Drop</code>时，会向<code>Sender</code>发送<code>close</code>通知，以便于清理<code>sender</code>并中断其执行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx1, rx1) = oneshot::channel::&lt;<span class="built_in">u32</span>&gt;();</span><br><span class="line">    <span class="keyword">let</span> (tx2, rx2) = oneshot::channel();</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            _ = tx1.closed() =&gt; &#123;</span><br><span class="line">                <span class="comment">// `val = rx1` is canceled</span></span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"tx1 closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = tx2.send(<span class="string">"two"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        val = rx1 =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"rx1 completed first with &#123;:?&#125;"</span>, val);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        val = rx2 =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"rx2 completed first with &#123;:?&#125;"</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust异步编程之Future并发处理
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="future" scheme="https://newbmiao.github.io/tags/future/"/>
    
  </entry>
  
  <entry>
    <title>Rust异步编程之Future初探</title>
    <link href="https://newbmiao.github.io/2024/01/06/rust-async-future.html"/>
    <id>https://newbmiao.github.io/2024/01/06/rust-async-future.html</id>
    <published>2024-01-05T23:10:51.000Z</published>
    <updated>2024-01-06T06:10:26.965Z</updated>
    
    <content type="html"><![CDATA[<p><code>Rust</code>的<code>Future</code>是用来实现异步编程的。今天我们围绕其了解下<code>Rust</code>的异步编程是如何构建。</p><p><code>Rust</code>用<code>async</code>就能轻松创建开销很小的可异步执行的函数，在<code>await</code>时其才会被调度执行。</p><p>其比较轻量级，有别于异步多线程，依托在操作系统线程之上，构建大量并发则需要大量的线程资源，对资源的消耗比较大。</p><p>比如下边用<code>async</code>构建异步任务：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn</span></span>() &#123;</span><br><span class="line">    <span class="comment">// handle async logic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    async_fn().<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p><code>async</code>其实也是帮你自动实现了下边的<code>Future trait</code>，用结构体维护了一个状态机</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;,</span><br><span class="line">    ) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Future</code>定义一个<code>poll</code>方法，可以查询异步任务状态。对于异步任务，有<code>Pending</code>和<code>Ready</code>两种状态，<code>Pending</code>时会让出控制，等待可以处理时再被唤醒继续处理，如此重复，直到<code>Ready</code>。</p><p>我们来尝试通过实现一个<code>Delay</code>的<code>Future</code>了解这个状态流转的过程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Delay</span></span> &#123;</span><br><span class="line">    when: Instant,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> Delay &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = &amp;<span class="symbol">'static</span> <span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;&amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> Instant::now() &gt;= <span class="keyword">self</span>.when &#123;</span><br><span class="line">            Poll::Ready(<span class="string">"done"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 还未ready，注册下一次唤醒</span></span><br><span class="line">            cx.waker().wake_by_ref();</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> when = Instant::now() + Duration::from_millis(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> future = Delay &#123; when &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> out = future.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(out, <span class="string">"done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Delay</code>每次<code>poll</code>时会检查，时间是否满足，满足则<code>Ready</code>，否则schedule下一次执行并返回<code>Pending</code></p><p>状态机是有了，<code>Future</code>怎么调度呢？</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p><code>Rust</code>需要运行时<code>runtime</code>来调度异步任务<code>task</code>，<code>runtime</code>负责调度，检查<code>future</code>的状态。</p><p>调度一般在<code>Pending</code>时会交出<code>task</code>的控制，并<code>schedule</code>下一次什么时候唤醒（<code>wake</code>）。</p><p>流程处理展开来说，常规<code>Ready</code>处理：</p><pre class="mermaid">graph TD    executor --> task    task -- poll --> future    future -- ready --> task</pre><p>而<code>Pending</code>时, <code>future</code>要被<code>schedule</code>下一次唤醒，而每次唤醒可能不会都是在同一个<code>task</code>上执行。<br>这里用于唤醒的<code>waker</code>会在每次<code>poll</code>时以<code>context</code>传递下去，</p><pre class="mermaid">graph TD    executor --> task    executor --> waker    executor -.-> task    task -- poll with context (waker) --> future    future -- update --> waker    future -- pending --> task    waker -- wake --> executor</pre><h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>了解了调度，我们再展开说下运行时。<code>rust</code>的运行时没在标准库中实现，需要依赖第三方的运行时，常用的有<code>tokio</code>。</p><p>就比如如下的<code>tokio</code>宏实际是添加了一个多线程（<code>multi thread</code>）的运行时，会阻塞当前线程直到异步任务完成。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tranform to</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    tokio::runtime::Builder::new_multi_thread()</span><br><span class="line">        .enable_all()</span><br><span class="line">        .build()</span><br><span class="line">        .unwrap()</span><br><span class="line">        .block_on(<span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Hello world"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以用单线程的运行时（<code>current thread</code>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main(flavor = <span class="meta-string">"current_thread"</span>)]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tranform to</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    tokio::runtime::Builder::new_current_thread()</span><br><span class="line">        .enable_all()</span><br><span class="line">        .build()</span><br><span class="line">        .unwrap()</span><br><span class="line">        .block_on(<span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Hello world"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>其实一般很少直接去实现<code>Future trait</code>, 直接使用<code>async</code>去自动实现<code>Future trait</code>就足够了。上边<code>Delay</code>完全可以这么实现，简洁且高效</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Notify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">delay</span></span>(dur: Duration) &#123;</span><br><span class="line">    <span class="keyword">let</span> when = Instant::now() + dur;</span><br><span class="line">    <span class="keyword">let</span> notify = Arc::new(Notify::new());</span><br><span class="line">    <span class="keyword">let</span> notify_clone = notify.clone();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> now = Instant::now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> now &lt; when &#123;</span><br><span class="line">            thread::sleep(when - now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notify_clone.notify_one();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    notify.notified().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    delay(Duration::from_secs(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h2><p>还记得<code>future trait</code>上参数有个<code>Pin&lt;&amp;mut Self&gt;</code>, 为什么要<code>Pin future</code>的引用？</p><p>来看下边一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">my_async_fn</span></span>() &#123;</span><br><span class="line">    <span class="comment">// async logic here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> future = my_async_fn();</span><br><span class="line">    (&amp;<span class="keyword">mut</span> future).<span class="keyword">await</span>;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="comment">// within `impl Future&lt;Output = ()&gt;`, the trait `Unpin` is not implemented for `[async fn body@src/main.rs:1:24: 3:2]`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当尝试执行一个异步函数的引用时，编译器会报错要求其是<code>Unpin trait</code>。</p><p>为什么呢？</p><p><code>future</code>本质是一个封装的状态机结构体，调度时会被移动，如果其包含引用，引用的地址要能保证生命周期至少在其完成前还存活，不然就会出现引用一个已失效的地址。</p><p>所以Rust引入了<code>Unpin trait</code>。 这个<code>Unpin</code>是代表其不需要固定地址，可以安全引用。</p><p>常规的类型一般都是实现了的。对于未实现的<code>!Unpin</code>类型，一般可以将其<code>Box::pin</code>到堆上或用宏<code>pin!</code>到栈上来确保其地址在<code>future</code>移动期间是有效的。</p><p>代码如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::pin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">my_async_fn</span></span>() &#123;</span><br><span class="line">    <span class="comment">// async logic here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> future = my_async_fn();</span><br><span class="line">    <span class="comment">// option 1</span></span><br><span class="line">    pin!(future);</span><br><span class="line">    (&amp;<span class="keyword">mut</span> future).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// option 2</span></span><br><span class="line">    <span class="comment">// let pinned_fut = Box::pin(future);</span></span><br><span class="line">    <span class="comment">// pinned_fut.await;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>好了，今天就聊到这里，下一篇我们再聊聊多个异步同时怎么处理。</p><p>对<code>Pin</code>感兴趣可以看看官方更详细的文档：<a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html" target="_blank" rel="noopener">Pinning</a></p><p>异步编程更深入了解的话也推荐看下tokio的这篇：<a href="https://tokio.rs/tokio/tutorial/async" target="_blank" rel="noopener">Async in depth</a></p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust异步编程之Future
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="futures" scheme="https://newbmiao.github.io/tags/futures/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Rust的Atomic及Ordering</title>
    <link href="https://newbmiao.github.io/2023/12/16/rust-sync-atomic.html"/>
    <id>https://newbmiao.github.io/2023/12/16/rust-sync-atomic.html</id>
    <published>2023-12-16T08:23:50.000Z</published>
    <updated>2023-12-18T11:27:26.342Z</updated>
    
    <content type="html"><![CDATA[<p>之前提到的<code>Mutex</code>、<code>Condvar</code>是<code>Rust</code>中比较偏高层的共享数据型并发控制，更底层的并发控制也有，比如<code>Atomic</code>（原子操作）。</p><p>今天结合代码来深入聊聊<code>Atomic</code>及其相关的<code>Ordering</code></p><a id="more"></a><!-- **文章目录** --><!-- [TOC] --><p>首先为什么要有Atomic，用Mutex不就可以了吗，我们来对比下</p><h2 id="Mutex-vs-Atomic"><a href="#Mutex-vs-Atomic" class="headerlink" title="Mutex vs Atomic"></a>Mutex vs Atomic</h2><p>1.从数据操作上对比：</p><p><code>Mutex</code>是并发下对数据的<strong>互斥访问控制</strong>，多个线程尝试写入，同时必须只能有一个线程争得锁，进而写入成功，其他线程只能等待其释放锁后再争夺锁。</p><p><code>Atomic</code>本身就是并发下对数据的原子操作，其操作是构建在操作系统的原子指令上，比如<code>读取（Load），写入（Store），比较写入(CAS，compare and swap)，自增（fetch_add）</code>等，操作要么成功要么失败，不可能被其他线程打断，出现中间状态，避免操作中数据竞争状态的发生。</p><p>也就是说<code>Atomic</code>是依赖底层系统的指令不可拆分达到无需锁（<code>lock free</code>）就能直接对数据地址共享操作。</p><p>2.从临界区构建上对比：</p><p><code>Mutex</code>是在加锁和释放锁之间构建了并发访问的临界区，进而进行数据操作。</p><p><code>Atomic</code>本身对于数据地址操作就是原子的，如果临界区想操作就是数据本身，那就不需要额外的保证</p><p>但如果还有别的数据需要在临界区操作，则需要通过<code>load/store/cas</code>等组合<code>wait loop</code>才能实现，也就是常说的自旋（spin），这也是更底层的方式。一般在对性能要求更细致场景会需要。</p><p>下边先用伪代码举例常见临界区的样子（后边会结合Ordering用代码详细展开）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="number">1</span>: </span><br><span class="line">    <span class="comment">// 条件满足设置flag</span></span><br><span class="line">    store/CAS flag: <span class="literal">false</span>-&gt;<span class="literal">true</span></span><br><span class="line">thread <span class="number">2</span>: </span><br><span class="line">    <span class="comment">// wait flag满足条件，模拟类似锁的阻塞, spin</span></span><br><span class="line">    <span class="keyword">while</span> load flag == <span class="literal">false</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 执行临界区操作</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="Atomic初探"><a href="#Atomic初探" class="headerlink" title="Atomic初探"></a>Atomic初探</h2><p>了解了<code>Atomic</code>的作用，下边先从一个例子了解下如何使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::atomic::&#123;AtomicBool, Ordering&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化原子bool类型</span></span><br><span class="line"><span class="keyword">static</span> FLAG: AtomicBool = AtomicBool::new(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = thread::spawn(|| &#123;</span><br><span class="line">        <span class="comment">// 原子操作修改</span></span><br><span class="line">        FLAG.store(<span class="literal">true</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> b = thread::spawn(|| &#123;</span><br><span class="line">        <span class="comment">// 原子操作读取</span></span><br><span class="line">        <span class="keyword">if</span> FLAG.load(Ordering::Relaxed) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Relaxed: Flag is set!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    a.join().unwrap();</span><br><span class="line">    b.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，两个线程分别对Flag修改和读取，读取时会尝试判断是否满足打印条件。</p><p>不过运行代码，打印不一定会发生。你可能觉得多线程下，两线程执行顺序不能保证，执行顺序可能是先load后store，这样的结果也很正常。</p><p>这是一种可能，然而远没有那么简单。</p><p>这里要提下指令重排和<code>Atomic</code>的<code>Ordering</code>排序</p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(a: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>, b: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    *a += <span class="number">1</span>;</span><br><span class="line">    *b += <span class="number">1</span>;</span><br><span class="line">    *a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你写下这段代码，交给操作系统编译执行，但很可能你得到的是这样的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(a: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>, b: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    *a += <span class="number">2</span>;</span><br><span class="line">    *b += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么？</p><p>操作系统处理器和编译器悄悄的帮你优化了代码来让他运行更快，这里规则是：</p><p><strong>只要不影响程序语义，指令可以重排执行以优化，即不按代码顺序执行</strong>。</p><p>单线程下这样问题可能还不大，但如果多线程下，同一线程下多条原子指令，也是会有指令重排的可能，数据竞争很有可能发生，就是说加了原子操作也无法确定数据操作顺序。</p><p>如以下代码：</p><p><strong>b线程的1和2不互相依赖，可以指令重排成2和1</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::atomic::&#123;AtomicI32, Ordering&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> X: AtomicI32 = AtomicI32::new(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">static</span> Y: AtomicI32 = AtomicI32::new(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> x = X.load(Ordering::Relaxed);</span><br><span class="line">        Y.store(x, Ordering::Relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> b = thread::spawn(|| &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">let</span> y = Y.load(Ordering::Relaxed);</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        X.store(<span class="number">42</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">    a.join().unwrap();</span><br><span class="line">    b.join().unwrap();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(X.load(Ordering::Relaxed), <span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 有可能, b线程的1和2不互相依赖，可以指令重排成2和1</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(Y.load(Ordering::Relaxed), <span class="number">42</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层的原子操作当然不能坐视不理，提出了<code>Ordering</code>来约束当前原子操作修改在其他多线程下的可见性，希望能约束<strong>当前线程发生原子操作如何同步到其他线程</strong>，能在并发中并发数据操作能有更好的<strong>确定性</strong>。</p><h2 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h2><p><code>Rust</code>用于的内存访问顺序（<code>memory order</code>）的<code>Ordering</code>基本和<a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener"><code>C++ 20</code>的内存排序</a>的保持一致， 下边先挨个过一遍</p><ul><li>Relaxed</li></ul><p>最基础的内存排序要求，只要求当前原子操作是要么完全执行，要么还未执行，其操作结果的可见性同步在其他线程没有任何顺序的保证（如指令重排代码所示）</p><ul><li>Acquire</li></ul><p>适用于读取数据操作，要求：</p><p>当前线程不能有<strong>其他的读或写被reorder在load之前</strong><br>其他线程的同一数据已发生的Release写入操作都是对其可见的。</p><ul><li>Release</li></ul><p>适用于写数据操作，要求：</p><p>当前线程不能有<strong>其他的读或写被reorder在store之后</strong><br>当前写入后的结果对其他线程的同一数据Acquire读取操作是可见的。</p><p>也就是说，这里线程间可见性要求，<code>acquire load</code>总是可以同步到其他线程已发生的<code>release store</code></p><p>结合代码来看就是（指令重排部分见注释）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::atomic::&#123;AtomicBool, Ordering&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 更严谨的测试可以用loom</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100000</span> &#123;</span><br><span class="line">        acquire_release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">acquire_release</span></span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> FLAG: AtomicBool = AtomicBool::new(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mut</span> DATA: <span class="built_in">u64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> a = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; DATA = <span class="number">42</span> &#125;;</span><br><span class="line">        FLAG.store(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">        <span class="comment">// 不允许有读写重排到store之后</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> b = thread::spawn(|| &#123;</span><br><span class="line">        <span class="comment">// 不允许有读写重排到load之前</span></span><br><span class="line">        <span class="keyword">while</span> !FLAG.load(Ordering::Acquire) &#123;&#125;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="keyword">unsafe</span> &#123; DATA &#125;, <span class="number">42</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    a.join().unwrap();</span><br><span class="line">    b.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AcqRel</li></ul><p>适用于同时读写操作（Read and write）,读操作用Acquire，写操作用Release</p><ul><li>SeqCst</li></ul><p>在保证读写一定是Acquire和Release的约束外，还保证<strong>其他线程看到的原子操作顺序一致</strong>，即<strong>全局只有一种内存结果可见顺序（a single total order）</strong>。</p><p>也就是说多线程下，即使执行顺序不能保证，但执行完后全局只能有一种原子操作的结果顺序，可以每次是不一样的（因为执行的先后不同），但一旦执行顺序确定后，就不可能有第二种原子操作结果的可能性存在。如同将不同线程的原子操作执行给串行化了一样。</p><p>所以内存顺序的严格程度就是从<code>Relax-&gt;Acquire+Relase-&gt;SeqCst</code>。越严格当然也会带来越多的性能开销。</p><p>来个代码帮助理解下用<code>Ordering</code>组合构建临界区：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicBool, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> lock = Arc::new(AtomicBool::new(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> lock_clone_read = lock.clone();</span><br><span class="line">    <span class="keyword">let</span> lock_clone_store = lock.clone();</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 持有锁</span></span><br><span class="line">        lock.store(<span class="literal">true</span>, Ordering::SeqCst);</span><br><span class="line">        <span class="comment">// 执行临界区操作</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待锁被获取</span></span><br><span class="line">    <span class="keyword">while</span> !lock_clone_read.load(Ordering::Acquire) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入临界区，可以放心的执行临界区操作了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Critical section!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock_clone_store.store(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Ordering的可见性"><a href="#验证Ordering的可见性" class="headerlink" title="验证Ordering的可见性"></a>验证Ordering的可见性</h2><p>原子操作结果可见性同步严格程度不同影响大么？</p><p>眼见为实，下边在通过一段<code>Relaxed</code>的代码先来验证下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::&#123;</span><br><span class="line">        atomic::&#123;AtomicBool, AtomicU64, Ordering&#125;,</span><br><span class="line">        Arc,</span><br><span class="line">    &#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> S: AtomicU64 = AtomicU64::new(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">relaxed</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Arc::new(AtomicBool::new(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> b = Arc::new(AtomicBool::new(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> a_clone = a.clone();</span><br><span class="line">    <span class="keyword">let</span> b_clone = b.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        a.store(<span class="literal">true</span>, Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">if</span> !b.load(Ordering::Relaxed) &#123;</span><br><span class="line">            S.fetch_add(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        b_clone.store(<span class="literal">true</span>, Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">if</span> !a_clone.load(Ordering::Relaxed) &#123;</span><br><span class="line">            S.fetch_add(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.join().unwrap();</span><br><span class="line">    t2.join().unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">        relaxed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果可能大于10000</span></span><br><span class="line">    <span class="keyword">let</span> s = S.load(Ordering::SeqCst);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s: &#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是S基本大于10000，为什么？我们展开分析下</p><p>两个<code>AtomicBool</code> A和B初始是false，两个线程用<code>Relaxed</code>先修改一个为true和再去读取另一个的值，如果判断读取到的值还是false就增加结果长度一次。</p><p>两个线程在判断是否增加结果长度时，会有以下几种可能：</p><ol><li>其他线程指令重排</li></ol><ul><li>修改排到load之后还没执行修改，S+1 （Relaxed时）</li></ul><ol start="2"><li>其他线程指令不重排</li></ol><ul><li>还没开始修改，S+1 </li><li>其他线程修改了，但对当前load不可见，S+1（Relaxed时） </li><li>其他线程修改了，对当前load可见，S不变</li></ul><p>所以指令重排和读取对修改不可见都会让S+1， <code>Relaxed</code>会有更多可能让S+1</p><p>所以遍历一次，两线程并发的情况下，如果S增加了2，则说明对于修改的可见性同步要求较弱，即使另一个线程修改了值，也没能及时同步到当前值的load</p><p>对于<code>Relaxed</code>约束，那么执行100000次，S很容易大于100000。</p><p>如果换成<code>SeqCst</code>，不允许上边代码中指令重排，又全局串行化了不同的原子操作。</p><p>如果其他线程修改发生在当前线程load之前，其一定是对当前线程load可见的，不会同时都不可见的可能性。所以S最多只能是100000。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t1 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    a.store(<span class="literal">true</span>, Ordering::SeqCst);</span><br><span class="line">    <span class="keyword">if</span> !b.load(Ordering::SeqCst) &#123;</span><br><span class="line">        S.fetch_add(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t2 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    b_clone.store(<span class="literal">true</span>, Ordering::SeqCst);</span><br><span class="line">    <span class="keyword">if</span> !a_clone.load(Ordering::SeqCst) &#123;</span><br><span class="line">        S.fetch_add(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="fence"><a href="#fence" class="headerlink" title="fence"></a>fence</h2><p><code>Ordering</code>除了可以对绑定到<strong>单个原子数据类型</strong>的操作上，也可以用在<code>fence</code>约束多条原子操作上，防止编译器和处理器对内存操作的重排，添加内存屏障（memory barrier），这也是构建临界区的一种方式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.store(<span class="number">1</span>, Release);</span><br><span class="line"><span class="comment">// 可以替换为</span></span><br><span class="line">fence(Release);</span><br><span class="line">a.store(<span class="number">1</span>, Relaxed);</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.load(Acquire);</span><br><span class="line"><span class="comment">// 可以被替换为</span></span><br><span class="line">a.load(Relaxed);</span><br><span class="line">fence(Acquire);</span><br></pre></td></tr></table></figure><p>这样拆分后，可以被扩展用作多个数据操作组合在线程间可见性的保证。也可以<strong>可选的选择</strong>什么时候用<code>acquire/release/seqcst</code></p><p>比如下边用原子操作和fence模拟锁的实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::AtomicBool;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::fence;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mutex</span></span> &#123;</span><br><span class="line">    flag: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Mutex &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Mutex &#123;</span><br><span class="line">        Mutex &#123;</span><br><span class="line">            flag: AtomicBool::new(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// relaxed+acquire fence 来及时同步已发生的unlock (release)</span></span><br><span class="line">        <span class="comment">// cas时没有直接使用严格的acquire</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span></span><br><span class="line">            .flag</span><br><span class="line">            .compare_exchange_weak(<span class="literal">false</span>, <span class="literal">true</span>, Ordering::Relaxed, Ordering::Relaxed)</span><br><span class="line">            .is_err()</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        fence(Ordering::Acquire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.flag.store(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p><code>Atomic</code>也常用来做资源的延迟初始化，让多线程共享一份资源。</p><p>比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::atomic::&#123;AtomicPtr, Ordering&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_data</span></span>() -&gt; Data &#123;</span><br><span class="line">    Data &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_data</span></span>() -&gt; &amp;<span class="symbol">'static</span> Data &#123;</span><br><span class="line">    <span class="keyword">static</span> PTR: AtomicPtr&lt;Data&gt; = AtomicPtr::new(std::ptr::null_mut());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> p = PTR.load(Ordering::Acquire);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p.is_null() &#123;</span><br><span class="line">        p = <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(generate_data()));</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = PTR.compare_exchange(</span><br><span class="line">            std::ptr::null_mut(),</span><br><span class="line">            p,</span><br><span class="line">            Ordering::Release,</span><br><span class="line">            Ordering::Acquire,</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// Safety: p comes from Box::into_raw right above,</span></span><br><span class="line">            <span class="comment">// and wasn't shared with any other thread.</span></span><br><span class="line">            <span class="built_in">drop</span>(<span class="keyword">unsafe</span> &#123; <span class="built_in">Box</span>::from_raw(p) &#125;);</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Safety: p is not null and points to a properly initialized value.</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123; &amp;*p &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(|| get_data());</span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(|| get_data());</span><br><span class="line">    <span class="keyword">let</span> (ret1, ret2) = (t1.join().unwrap(), t2.join().unwrap());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(ret1 <span class="keyword">as</span> *<span class="keyword">const</span> _, ret2 <span class="keyword">as</span> *<span class="keyword">const</span> _);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过一般情况下我们都没有需要自己去实现，很多crate都能实现类似操作，比如<a href="https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data" target="_blank" rel="noopener">OneCell</a></p><p>综上，<code>Atomic</code>是更底层的原子操作，为了同步原子操作的结果在其他线程的可见性以及约束编译器和操作系统的指令重排，也支持<code>Ordering</code>来提供不同程度的可见性保证。</p><p>深入了解<code>Atomic</code>并不意味着我们一定会用他来做一些<code>lock free</code>的开发，毕竟轮子已经有好多了，但至少能更好理解一些并发控制代码中原子操作的实现，也不会对各种<code>Ordering</code>傻傻分不清了。</p><p>最后推荐两个不错的<code>Atomic</code>资料，非常有助于理解，感兴趣的可以去看看</p><ul><li><a href="https://marabos.nl/atomics/memory-ordering.html" target="_blank" rel="noopener">Rust Atomics and Locks: memory ordering</a></li><li><a href="https://www.youtube.com/watch?v=rMGWeSjctlY" target="_blank" rel="noopener">Crust of Rust: Atomics and Memory Ordering</a></li></ul><!-- ---**欢迎关注公众号：newbmiao, 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Atomic
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="atomic" scheme="https://newbmiao.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Channel</title>
    <link href="https://newbmiao.github.io/2023/12/08/rust-sync-channel.html"/>
    <id>https://newbmiao.github.io/2023/12/08/rust-sync-channel.html</id>
    <published>2023-12-08T12:55:42.000Z</published>
    <updated>2023-12-09T09:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rust官方<code>sync</code>包中提供了<code>mpsc</code>模式的 (多生产者，单消费者：multi-producer, single-consumer) channel，可以实现基于消息并发控制，而不是依赖控制内存共享（加锁）。这正是go语言作者 <code>R. Pike</code> 所推崇的方式：</p><blockquote><p>Don’t communicate by sharing memory; share memory by communicating. (R. Pike)</p></blockquote><p>今天就聊聊<code>mpsc</code>提供的<code>sync_channel</code>和<code>channel</code>。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>首先一般channel机制都保证了</p><ul><li>生产者（producer/sender） 可以发送（send）消息，消费者（consumer/receiver）可以接受（recv）消息，生产和消费的顺序一致（一般都有消息队列保证顺序<code>FIFO</code>）</li><li>消费者在没有消息可接收前会阻塞等待，直到有消息或channel关闭</li><li>channel可以限制同时可处理消息上限（buffer size）</li><li>生产者发送的消息累积到buffer上限时就要阻塞到有消息被消费</li></ul><p>从这些规则中，可以看出，channel保证了生产总是先于消费，消息处理总是先进先出（<code>FIFO</code>）。</p><h2 id="sync-channel-spsc"><a href="#sync-channel-spsc" class="headerlink" title="sync_channel - spsc"></a>sync_channel - spsc</h2><p>buffer size 最特别的情况就是0，就是单生产者单消费者模式(<code>mpsc</code>)： send后会阻塞，直到有recv处理，才能再send下一个消息。</p><p>这就能很好的实现对并发顺序的控制， 比如下边代码，用两组channel实现1和2的交替打印。</p><p>不同channel的send和recv交叉等待，保证了打印的顺序，就像这中间持有锁一样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::sync_channel;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = sync_channel(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> (sender2, receiver2) = sync_channel(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(&#123;</span><br><span class="line">        <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">                <span class="comment">// t1打印完，通知t2的receiver打印</span></span><br><span class="line">                sender.send(<span class="number">2</span>).unwrap();</span><br><span class="line">                <span class="comment">// 阻塞，等待t2打印结束</span></span><br><span class="line">                receiver2.recv().unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(&#123;</span><br><span class="line">        <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="comment">// 阻塞，等待t1 sender的已打印的消息</span></span><br><span class="line">                receiver.recv().unwrap();</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">                <span class="comment">// t2打印完, 给t1 receiver2通知可以进行下一次打印</span></span><br><span class="line">                sender2.send(<span class="number">1</span>).unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.join().unwrap();</span><br><span class="line">    t2.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-channel-mpsc"><a href="#sync-channel-mpsc" class="headerlink" title="sync_channel - mpsc"></a>sync_channel - mpsc</h2><p>buffer size增加，就是正常<code>mpsc</code>摸式，可以控制同时能并发的上限（实际内部提前分配了数组来支持buffer）。</p><p>达到上限，sender就需要等待有receiver消费才能够继续发送消息。</p><p>当然没消息的话，别忘了drop也是可以结束recv一直等待消息的。</p><p>如下边代码所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::sync_channel;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = sync_channel(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sender2 = sender.clone();</span><br><span class="line">    <span class="keyword">let</span> sender3 = sender.clone();</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || sender.send(<span class="number">1</span>).unwrap());</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || sender2.clone().send(<span class="number">2</span>).unwrap());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drop</span>(sender3); <span class="comment">// 这里保证了第三个recv打印能成功</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, receiver.recv().unwrap());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, receiver.recv().unwrap());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, receiver.recv());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>明白了<code>sync_channel</code>，<code>channel</code>就简单了，就是buffer size无限模式（实际是内部维护了一个链表自动扩容）。 所有的send都不会阻塞，只有recv在没消息时需要阻塞等待channel中产生新的消息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::&#123;channel, sync_channel&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// let (sender, receiver) = sync_channel(1); // buffer为1的话，不会打印send no block</span></span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel(); <span class="comment">// 使用channel，send不阻塞，会打印</span></span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        sender.send(<span class="number">1</span>).unwrap();</span><br><span class="line">        sender.send(<span class="number">2</span>).unwrap();</span><br><span class="line">        sender.send(<span class="number">3</span>).unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"send no block"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, receiver.recv().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想及时check是否能recv消息时，可以用<code>try_recv</code></p><ul><li><code>TryRecvError::Empty</code>代表目前为空，但channel连接还在</li><li><code>TryRecvError::Disconnected</code>则是连接已关闭，不可能再受到消息了</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::&#123;channel, Receiver, RecvError, TryRecvError&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel();</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_recv_with_log</span></span>(receiver: &amp;Receiver&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">match</span> receiver.try_recv() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(v) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v),</span><br><span class="line">            <span class="literal">Err</span>(TryRecvError::Empty) =&gt; <span class="built_in">println!</span>(<span class="string">"error: Empty"</span>),</span><br><span class="line">            <span class="literal">Err</span>(TryRecvError::Disconnected) =&gt; <span class="built_in">println!</span>(<span class="string">"error: Disconnected"</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error: Empty</span></span><br><span class="line">    try_recv_with_log(&amp;receiver);</span><br><span class="line">    sender.send(<span class="number">1</span>).unwrap();</span><br><span class="line">    receiver.recv().unwrap();</span><br><span class="line">    <span class="built_in">drop</span>(sender);</span><br><span class="line">    <span class="comment">// error: Disconnected</span></span><br><span class="line">    try_recv_with_log(&amp;receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Sender&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> Sender&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Receiver&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> Receiver&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>最后来看看rust如何保证channel的并发安全</p><p><code>Sender&lt;T&gt;</code>同时支持<code>Send</code>和<code>Sync</code>，其维护的消息队列可以安全的在线程间传递所有权，也可以了共享引用，即可以被多个线程同时进行send操作。</p><p>其中<code>T</code>需要实现<code>Send</code>, 以确保消息可以在线程间安全传递所有权，避免竞争条件或使用已释放的内存</p><p>而<code>Receiver&lt;T&gt;</code>只支持Send，只能在线程间传递自身所有权，但不能在线程间共享引用。同时只能有一个线程拥有其所有权，进而独占的去消费<code>Sender&lt;T&gt;</code>的消息队列。</p><p>依旧是巧妙的通过<code>Send</code>和<code>Sync</code>标记trait保证了并发的安全，轻松实现无畏并发。</p><!-- ---**欢迎关注公众号：newbmiao, 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Channel
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="channel" scheme="https://newbmiao.github.io/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Semaphore-两线程交替打印</title>
    <link href="https://newbmiao.github.io/2023/11/24/rust-sync-semaphore.html"/>
    <id>https://newbmiao.github.io/2023/11/24/rust-sync-semaphore.html</id>
    <published>2023-11-24T10:57:56.000Z</published>
    <updated>2023-12-08T12:53:11.120Z</updated>
    
    <content type="html"><![CDATA[<p>信号量（Semaphore）是一种对资源并发访问控制的方式。</p><p>区别于互斥锁（Mutex）是对共享资源的独占访问，Semaphore允许指定多个并发访问共享资源。</p><p>就是说Semaphore像一个持有令牌（permit/token）的桶，每一个并发访问需要持有（acquire）一个令牌来访问共享资源，</p><p>当没有令牌时，没法访问共享资源，直到有新的令牌加入（add）或者原来发出的令牌放回（release）桶中。</p><p>接下来，我们尝试用通过用它来实现两个线程交替打印1和2，来更直观了解如何使用semaphore</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><blockquote><p>Rust std库中没有正式发布的semaphore（std::sync::Semaphore在1.7.0废弃了）。下边用tokio库提供的semaphore</p></blockquote><p>首先安装 tokio库</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 手动添加tokio到cargo.toml</span><br><span class="line"># 或使用cargo-add: cargo add tokio --features sync,macros,rt-multi-thread</span><br><span class="line">[dependencies]</span><br><span class="line">tokio = &#123; version = <span class="string">"1.34.0"</span>, features = [<span class="string">"sync"</span>, <span class="string">"macros"</span>, <span class="string">"rt-multi-thread"</span>] &#125;</span><br></pre></td></tr></table></figure><p>先来一版常规实现，初始化一个只有一个令牌的semahore，两个线程去并发持有令牌，用后释放（通过drop）令牌，实现交替打印</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> semaphore = Arc::new(Semaphore::new(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> semaphore2 = semaphore.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">let</span> permit = semaphore.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">            <span class="comment">// 可不写，离开scope时自动释放，放回令牌桶</span></span><br><span class="line">            <span class="built_in">drop</span>(permit); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="comment">// 或用 _ ignore返回值，即时回收令牌</span></span><br><span class="line">            <span class="keyword">let</span> _ = semaphore2.acquire().<span class="keyword">await</span>.unwrap(); </span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::try_join!(t1, t2).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看没什么问题，但是打印其实不一定是<code>1 2 1 2 1 2</code>的顺序。</p><p>原因很简单，我们只是约束了令牌同时只能有一个线程获取到，但是没有约束谁先谁后啊。所以其实没有实现交替打印。</p><p>怎么交替打印呢？</p><p>要控制顺序，我们可以让每个线程所持有的semaphore里的令牌时动态增加和消耗，然后一个令牌桶数量的增加滞后于另一个。</p><p>增加可以用add_permits， 消耗后不放回可以用forgot， 代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 线程1的令牌桶1初始一个令牌，可以先打印1</span></span><br><span class="line">    <span class="keyword">let</span> semaphore = Arc::new(Semaphore::new(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> semaphore2 = semaphore.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2的令牌桶2初始没有令牌，直到1打印后增加令牌</span></span><br><span class="line">    <span class="keyword">let</span> semaphore_wait = Arc::new(Semaphore::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> semaphore_wait2 = semaphore_wait.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">let</span> permit = semaphore.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">            <span class="comment">// 消耗令牌，不放回令牌桶1</span></span><br><span class="line">            permit.forget();</span><br><span class="line">            <span class="comment">// 令牌桶2增加令牌，可以打印2</span></span><br><span class="line">            semaphore_wait2.add_permits(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">let</span> permit = semaphore_wait.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">            <span class="comment">// 消耗令牌，不放回令牌桶2</span></span><br><span class="line">            permit.forget();</span><br><span class="line">            <span class="comment">// 令牌桶1增加令牌，可以打印1</span></span><br><span class="line">            semaphore2.add_permits(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::try_join!(t1, t2).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个动态的令牌桶（semaphore）线程的执行顺序就能交替执行了。</p><p>可以和上篇 <a href="https://mp.weixin.qq.com/s/5io-hBPlsO_buUILCjg7BA" target="_blank" rel="noopener">condvar实现的版本</a> 对比下， 感受下semaphore的魅力。</p><!-- ---**欢迎关注公众号：newbmiao, 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Semaphore-两线程交替打印
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="semaphore" scheme="https://newbmiao.github.io/tags/semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Condvar-两线程交替打印</title>
    <link href="https://newbmiao.github.io/2023/11/23/rust-sync-condvar-2.html"/>
    <id>https://newbmiao.github.io/2023/11/23/rust-sync-condvar-2.html</id>
    <published>2023-11-23T15:30:59.000Z</published>
    <updated>2023-12-08T12:53:11.119Z</updated>
    
    <content type="html"><![CDATA[<p>在并发控制的面试里有个很喜欢考的点：如何控制两个并发线程交替打印1和2。</p><p>实现的方式有很多，今天我们先用上篇提到的condvar试试。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><p>思路是利用条件变量来控制两个线程：</p><ul><li>线程1：当且仅当条件为false时开始打印1，并修改条件为true, 通知等待的另一个线程打印2，否则while阻塞等待</li><li>线程2：条件为false时阻塞等待notify，直到条件为true，然后重置条件为false，并打印2</li></ul><p>代码及注释如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Arc::new((Mutex::new(<span class="literal">false</span>), Condvar::new()));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> pair2 = pair.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair2;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(<span class="keyword">mut</span> v) = lock.lock() &#123;</span><br><span class="line">                <span class="comment">// 条件为false时开始打印1</span></span><br><span class="line">                <span class="comment">// 并修改条件为true, 通知等待的另一个线程打印2</span></span><br><span class="line">                <span class="keyword">if</span> !*v &#123;</span><br><span class="line">                    <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">                    *v = <span class="literal">true</span>;</span><br><span class="line">                    cvar.notify_one();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 及时释放锁，不让mutexguard被scope结束时才释放</span></span><br><span class="line">                    <span class="comment">// 如果后续没操作的话，可以不用这里drop，等离开scope时自动释放也一样</span></span><br><span class="line">                    <span class="built_in">drop</span>(v);</span><br><span class="line">                    <span class="comment">// [2]</span></span><br><span class="line">                    <span class="comment">// std::thread::sleep(std::time::Duration::from_millis(1));</span></span><br><span class="line">                    <span class="comment">// [1]</span></span><br><span class="line">                    <span class="comment">// print!(" waitting... ");</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> v = lock.lock().unwrap();</span><br><span class="line">            <span class="comment">// 条件为false时等待notify，直到条件为true</span></span><br><span class="line">            <span class="keyword">while</span> !*v &#123;</span><br><span class="line">                v = cvar.wait(v).unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置条件为false，并打印2</span></span><br><span class="line">            *v = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.join().unwrap();</span><br><span class="line">    t2.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果可以实现打印 <code>1 2 1 2 1 2</code></p><p>不过线程1用遍历阻塞其实还是消耗了不少cpu时间，恢复注释[1]的打印可以看出，又多次waitting输出</p><p>可以加一点等待 sleep 让出cpu占用，如注释[2]来减少频繁对锁的抢占。</p><p>其实这个题目用semaphore实现也很有意思，下一篇我们聊semaphore时再来看。</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Condvar-两线程交替打印
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="condvar" scheme="https://newbmiao.github.io/tags/condvar/"/>
    
  </entry>
  
  <entry>
    <title>博客地址已迁移到newbmiao.github.io</title>
    <link href="https://newbmiao.github.io/2023/11/20/blog-migrate-hostname.html"/>
    <id>https://newbmiao.github.io/2023/11/20/blog-migrate-hostname.html</id>
    <published>2023-11-20T04:49:22.000Z</published>
    <updated>2023-12-08T12:53:11.102Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p><strong>声明：博客地址已迁移到 <a href="https://newbmiao.github.io">https://newbmiao.github.io</a>, 原域名<del>blog.newbmiao.com</del>已不再使用。</strong></p><a id="more"></a><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      newbmiao.github.io
    
    </summary>
    
    
      <category term="blog" scheme="https://newbmiao.github.io/categories/blog/"/>
    
    
      <category term="blog" scheme="https://newbmiao.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Condvar</title>
    <link href="https://newbmiao.github.io/2023/11/18/rust-sync-condvar.html"/>
    <id>https://newbmiao.github.io/2023/11/18/rust-sync-condvar.html</id>
    <published>2023-11-18T11:44:31.000Z</published>
    <updated>2023-12-08T12:53:11.119Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>上次提到的<a href="https://mp.weixin.qq.com/s/X4hIhzggiv-nv4vAxvX6Rw" target="_blank" rel="noopener">Barrier</a>用到了Rust的condvar和mutex，今天来看下condvar的用法。</p><a id="more"></a><p>condvar即condition variable（条件变量），是一种线程同步的方式，用于线程间的通信。它可以阻塞（wait）线程，期间不消耗CPU，直到某个时间发生唤醒（notify）线程。</p><p>代码举例来说：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Arc::new((Mutex::new(<span class="literal">false</span>), Condvar::new()));</span><br><span class="line">    <span class="keyword">let</span> pair2 = Arc::clone(&amp;pair);</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> (lock, cvar) = &amp;*pair2;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> started = lock.lock().unwrap();</span><br><span class="line">        *started = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// We notify the condvar that the value has changed.</span></span><br><span class="line">        cvar.notify_one();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the thread to start up.</span></span><br><span class="line">    <span class="keyword">let</span> (lock, cvar) = &amp;*pair;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> started = lock.lock().unwrap();</span><br><span class="line">    <span class="keyword">while</span> !*started &#123;</span><br><span class="line">        started = cvar.wait(started).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，创建一个线程在修改started变量后唤醒等待的线程。main中等待的的线程会一直阻塞（wait）直到started的值被修改。</p><p>其中wait会需要一个锁的MutexGuard来配合，wait会自动释放锁，并阻塞当前线程，直到被唤醒时重新获取锁，并返回锁的MutexGuard，来获取锁当前保护的值</p><blockquote><p>Tips: MutexGuard实现了销毁时自动释放锁和可以通过解引用（deref）到它保护的值</p></blockquote><p>这里有两个有意思的点：</p><ul><li>为什么要和mutex一起使用？</li><li>为什么唤醒时要检查条件是否满足？</li></ul><p>这个要从condvar唤醒的机制说起。</p><h2 id="唤醒顺序不保证"><a href="#唤醒顺序不保证" class="headerlink" title="唤醒顺序不保证"></a>唤醒顺序不保证</h2><p>先来看下唤醒的顺序，我们起两批同样数目的线程，一批线程每个线程会修改一次变量并唤醒一个另一批等待的线程，为了观测唤醒顺序，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SharedData</span></span> &#123;</span><br><span class="line">    counter: Mutex&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">    condvar: Condvar,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> shared_data = Arc::new(SharedData &#123;</span><br><span class="line">        counter: Mutex::new(<span class="number">0</span>),</span><br><span class="line">        condvar: Condvar::new(),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> thread_num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> workers = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> waits = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..thread_num &#123;</span><br><span class="line">        do_wait(i, Arc::clone(&amp;shared_data), &amp;<span class="keyword">mut</span> waits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..thread_num &#123;</span><br><span class="line">        do_work(i, Arc::clone(&amp;shared_data), &amp;<span class="keyword">mut</span> workers)</span><br><span class="line">    &#125;</span><br><span class="line">    waits.into_iter().for_each(|w| w.join().unwrap());</span><br><span class="line">    workers.into_iter().for_each(|w| w.join().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_work</span></span>(i: <span class="built_in">i32</span>, data: Arc&lt;SharedData&gt;, workers: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;) &#123;</span><br><span class="line">    workers.push(thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> SharedData &#123; counter, condvar &#125; = &amp;*data;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> data = counter.lock().unwrap();</span><br><span class="line">        *data += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Woker thread &#123;&#125; before notify: Counter &#123;&#125;"</span>, i, data);</span><br><span class="line">        condvar.notify_one();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_wait</span></span>(i: <span class="built_in">i32</span>, data: Arc&lt;SharedData&gt;, waits: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;) &#123;</span><br><span class="line">    waits.push(thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> SharedData &#123; counter, condvar &#125; = &amp;*data;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> data = counter.lock().unwrap();</span><br><span class="line">        data = condvar.wait(data).unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"   Wait thread &#123;&#125; after wake up: Counter &#123;&#125;"</span>, i, data);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果不唯一，比如如下结果，五次修改触发了五次唤醒，但是wait唤醒顺序不一定是按照worker修改顺序（而修改顺序是符合预期的，因为是加锁保证的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Woker thread 0 before notify: Counter 1</span><br><span class="line">Woker thread 4 before notify: Counter 2</span><br><span class="line">Woker thread 2 before notify: Counter 3</span><br><span class="line">   Wait thread 1 after wake up: Counter 3</span><br><span class="line">   Wait thread 3 after wake up: Counter 3</span><br><span class="line">Woker thread 3 before notify: Counter 4</span><br><span class="line">   Wait thread 0 after wake up: Counter 4</span><br><span class="line">Woker thread 1 before notify: Counter 5</span><br><span class="line">   Wait thread 4 after wake up: Counter 5</span><br><span class="line">   Wait thread 2 after wake up: Counter 5</span><br></pre></td></tr></table></figure><p>甚至有可能是唤醒次数少于五次，导致有些线程一直阻塞，比如如下结果，只有四次唤醒，导致有1个线程一直阻塞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Woker thread 1 before notify: Counter 1</span><br><span class="line">   Wait thread 2 after wake up: Counter 1</span><br><span class="line">Woker thread 3 before notify: Counter 2</span><br><span class="line">Woker thread 0 before notify: Counter 3</span><br><span class="line">   Wait thread 4 after wake up: Counter 3</span><br><span class="line">Woker thread 4 before notify: Counter 4</span><br><span class="line">   Wait thread 3 after wake up: Counter 4</span><br><span class="line">   Wait thread 1 after wake up: Counter 4</span><br><span class="line">Woker thread 2 before notify: Counter 5</span><br><span class="line"><span class="comment"># 有一个线程一直阻塞在这里</span></span><br></pre></td></tr></table></figure><p>为什么顺序不保证呢？condvar实现是基于操作系统的条件变量实现，顺序取决于操作系统调度时当前可唤醒的线程是哪个，要保证唤醒顺序需要额外的开销，而这个开销是不必要的，因为唤醒顺序对于线程间的通信是没有意义的，所以底层实现并不保证唤醒顺序。<a href="https://www.reddit.com/r/C_Programming/comments/12itrvd/condition_variables_wakeup_ordering/" target="_blank" rel="noopener">这里</a>有相关讨论</p><p>所以多个线程等待同一条件变量时，notify_one唤醒和等待也不是一定是一对一的调用，每次唤醒也不能保证都是不同的等待线程。</p><p>至于为什么会有线程一直阻塞的情况，是因为唤醒次数少于等待次数，导致有些线程一直阻塞。<br>因为是多线程并发构建的notify_one和wait，存在调用notify_one时没有线程在等待的可能，导致唤醒次数少于等待次数的情况。</p><h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><p>还有就是虚假唤醒，即wait返回时，条件由于并发原因已经不满足，还可能因为唤醒并不是由于显示的notify调用，这个听起来很奇怪，但不是一个bug，是底层操作系统实现导致的，具体看看<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">wiki</a>上的说明吧。</p><p>综上这两点，condvar唤醒时是需要重新检查条件是否依旧满足，而且需要和mutex一起使用，来确保条件值获取的并发安全。</p><p>除此condvar还有一些方便的方法，比如提供了</p><ul><li>notify_all来广播唤醒所有等待的线程；</li><li>wait_while可以根据条件等待条件直到满足；</li><li>wait_timeout只等待一段时间如果不能及时被唤醒。</li></ul><p>官方文档都有例子，就不展开了。</p><p>关于condvar比较实际的例子有WaitGroup，不需要像Barrier一样初始化时指定线程数量，而是在运行时动态增加线程数量，在<a href="https://github.com/crossbeam-rs/crossbeam/blob/master/crossbeam-utils/src/sync/wait_group.rs" target="_blank" rel="noopener">crossbeam-utils</a>中有实现，代码很精炼，感兴趣可以看下</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Condvar
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="condvar" scheme="https://newbmiao.github.io/tags/condvar/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Barrier</title>
    <link href="https://newbmiao.github.io/2023/11/12/rust-sync-barrier.html"/>
    <id>https://newbmiao.github.io/2023/11/12/rust-sync-barrier.html</id>
    <published>2023-11-12T11:44:31.000Z</published>
    <updated>2023-12-08T12:53:11.119Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>Rust有很多种控制并发的方式，Barrier（屏障）是其中一种用来同步多线程计算的方式。</p><p>今天拿代码来简单看下。</p><a id="more"></a><p>比如我们要多线程计算，期望所有线程都计算完毕再输出最终结果。常规多线程代码示例可以用线程join来等待</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numthreads = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> my_mutex = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handlers = <span class="built_in">Vec</span>::with_capacity(numthreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..numthreads &#123;</span><br><span class="line">        <span class="keyword">let</span> my_lock = my_mutex.clone();</span><br><span class="line">        handlers.push(std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> guard = my_lock.lock().unwrap();</span><br><span class="line">            *guard += <span class="number">1</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> handler <span class="keyword">in</span> handlers &#123;</span><br><span class="line">        handler.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> answer = &#123; *my_mutex.lock().unwrap() &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(answer, numthreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果用Barrier，我们可以这么写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Barrier, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numthreads = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> my_mutex = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We use a barrier to ensure the readout happens after all writing</span></span><br><span class="line">    <span class="keyword">let</span> barrier = Arc::new(Barrier::new(numthreads + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..numthreads &#123;</span><br><span class="line">        <span class="keyword">let</span> my_barrier = barrier.clone();</span><br><span class="line">        <span class="keyword">let</span> my_lock = my_mutex.clone();</span><br><span class="line">        std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> guard = my_lock.lock().unwrap();</span><br><span class="line">            *guard += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Release the lock to prevent a deadlock</span></span><br><span class="line">            <span class="built_in">drop</span>(guard);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"thread &#123;&#125; is ready"</span>, i);</span><br><span class="line">            <span class="comment">// Blocks the current thread until all threads have rendezvoused here.</span></span><br><span class="line">            my_barrier.wait();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"thread &#123;&#125; is done"</span>, i)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A barrier will block `n`-1 threads which call [`wait()`] and then wake</span></span><br><span class="line">    <span class="comment">// up all threads at once when the `n`th thread calls [`wait()`].</span></span><br><span class="line">    barrier.wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> answer = &#123; *my_mutex.lock().unwrap() &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(answer, numthreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Barrier可以用wait来控制n个线程的同步，数量需要提前指明。<br>当调用wait时，如果不是第n个，就会一直阻塞当前线程，直到第n个wait调用，才能进行后续操作。</p><p>这种机制就像在多个线程中插入了一道屏障，当所有线程都执行到这里时，才能解除屏障继续向后执行。</p><p>当然这样实现相较于第一种，在线程数量大的时候也是会有比较明显的性能开销的，底层是使用condvar+mutex来实现的。这种组合也是一种有意思的并发控制方式，下次我们再聊聊它们。</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Barrier
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="barrier" scheme="https://newbmiao.github.io/tags/barrier/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Rust的并发约束：Send和Sync</title>
    <link href="https://newbmiao.github.io/2023/10/11/rust-send-and-sync-trait.html"/>
    <id>https://newbmiao.github.io/2023/10/11/rust-send-and-sync-trait.html</id>
    <published>2023-10-11T09:17:22.000Z</published>
    <updated>2023-12-08T12:53:11.119Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>不知道你有没有好奇过，<code>Rust</code>是怎么控制并发安全的。为什么编译器在编译时就能发现一些并发安全的问题。</p><p>今天拿例子聊聊这背后<code>Rust</code>的两个并发约束<code>trait</code>：<code>Sync</code>和<code>Send</code>，看看它们是怎么控制并发安全的。</p><a id="more"></a><h2 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h2><p>先来看看下边代码，尝试将<code>String</code>类型的引用计数<code>a</code>（<code>Rc&lt;String&gt;</code>）移动到另一个线程中去，会发现编译器报错了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, thread&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    <span class="comment">// 注意！这里move让闭包获取了a的所有权（Rc&lt;String&gt;）</span></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> b = a.clone();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// got error:</span></span><br><span class="line">    <span class="comment">// `Rc&lt;String&gt;` cannot be sent between threads safely</span></span><br><span class="line">    <span class="comment">// the trait `Send` is not implemented for `Rc&lt;String&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察编译器的报错和下边相关代码<code>trait</code>实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> Rc&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="built_in">FnOnce</span>() -&gt; T,</span><br><span class="line">    F: <span class="built_in">Send</span> + <span class="symbol">'static</span>,</span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="symbol">'static</span>,</span><br></pre></td></tr></table></figure><p>你会发现<code>thread::spawn</code>要求传入的闭包<code>F</code>必须实现<code>Send</code>，而<code>Rc</code>类型的<code>a</code>没有实现<code>Send</code>，所以编译器报错了。</p><p>我们知道<code>Rc</code>是引用计数，它为了性能没有实现原子操作的引用计数，如果在多个线程中共享，那么引用计数可能会出现计数错误，所以不能安全的跨线程共享。</p><p>那<code>Send</code>是干什么的呢？</p><p><code>Send</code>是一个<code>trait</code>，它标记了实现它的类型可以安全的在线程间<strong>传递</strong>所有权。也就是可以安全的<strong>移动</strong>（<code>move</code>）其所有权。</p><p><code>Send trait</code>是一个<strong>标记型（marker）</strong>的<code>trait</code>, 它没有实际方法，也不需要用户主动去实现，一般基本类型都实现了<code>Send</code>。而复合类型如果包含的所有成员都实现了<code>Send</code>，那么它也<strong>自动</strong>实现了<code>Send</code>。（后面的<code>Sync</code>也是这样的自动<code>trait</code>）</p><p>也就是说，需要并发中需要安全传递<strong>值</strong>都需要被标记实现<code>Send</code>，否则编译器会报错。</p><p>并发安全检查变成了<code>trait bound</code>检查，这样就能在编译时发现问题，而不是在运行时，是不是很巧妙！</p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>再来看看下边代码，尝试将<code>String</code>类型的引用计数<code>a</code>（<code>&amp;Rc&lt;String&gt;</code>）共享到一个线程中去，会发现编译器报错了。（注意没有移动，是共享）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, thread&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    <span class="comment">// 注意！这里没有用move，闭包获取的是a的引用（&amp;Rc&lt;String&gt;）</span></span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> b = a.clone();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// `Rc&lt;String&gt;` cannot be shared between threads safely</span></span><br><span class="line">    <span class="comment">// the trait `Sync` is not implemented for `Rc&lt;String&gt;`</span></span><br><span class="line">    <span class="comment">// required for `&amp;Rc&lt;String&gt;` to implement `Send`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然，<code>Rc</code>没有实现<code>Sync</code>，所有编译器报错了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> Rc&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Sync</code>也是一个标记型<code>trait</code>，它标记了实现它的类型可以安全的在线程间共享访问。</p><p>所谓共享，其实就是可以安全的引用。而如果<code>&amp;T</code>实现了<code>Send</code>（可安全移动），那么<code>T</code>就实现了<code>Sync</code>（可安全共享其的引用）。</p><p>也就是说，需要并发中需要安全<strong>引用</strong>（<code>&amp;T</code>）都需要<code>T</code>被标记实现了<code>Sync</code>，否则编译器会报错。</p><p>又是一个巧妙的设计，通过<code>trait bound</code>检查了引用是否满足并发安全。</p><p>总结一下：</p><ul><li><code>Send</code>标记了实现它的类型可以安全的在线程间传递所有权（<code>move</code>）。</li><li><code>Sync</code>标记了实现它的类型可以安全的在线程间共享引用（<code>&amp;T</code>）。</li></ul><p>最后推荐看看官方的这两篇文档来加深理解</p><ul><li><a href="https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html" target="_blank" rel="noopener">Extensible Concurrency with the Sync and Send Traits</a></li><li><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html" target="_blank" rel="noopener">Send and Sync</a></li></ul><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊Rust的并发约束：Send和Sync
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="send" scheme="https://newbmiao.github.io/tags/send/"/>
    
      <category term="sync" scheme="https://newbmiao.github.io/tags/sync/"/>
    
  </entry>
  
  <entry>
    <title>聊聊共享所有权之Rc和Arc</title>
    <link href="https://newbmiao.github.io/2023/10/07/ownership-of-rc-and-arc.html"/>
    <id>https://newbmiao.github.io/2023/10/07/ownership-of-rc-and-arc.html</id>
    <published>2023-10-07T11:44:05.000Z</published>
    <updated>2023-12-08T12:53:11.118Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><h2 id="1v1-所有权"><a href="#1v1-所有权" class="headerlink" title="1v1 所有权"></a>1v1 所有权</h2><p><code>Rust</code>中所有权约束了值只能有一个所有者，当值离开作用域时，它将被销毁。</p><p>像如下代码，字符串<code>a</code>如果直接移动给<code>b</code>后就没法后边再去打印，因为它的所有权已经转移给了<code>b</code>。</p><a id="more"></a><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"a = &#123;&#125;, b = &#123;&#125;"</span>, a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// got error:</span></span><br><span class="line"><span class="comment">// error[E0382]: borrow of moved value: `a`</span></span><br><span class="line"><span class="comment">// 3 |     let a = String::from("hello");</span></span><br><span class="line"><span class="comment">//   |         - move occurs because `a` has type `String`, which does not implement the `Copy` trait</span></span><br><span class="line"><span class="comment">// 4 |     let b = a;</span></span><br><span class="line"><span class="comment">//   |             - value moved here</span></span><br><span class="line"><span class="comment">// 5 |     println!("a = &#123;&#125;, b = &#123;&#125;", a, b);</span></span><br><span class="line"><span class="comment">//   |                                ^ value borrowed here after move</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝（clone）"><a href="#深拷贝（clone）" class="headerlink" title="深拷贝（clone）"></a>深拷贝（clone）</h2><p>如果<code>clone</code>的话可以复制一份，但是这样的话就需要开辟一块新的内存，不是很高效。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// let b = a;</span></span><br><span class="line"><span class="keyword">let</span> b = a.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"a = &#123;&#125;, b = &#123;&#125;"</span>, a, b);</span><br><span class="line"><span class="comment">// output: a = hello, b = hello</span></span><br></pre></td></tr></table></figure><h2 id="引用计数-（reference-count）"><a href="#引用计数-（reference-count）" class="headerlink" title="引用计数 （reference count）"></a>引用计数 （reference count）</h2><p>想要实现多个所有者，又开销小，可以用引用计数，对应的类型是<code>Rc</code>。</p><p><code>Rc</code>只会在复制时增加引用计数，当引用计数为0时，会自动调用<code>drop</code>方法，释放内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line"><span class="keyword">let</span> _b = Rc::clone(&amp;a);</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">let</span> _b = Rc::clone(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"reference count &#123;&#125;"</span>, Rc::strong_count(&amp;a)); </span><br><span class="line">    <span class="comment">// 3, will be 2 after this block out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"reference count &#123;&#125;"</span>, Rc::strong_count(&amp;a)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="写时复制（copy-on-write）"><a href="#写时复制（copy-on-write）" class="headerlink" title="写时复制（copy on write）"></a>写时复制（copy on write）</h2><p><code>Rc</code>引用的值是不可变的，如果想要修改，可以使用<code>Rc::make_mut</code>方法，它会检查引用计数，在有别的有效引用（<code>strong</code>）时，会复制一份，然后修改。否则就直接修改原来的值。这也是写时复制，只有在需要修改时才会复制。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line"><span class="keyword">let</span> b = Rc::clone(&amp;a);</span><br><span class="line"><span class="comment">//  allocate a new string (copy on write)</span></span><br><span class="line">(*Rc::make_mut(&amp;<span class="keyword">mut</span> a)).push_str( <span class="string">" world"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>,  a, b); </span><br><span class="line"><span class="comment">// hello world hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = Rc::clone(&amp;a);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125; &#123;&#125;"</span>,  a, b, c); </span><br><span class="line"><span class="comment">// hello world hello hello world</span></span><br></pre></td></tr></table></figure><p>所以这么用有一个好处，如果有修改，修改是独立于之前的引用的，不用担心修改会影响之前引用的值。</p><blockquote><p>当然，如果想保持值修改的同步，可以使用之前提到的<code>Cell</code>和<code>RefCell</code>，这两个类型可以实现内部可变性，可以在不可变引用的情况下修改值。</p></blockquote><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p><code>Rc</code>是不允许循环引用的，因为它的引用计数是在编译时就确定的，如果有循环引用，那么引用计数永远不会为0，也就永远不会调用<code>drop</code>方法，导致内存泄漏。</p><p>这里用官方的一个例子说明：下边代码用来描述工具（gadget）和工具所有者（owner）的关系，一个工具可以有一个个所有者，一个所有者可以有多个工具。</p><p>如果用<code>Rc</code>来实现的话，会出现循环引用，工具和工具所有者互相引用，导致谁都无法对引用计数减一，也就无法释放对应的内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    gadgets: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Gadget&gt;&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gadget</span></span> &#123;</span><br><span class="line">    id: <span class="built_in">i32</span>,</span><br><span class="line">    owner: Rc&lt;Owner&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> gadget_owner : Rc&lt;Owner&gt; = Rc::new(</span><br><span class="line">            Owner &#123; name: <span class="built_in">String</span>::from(<span class="string">"Gadget Man"</span>), gadgets: RefCell::new(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 两个工具，都有同一个所有者</span></span><br><span class="line">    <span class="keyword">let</span> gadget1 = Rc::new(Gadget &#123; id: <span class="number">1</span>, owner: gadget_owner.clone() &#125;);</span><br><span class="line">    <span class="keyword">let</span> gadget2 =Rc::new(Gadget &#123; id: <span class="number">2</span>, owner: gadget_owner.clone() &#125;);</span><br><span class="line"></span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(gadget1.clone());</span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(gadget2.clone());</span><br><span class="line">    <span class="comment">// 释放gadget_owner的引用计数，保留工具的owner引用计数</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget_owner);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1));</span><br><span class="line">    <span class="comment">// strong count of gadget1: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget1.owner: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放gadget1的引用计数，正常没有引用循环的话，owner对应的引用计数也需要释放</span></span><br><span class="line">    <span class="comment">// 但是gadget1的owner的引用计数不会减一，导致内存泄漏</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget2.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget2.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget2.owner: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环引用如下图所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gadgets和owner的引用形成了一个环，谁也没法释放，对应的引用计数无法减到0，也就没法释放</span><br><span class="line"></span><br><span class="line">+-----------+       +-----------+</span><br><span class="line">|   Owner   |&lt;------|  Gadget   |</span><br><span class="line">|           |       |           |</span><br><span class="line">|   Rc      |       |   Rc      |</span><br><span class="line">|           |       |           |</span><br><span class="line">| gadgets --|------&gt;| owner ----+</span><br><span class="line">+-----------+       +-----------+</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>这个时候就是弱引用的用武之地了，弱引用不会增加引用计数，所以不会导致循环引用。</p><p>但是它也不能保证引用的值一定存在，因为它的引用计数可能为0，所以用时，需要用<code>upgrade</code>方法来获取<code>Option</code>类型的引用。</p><p>也就是说引用的值释放与否只取决于强引用的引用计数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::rc::Weak;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    gadgets: RefCell&lt;<span class="built_in">Vec</span>&lt;Weak&lt;Gadget&gt;&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gadget</span></span> &#123;</span><br><span class="line">    id: <span class="built_in">i32</span>,</span><br><span class="line">    owner: Rc&lt;Owner&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> gadget_owner : Rc&lt;Owner&gt; = Rc::new(</span><br><span class="line">            Owner &#123;</span><br><span class="line">                name: <span class="string">"Gadget Man"</span>.to_string(),</span><br><span class="line">                gadgets: RefCell::new(<span class="built_in">Vec</span>::new())</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> gadget1 = Rc::new(Gadget&#123;id: <span class="number">1</span>, owner: gadget_owner.clone()&#125;);</span><br><span class="line">    <span class="keyword">let</span> gadget2 = Rc::new(Gadget&#123;id: <span class="number">2</span>, owner: gadget_owner.clone()&#125;);</span><br><span class="line"></span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget1.clone()));</span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget2.clone()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gadget_opt <span class="keyword">in</span> gadget_owner.gadgets.borrow().iter() &#123;</span><br><span class="line">        <span class="keyword">let</span> gadget = gadget_opt.upgrade().unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Gadget &#123;&#125; owned by &#123;&#125;"</span>, gadget.id, gadget.owner.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">drop</span>(gadget_owner);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1));</span><br><span class="line">    <span class="comment">// strong count of gadget1: 1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget1.owner: 2</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget2.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget2.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget2.owner: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><code>Rc</code>是线程不安全的，如果想要在多线程中使用，可以使用<code>Arc</code>，它是<code>Rc</code>的线程安全版本。 （<code>A</code>代表<code>atomic</code>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> val = Arc::new(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val = Arc::clone(&amp;val);</span><br><span class="line">        thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> v = *val.as_ref() + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;v:?&#125;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    thread::sleep(std::time::Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果想要在多线程中修改值，可以使用<code>Mutex</code>和<code>RwLock</code>，它们都是线程安全的。 如<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。</p><hr><p>最后还有一点想提下，<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>都实现了自动解引用<code>Deref</code>到<code>T</code>，所以可以直接在<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>上调用<code>T</code>的方法。而为了防止方法名冲突，一般习惯用全限定语法调用方法来调用<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>的方法，如<code>Rc::clone</code>。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](https://newbmiao.github.io/categories/opa/)[Dig101-Go系列](https://newbmiao.github.io/categories/go/dig101/)![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊所有权之Rc和Arc
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="ownership" scheme="https://newbmiao.github.io/tags/ownership/"/>
    
      <category term="rc" scheme="https://newbmiao.github.io/tags/rc/"/>
    
      <category term="arc" scheme="https://newbmiao.github.io/tags/arc/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Rust的Cell和RefCell</title>
    <link href="https://newbmiao.github.io/2023/10/03/rust-cell-and-refcell.html"/>
    <id>https://newbmiao.github.io/2023/10/03/rust-cell-and-refcell.html</id>
    <published>2023-10-03T08:53:52.000Z</published>
    <updated>2023-12-08T12:53:11.118Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>内部可变性（<code>interior mutability</code>）是<code>Rust</code>用来表示在一个值的外部看起来是不可变的，但是在内部是可变的。这种模式通常用于在拥有不可变引用的同时修改目标数据。</p><p><code>Cell</code>和<code>RefCell</code>是<code>Rust</code>提供的两种内部可变性的实现。<code>Cell</code>是用于<code>Copy</code>类型的，而<code>RefCell</code>是用于非<code>Copy</code>类型的。</p><p>不知道你有没有好奇过具体内部可变性应用在什么场景，为啥要分两种实现。</p><p>今天我们针对一些场景来聊聊这两个类型的应用。</p><a id="more"></a><h2 id="Why-interior-mutability"><a href="#Why-interior-mutability" class="headerlink" title="Why interior mutability?"></a>Why interior mutability?</h2><p>如下代码所示，当需要多个可变引用时，会违反<code>Rust</code>的所有权要求：同一时间只能有一个可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"><span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line">*z = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line"># will get error:</span><br><span class="line"># error[E0499]: cannot borrow `x` <span class="keyword">as</span> mutable more than once at a time</span><br><span class="line">#  --&gt; src/main.rs:<span class="number">5</span>:<span class="number">9</span></span><br><span class="line">#   |</span><br><span class="line"># <span class="number">4</span> | <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ------ first mutable borrow occurs here</span><br><span class="line"># <span class="number">5</span> | <span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ^^^^^^ second mutable borrow occurs here</span><br><span class="line"># <span class="number">6</span> | x = <span class="number">2</span>;</span><br><span class="line"># <span class="number">7</span> | *y = <span class="number">3</span>;</span><br><span class="line">#   | ------ first borrow later used here</span><br><span class="line"></span><br><span class="line"># error[E0506]: cannot assign to `x` because it is borrowed</span><br><span class="line">#  --&gt; src/main.rs:<span class="number">6</span>:<span class="number">1</span></span><br><span class="line">#   |</span><br><span class="line"># <span class="number">4</span> | <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ------ `x` is borrowed here</span><br><span class="line"># <span class="number">5</span> | <span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"># <span class="number">6</span> | x = <span class="number">2</span>;</span><br><span class="line">#   | ^^^^^ `x` is assigned to here but it was already borrowed</span><br><span class="line"># <span class="number">7</span> | *y = <span class="number">3</span>;</span><br><span class="line">#   | ------ borrow later used here</span><br></pre></td></tr></table></figure><p>这个时候就是内部可变性发挥作用的时候了。拿<code>Cell</code>来举例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = Cell::new(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> y = &amp;x;</span><br><span class="line"><span class="keyword">let</span> z = &amp;x;</span><br><span class="line">x.set(<span class="number">2</span>);</span><br><span class="line">y.set(<span class="number">3</span>);</span><br><span class="line">z.set(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x.get());</span><br></pre></td></tr></table></figure><p>通过<code>Cell</code>，其封装了<code>get</code>和<code>set</code>,可以在不需要显示声明为可变的情况下修改值。</p><h3 id="修改结构体的字段"><a href="#修改结构体的字段" class="headerlink" title="修改结构体的字段"></a>修改结构体的字段</h3><p>一般我们要修改一个结构体的值，需要将其声明为<code>mut</code>, 而对应的方法也需要接收<code>&amp;mut self</code> 举例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    age: <span class="built_in">u32</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">celebrate_birthday</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> current_age = <span class="keyword">self</span>.age;</span><br><span class="line">        <span class="keyword">self</span>.age = current_age + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> Person = Person::default();</span><br><span class="line">Person.celebrate_birthday();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Age after birthday: &#123;&#125;"</span>, Person.age);</span><br></pre></td></tr></table></figure><p>但是有时候我们并不想这么做，因为我们只是想<strong>修改其中的某个字段</strong>，而不是整个结构体，亦或者<strong>接口并不想暴露一个<code>&amp;mut self</code>的方法</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    age: Cell&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="comment">// 方法receiver无需声明为`mut`</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">celebrate_birthday</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> current_age = <span class="keyword">self</span>.age.get();</span><br><span class="line">        <span class="keyword">self</span>.age.set(current_age + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.celebrate_birthday();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Age after birthday: &#123;&#125;"</span>, person.age.get());</span><br></pre></td></tr></table></figure><h2 id="Cell-只适合-Copy-类型"><a href="#Cell-只适合-Copy-类型" class="headerlink" title="Cell 只适合 Copy 类型"></a>Cell 只适合 Copy 类型</h2><p>对于非<code>Copy</code>类型，<code>Cell</code>并不适用, 因为其约束了<code>get</code>方法的返回值必须是<code>Copy</code>类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>&gt; Cell&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(&amp;<span class="keyword">self</span>) -&gt; T &#123;</span><br></pre></td></tr></table></figure><p>那是不是不能往<code>Cell</code>里面放非<code>Copy</code>类型的值呢？当然不是，只是失去了意义，代码如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = Cell::new(<span class="built_in">String</span>::from(<span class="string">"value"</span>));</span><br><span class="line"><span class="comment">// 没有 `s.get()`，因为 `String` 不是 `Copy` 类型</span></span><br><span class="line"><span class="comment">// 而`get_mut()`返回的是 要求自身是可变的，就失去了用`Cell`的意义</span></span><br><span class="line">*s.get_mut() = <span class="built_in">String</span>::from(<span class="string">"value2"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s.into_inner());</span><br></pre></td></tr></table></figure><h2 id="RefCell-提供引用"><a href="#RefCell-提供引用" class="headerlink" title="RefCell 提供引用"></a>RefCell 提供引用</h2><p><code>RefCell</code>主要的不同是支持非<code>Copy</code>类型，且返回的是引用，而不是值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="string">"hello"</span>.to_owned());</span><br><span class="line">*c.borrow_mut() = <span class="string">"bonjour"</span>.to_owned();</span><br><span class="line"><span class="keyword">let</span> val = c.borrow();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;*val, <span class="string">"bonjour"</span>);</span><br></pre></td></tr></table></figure><h2 id="运行时检查"><a href="#运行时检查" class="headerlink" title="运行时检查"></a>运行时检查</h2><p>如果把上边代码换成如下先借用，编译能通过，但是运行时会报错。</p><p><code>RefCell</code> 依旧要遵守借用规则，只是推迟检查从编译期到运行时，如果违反了借用规则，会 <code>panic</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```rust</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="string">"hello"</span>.to_owned());</span><br><span class="line"><span class="keyword">let</span> val = c.borrow(); <span class="comment">// 先借用再修改，最后读取借用的值</span></span><br><span class="line">*c.borrow_mut() = <span class="string">"bonjour"</span>.to_owned();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;*val, <span class="string">"bonjour"</span>);</span><br><span class="line"></span><br><span class="line"># will panic:</span><br><span class="line"># thread <span class="symbol">'main</span>' panicked at <span class="symbol">'already</span> borrowed: BorrowMutError', src/main.rs:<span class="number">7</span>:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>综上可以看出，<code>Cell</code>和<code>RefCell</code>是不同粒度的内部可变性实现，简单的<code>Copy</code>类型可以考虑开销小的<code>Cell</code>来获取有内部可变性的<strong>值</strong>， 需要更灵活的内部可变<strong>借用</strong>就要用<code>RefCell</code>。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](https://newbmiao.github.io/categories/opa/)[Dig101-Go系列](https://newbmiao.github.io/categories/go/dig101/)![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊Rust的Cell和RefCell
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="cell" scheme="https://newbmiao.github.io/tags/cell/"/>
    
      <category term="refcell" scheme="https://newbmiao.github.io/tags/refcell/"/>
    
  </entry>
  
  <entry>
    <title>掌握Rust：从零开始的所有权之旅</title>
    <link href="https://newbmiao.github.io/2023/08/13/master-rust-ownership-from-scratch.html"/>
    <id>https://newbmiao.github.io/2023/08/13/master-rust-ownership-from-scratch.html</id>
    <published>2023-08-13T14:25:08.000Z</published>
    <updated>2023-12-08T12:53:11.118Z</updated>
    
    <content type="html"><![CDATA[<p>所有权是 <code>Rust</code> 很有意思的一个语言特性，但对于初学者却是一个比较有挑战的内容。</p><p>今天尝试用代码示例来聊聊 <code>Rust</code> 的所有权是什么，以及为什么要有所有权。希望能给初学的朋友一点帮助。</p><blockquote><p>Tips：文中代码有相应注释，建议可以先不用纠结细节，关注整体。后边可以再挨个去研究具体代码细节</p></blockquote><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="移动？拷贝？"><a href="#移动？拷贝？" class="headerlink" title="移动？拷贝？"></a>移动？拷贝？</h2><p>先来试试常规的赋值语句在<code>Rust</code>有什么样的表现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"start"</span>);</span><br><span class="line"><span class="comment">// code 1:</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> _b = a;</span><br><span class="line"><span class="keyword">let</span> _c = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code 2:</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> _e = d;</span><br><span class="line"><span class="keyword">let</span> _f = d;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `d`</span><br><span class="line">  --&gt; src/main.rs:<span class="number">12</span>:<span class="number">10</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> | <span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |     - move occurs because `d` has type `String`, which does not implement the `Copy` trait</span><br><span class="line"><span class="number">11</span> | <span class="keyword">let</span> _e = d;</span><br><span class="line">   |          - value moved here</span><br><span class="line"><span class="number">12</span> | <span class="keyword">let</span> _f = d;</span><br><span class="line">   |          ^ value used here after <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">help: consider cloning the value <span class="keyword">if</span> the performance cost is acceptable</span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> | <span class="keyword">let</span> _e = d.clone();</span><br><span class="line">   |           ++++++++</span><br></pre></td></tr></table></figure><p>为什么 <code>code 2</code> 出错了？ <code>code 1</code> 没有？</p><p>看起来都是初始化赋值操作，分别将数字 <code>a</code> 和字符串 <code>d</code> <strong>多次赋值</strong>给别的变量<br>为什么字符串的赋值失败了。</p><p>这里要引出 <code>Rust</code> 世界里对<strong>值拷贝</strong>和<strong>所有</strong>的区分</p><p>对于一切变量，当把他传递给别的变量或函数，如果他可以拷贝（<code>Copy</code>）就复制一份；否则就将值的所有权移动（<code>Move</code>）过去。</p><p>这里<code>a</code>是数字，数字是可以拷贝的，所以 <code>code 1</code> 是可以编译通过的。<br>而<code>d</code>是字符串，字符串是不可以拷贝的，第一次赋值就将所有权move给了<code>_e</code>，只能<code>move</code>一次，所以 <code>code 2</code> 编译不通过。</p><p>为什么要拷贝或移动？先剧透下 <code>Rust</code> 没有内存垃圾回收器（<code>GC</code>），它对内存的管理就是依赖所有权，谁持有（<code>Own</code>）变量，谁可以在变量需要销毁时释放内存。</p><p>我们拿代码看看它如何销毁变量</p><h2 id="作用域和销毁"><a href="#作用域和销毁" class="headerlink" title="作用域和销毁"></a>作用域和销毁</h2><p>这里我们关注在何时销毁的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为孤儿原则，包装原生string类型，来支持添加drop trait实现，来观察销毁</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyString</span></span>(<span class="built_in">String</span>);</span><br><span class="line"><span class="keyword">impl</span> MyString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        MyString(<span class="built_in">String</span>::from(name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyData</span></span> &#123;</span><br><span class="line">    data: MyString,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁时打印字符串</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyString with value: &#123;:?&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁时打印包含字符串的结构体</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyData &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyData with value: &#123;:?&#125;"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"not used"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> _wrapper = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as variable"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dropping MyData with value: MyString(<span class="string">"not used"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"not used"</span></span><br><span class="line">End of the scope inside main.</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as variable"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as variable"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>代码分了两个作用域（<code>Scope</code>）</p><blockquote><p>Tips: 其实有多个，每个<code>let</code>也可以看做是一个作用域，这里为了方便理解，只分了两个</p></blockquote><ul><li><p>main函数自身的<code>scope</code></p></li><li><p>main函数内的<code>scope</code></p><p>  在此作用域内<code>_</code>变量的结构体及包含的字符串就销毁了。<br>  这里<code>let _</code>代表这个变量被忽略，也无法再被别人使用，所以当即销毁</p><p>  离开此作用域时，局部变量<code>_wrapper</code>也被销毁</p></li></ul><p>结合之前字符串不能多次移动，这里就展示<code>Rust</code>对内存管理的两个原则：</p><ul><li><strong>值只能有一个所有者，当离开作用域，值将被丢弃</strong>。</li><li><strong>所有权可以转移</strong></li></ul><p>嗯，这么搞确实很利于内存管理。</p><p>那要只是想引用一个变量，不想移动怎么办？（毕竟移动只能一次）</p><h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>先来看看常规的“引用”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"start"</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> d = &amp;a;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="comment">// let ref d = a;</span></span><br><span class="line"><span class="keyword">let</span> _e = d;</span><br><span class="line"><span class="keyword">let</span> _f = d;</span><br></pre></td></tr></table></figure><p>这段代码是可以编译通过的</p><blockquote><p>Tips，<code>Rust</code>在编译阶段就能分析出很多代码问题，这也是为什么前边的错误里没有打印“start”，因为编译就失败了</p></blockquote><p><code>Rust</code>里对“引用”有细分，这里叫借用（<code>Borrow</code>），至于为什么，我们后边讲</p><p>从目前的代码看，如果一个变量借用了字符串变量，这个借用是可以赋值给多个变量的。</p><p>这样对于不需要<code>Move</code>整个字符串，只是要借用值来说，使用确实方便多了，那借用什么时候回收呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个借用结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDataRef</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    reference: &amp;<span class="symbol">'a</span> MyData,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的drop trait实现</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyDataRef&lt;<span class="symbol">'_</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyDataRef"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as variable"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> b = MyDataRef &#123; reference: &amp;a &#125;;</span><br><span class="line">        <span class="keyword">let</span> c = MyDataRef &#123; reference: &amp;a &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">End of the scope inside main.</span><br><span class="line">Dropping MyDataRef</span><br><span class="line">Dropping MyDataRef</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as variable"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as variable"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>在销毁借用的变量前，先销毁了所有的借用。哈哈，你可以有多个借用（准确说是<strong>不可变借用</strong>（<code>immutable borrow</code>），后边在展开），但销毁变量时，所有借用都会被一起销毁，这样保证你不是借用一个已经销毁的变量（<code>use after free</code>）</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>到这里我们都没有修改过一个变量</p><p><code>Rust</code>能像别的语言这样赋值修改么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>结果是不行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0384]: cannot assign twice to immutable variable `d`</span><br><span class="line">  --&gt; src/main.rs:<span class="number">33</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">32</span> |     <span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |         -</span><br><span class="line">   |         |</span><br><span class="line">   |         first assignment to `d`</span><br><span class="line">   |         help: consider making this binding mutable: `<span class="keyword">mut</span> d`</span><br><span class="line"><span class="number">33</span> |     d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br><span class="line">   |     ^ cannot assign twice to immutable variable</span><br></pre></td></tr></table></figure><p><code>Rust</code>对读取和修改是有区分的，像错误提示那样</p><p>需要<code>mut</code>关键字来声明变量可修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>那对应的销毁时什么样的呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> wrapper = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as mut variable1"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        wrapper.data = MyString::from(<span class="string">"used as mut variable2"</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"[Mutable] End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dropping MyString with value: <span class="string">"used as mut variable1"</span></span><br><span class="line">[Mutable] End of the scope inside main.</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as mut variable2"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as mut variable2"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>基本和之前不可变（<code>immutable</code>）变量销毁类似，唯一不同是赋值后，赋值前的值要被销毁，内存的管理很是细致啊。</p><p>现在说了借用，说了可变，我们可以来看看前边提到借用是有区分的：还有一个可变借用（<code>mutable borrow</code>）</p><h2 id="可变借用"><a href="#可变借用" class="headerlink" title="可变借用"></a>可变借用</h2><p>对于可变变量，是可以有对应的可变借用的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">*g = <span class="string">"world"</span>.to_string();</span><br></pre></td></tr></table></figure><p>那如果同时有可变借用和不可变借用，下边的代码可以么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> e = &amp;d;</span><br><span class="line">    <span class="keyword">let</span> f = &amp;d;</span><br><span class="line">    <span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">    *g = <span class="string">"world"</span>.to_string();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;f&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不可以</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `d` <span class="keyword">as</span> mutable because it is also borrowed <span class="keyword">as</span> immutable</span><br><span class="line"> --&gt; src/main.rs:<span class="number">5</span>:<span class="number">13</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> f = &amp;d;</span><br><span class="line">  |             -- immutable borrow occurs here</span><br><span class="line"><span class="number">5</span> |     <span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">  |             ^^^^^^ mutable borrow occurs here</span><br><span class="line"><span class="number">6</span> |     *g = <span class="string">"world"</span>.to_string();</span><br><span class="line"><span class="number">7</span> |     <span class="built_in">println!</span>(<span class="string">"&#123;f&#125;"</span>);</span><br><span class="line">  |               --- immutable borrow later used here</span><br></pre></td></tr></table></figure><p>编译器明确告诉我们，可变借用的时候不能同时有不可变借用。</p><p>为什么，如果拿<strong>读写互斥锁</strong>来类比，就很好理解了，我有可变借用，就像拿到写锁，这个时候是不允许有读锁的，不然我修改和你读取不一致怎么办。</p><p>这是就得出了所有权里借用的规则：</p><ul><li><strong>不可变借用可以有多个</strong></li><li><strong>可变借用同一时间只能有一个，且和不可变借用互斥</strong></li></ul><h2 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h2><p>到此，所有权的三条原则就全部出来了</p><ul><li>值有且只有一个所有者, 且所有者离开作用域时, 值将被丢弃</li><li>所有权可转移</li><li>借用<ul><li>不可变借用可以有多个</li><li>可变借用同一时间只能有一个</li></ul></li></ul><p>这些规则，规范了对于一个变量谁持有，离开作用域是否可以释放，变量的修改和借用有什么样要求，避免释放后的内存被借用，也防止修改和读取的内容不一致有<code>race condition</code>的问题。</p><p>最厉害的是这些都是编译阶段就分析保证了的，提前暴露了问题，不然等到代码上线了遇到问题再crash，追查起来就滞后太久了。</p><p>到这所有权就结束了么？还没有，快了，再耐着性子往下看</p><h2 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h2><p>目前为止，一个借用要么是只读的要么是可写的，限制都很严格，万一我想需要写的时候再可写，平时只要一个只读的借用就可以，能搞定么？</p><p>能！</p><p>Rust提供了<code>Cell</code>（针对实现<code>Copy</code>的简单类型）<br>和<code>RefCell</code>(针对任何类型，运行时做借用检查)<br><code>Arc</code>（多线程安全的引用计数类型）等类型，来支持内部可变性。<br><code>Mutex</code>和<code>RwLock</code>也是内部可变性的一种实现，只不过是在多线程场景下的。</p><blockquote><p>Tips: 本质上可以理解为对读写互斥的不同粒度下的封装，不需要显式声明可变借用，但内部有可变的能力</p></blockquote><p>以<code>RefCell</code>为例，来看看内部可变性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">let</span> value = RefCell::new(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Mutate the value using an immutable reference</span></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">let</span> borrowed = value.borrow();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Before mutation: &#123;&#125;"</span>, *borrowed);</span><br><span class="line"><span class="built_in">drop</span>(borrowed);</span><br><span class="line"><span class="comment">// Interior mutation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> borrowed_mut = value.borrow_mut();</span><br><span class="line">    *borrowed_mut += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">let</span> borrowed = value.borrow();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"After mutation: &#123;&#125;"</span>, *borrowed);</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>终于到了最后一个话题，生命周期</p><p>下边一段简单的字符串切片的长度比较函数</p><p>你能想到它为什么编译不通过么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(str1:  &amp;<span class="built_in">str</span>, str2: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str1.len() &gt; str2.len() &#123;</span><br><span class="line">        str1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">let</span> str2 = <span class="string">"world！"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest(str1, str2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:<span class="number">1</span>:<span class="number">39</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> | <span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(str1: &amp;<span class="built_in">str</span>, str2: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  |                  ----        ----     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function<span class="symbol">'s</span> <span class="keyword">return</span> <span class="class"><span class="keyword">type</span> <span class="title">contains</span></span> a borrowed value, but the signature does not say whether it is borrowed from `str1` or `str2`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> | <span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(str1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, str2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">  |           ++++        ++             ++          ++</span><br></pre></td></tr></table></figure><p>编译器再一次友好的提示我们，函数入参两个借用，返回值一个借用，无法确定返回值是用了哪个入参的生命周期。</p><p>一个新的概念出现了：<strong>生命周期</strong></p><p>生命周期是<code>Rust</code>用来标注引用存活周期，借此标识变量的借用与作用域是否合法，即借用是否在作用域内还有效，毕竟不能悬空指针（<code>dangling pointer</code>， 借用一个失效的内存地址）啊。</p><p>就像这里，函数返回一个借用，那返回的借用是否在作用域内合法，和入参的两个引用的关系是什么，靠的就是生命周期标注。如果入参和出参都是一个生命周期，即出参的借用在入参的借用作用域内，只要入参的生命周期合法，那出参的就是合法的。不然如果出参用了只是借用函数内部变量的生命周期，那函数返回后，函数内部变量就被销毁了，出参就是悬空指针了。</p><p>你可以简单理解为给借用多增加了一个参数，用来标识其借用在一个<code>scope</code>内使用是否合法。</p><blockquote><p>题外话，其实你如果了解<code>Golang</code>的逃逸分析，比如当函数内部变量需要返回给函数外部继续使用，其实是要扩大内部变量的作用域（即内部变量的生命周期），不能只依靠当前函数栈来保存变量，就会把它逃逸到堆上。 它做的其实也是变量的生命周期分析，用增加堆的内存开销来避免悬空指针。<br>只不过那是在gc基础上一种优化，而<code>Rust</code>则是在编译期就能通过生命周期标注就能确定借用是否合法。<br>对于想把内部变量返回给外部使用的情况，<code>Rust</code>也提供了<code>Box</code>来支持，这里就不展开了。</p></blockquote><p><strong>那是不是每个借用都要标注?</strong></p><p>也不是，rust默认会对所有借用自动标注，只有出现冲突无法自动标注的时候才需要程序员手动标注。如果感兴趣的话，可以深入看下<a href="https://doc.rust-lang.org/nomicon/subtyping.html" target="_blank" rel="noopener">Subtyping and Variance</a>，了解下生命周期的一些约束。</p><p>最后我们看下下边编译不通过的代码，从编译期的报错你就应该能明白，为什么要生命周期标注了，它对于让编译期做借用的作用域合法性检查很有用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_longest</span></span>&lt;<span class="symbol">'a</span>&gt;(str1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, str2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str1.len() &gt; str2.len() &#123;</span><br><span class="line">        str1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> str1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">let</span> str2 = <span class="string">"world!"</span>;</span><br><span class="line">        result = get_longest(str1.as_str(), str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `str1` does not live long enough</span><br><span class="line">  --&gt; src/main.rs:<span class="number">15</span>:<span class="number">30</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |         <span class="keyword">let</span> str1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |             ---- binding `str1` declared here</span><br><span class="line"><span class="number">14</span> |         <span class="keyword">let</span> str2 = <span class="string">"world!"</span>;</span><br><span class="line"><span class="number">15</span> |         result = get_longest(str1.as_str(), str2);</span><br><span class="line">   |                              ^^^^^^^^^^^^^ borrowed value does not live long enough</span><br><span class="line"><span class="number">16</span> |     &#125;</span><br><span class="line">   |     - `str1` dropped here <span class="keyword">while</span> still borrowed</span><br><span class="line"><span class="number">17</span> |</span><br><span class="line"><span class="number">18</span> |     <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">   |                                           ------ borrow later used here</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，收个尾吧：</p><ul><li>所有权关注的是值的拥有和管理</li><li>借用检查器在编译时保证借用的有效性和安全性</li><li>生命周期关注的是借用的有效范围和引用的合法性</li></ul><p>他们配合在一起，构建起了<code>Rust</code>强大的内存管理能力。避免了内存泄漏和悬空指针的问题，也避免了<code>GC</code>带来的性能问题。</p><p>怎么样？是不是感觉<code>Rust</code>的所有权设计还挺有意思的？一个所有权把内存管理的清晰又明了！</p><p>欢迎有问题的朋友留言讨论。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](https://newbmiao.github.io/categories/opa/)[Dig101-Go系列](https://newbmiao.github.io/categories/go/dig101/)![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      掌握Rust：从零开始的所有权之旅
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="ownership" scheme="https://newbmiao.github.io/tags/ownership/"/>
    
      <category term="borrow-checker" scheme="https://newbmiao.github.io/tags/borrow-checker/"/>
    
      <category term="lifetime" scheme="https://newbmiao.github.io/tags/lifetime/"/>
    
  </entry>
  
  <entry>
    <title>代码是负债，而不是资产</title>
    <link href="https://newbmiao.github.io/2023/08/12/seeing-code-as-debt-not-value.html"/>
    <id>https://newbmiao.github.io/2023/08/12/seeing-code-as-debt-not-value.html</id>
    <published>2023-08-12T10:19:54.000Z</published>
    <updated>2023-12-08T12:53:11.120Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《Google软件工程》，其中有一句话让我印象深刻：<br>代码是负债，而不是资产。</p><p>然而作为程序员，相信很多人都认为自己的代码就是资产，是自己智慧的结晶，怎么会是负债呢？</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><p>首先这个当然是要限定在软件工程领域来讨论。</p><p>在软件工程领域，代码的构建是要花费时间和人力成本的，但代码并不因此就能算作资产，真正有价值的是代码所要解决的产品问题，给用户和公司带来的价值。</p><p>而且写好的代码也是需要长期维护，长期运行的，而不是一次性的。<br>虽然维护的时间或长或短，决定于其服务的产品的生命。</p><p>所以代码是有维护成本的，就像负债，在没还清前，是需要源源不断的投入的。</p><p>我觉得这其实才道出了代码的本质。</p><p>为什么软件工程领域围绕代码有那么多方法论？</p><p>结对编程，代码评审，代码风格指南，测试驱动开发，设计文档评审，流水线集成和发布，清理技术负债，等等。</p><p>身处其中的程序员当然知道这是为了保证代码质量，但仅仅就是这样么？</p><p>要是从一开始就明白代码是负债，这一切就好理解了。</p><p>因为代码是需要维护的，不合理维护的代码就会像逐渐发霉的苹果，早晚有一天变成人人厌恶的坏代码，那些你眼里讨厌的legacy。</p><p>所以从一开始，代码就应该结合产品生命周期的规划，明白构建的代码将会存活大概多长时间。基于此再去设计，去实现，去计划相应的代码维护方案。</p><p>前期合适的流程能构建出当下场景合理的代码，避免代码一开始就腐烂。</p><p>但重要的是，团队能一开始就意识到代码需要长期合理的维护。</p><p>不会因为新需求的交付，而忽视那些将要后已经有问题但没人问津的技术负债。毕竟负债分散到日常去处理成本远远要小于最后一次偿还。</p><p>而且，当代码不能很好的服务产品的时候，要考虑何时弃用，将负债彻底清理。这反而是很多团队会忽略的东西。</p><p>不过有人就说，代码不用了不清理可以么？好像也没什么问题是不。</p><p>等遗留的旧代码依旧被别的代码引用，新老服务代码还有一些纠缠剪不断，代码仓库变得越来越臃肿，代码缺陷检查通不过，到时候开始抱怨的你猜会是谁？</p><p>到这里，你有没有发现，代码永远是程序员的负债，如果你自己还混不自知的话，最后很容易把自己搅入泥潭。</p><p>那个时候你能怪PM或者EM没有给你规划技术负债的清理维护么？</p><p>可能他们也知道，但是他们的屁股更关心的是需求的交付，产品的迭代。</p><p>而你有没有提前识别出代码负债的问题，有没有把技术负债也加入到日常交付中，是你要关心和负责的事情。</p><p>以前觉得软件工程都是些虚头巴脑的东西，不如写代码实在。</p><p>现在慢慢觉得写代码确实实在，但那些“虚头巴脑”的东西反而更考验一个程序员的能力。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](https://newbmiao.github.io/categories/opa/)[Dig101-Go系列](https://newbmiao.github.io/categories/go/dig101/)![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      代码是负债，而不是资产
    
    </summary>
    
    
      <category term="thoughts" scheme="https://newbmiao.github.io/categories/thoughts/"/>
    
      <category term="software-engineering" scheme="https://newbmiao.github.io/categories/thoughts/software-engineering/"/>
    
    
      <category term="thoughts" scheme="https://newbmiao.github.io/tags/thoughts/"/>
    
      <category term="software-engineering" scheme="https://newbmiao.github.io/tags/software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>深入解读-如何用keycloak管理external auth</title>
    <link href="https://newbmiao.github.io/2023/06/18/auth-manage-via-keycloak.html"/>
    <id>https://newbmiao.github.io/2023/06/18/auth-manage-via-keycloak.html</id>
    <published>2023-06-18T14:10:20.000Z</published>
    <updated>2023-12-08T12:53:11.117Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>提到<code>OAuth2</code>，大家多少都有些了解。</p><blockquote><p>不了解的话可以先看下之前的<a href="https://newbmiao.github.io/2021/09/19/tech-behind-authentication.html">简单聊聊鉴权背后的那些技术</a>先回顾一下基本概念和流程。</p></blockquote><p>简单来说，以<code>google</code>授权为例，一般就是通过用户授权页面登录<code>google</code>账号，再跳转用<code>code</code>换取到相应权限的<code>token</code>，就可以代表用户去发起一些<code>google api</code>的请求。</p><p>直接代码实现这套授权逻辑并不复杂，不过如果还需要接入<code>facebook</code>授权，<code>instagram</code>授权呢，总不能挨个去实现一遍吧。</p><p>最好能有一套通用的解决方案来解放双手， 今天我们就聊聊如何用<code>keycloak</code>实现一套通用的身份验证和授权管理方案。</p><blockquote><p>提前说明，无法本地复刻的技术方案不利于理解，也不利于方案探讨。虽然本文章所用代码是使用了<code>rust</code>的<code>axum</code>框架（为啥？因为<code>rust</code> is future！）+<code>keycloak</code>，但从服务启动到<code>keycloak</code>服务及相关配置，都用<code>docker-compose+terraform+shell</code> 脚本化管理，可100%本地复刻，欢迎本地尝试。（当然我说的是<code>Mac</code>下）代码地址： <a href="https://github.com/NewbMiao/axum-koans" target="_blank" rel="noopener">https://github.com/NewbMiao/axum-koans</a></p></blockquote><a id="more"></a><h2 id="初探OAuth"><a href="#初探OAuth" class="headerlink" title="初探OAuth"></a>初探<code>OAuth</code></h2><p>在引入<code>keycloak</code>之前我们以<code>google</code>为例先看下常规<code>OAuth</code>怎么接入，方便后边和<code>keycloak</code>接入对比。</p><blockquote><p>前置工作： 获取<code>google OAuth application</code>的<code>clientId</code>和<code>clientSecret</code>，不清楚的话，可以参考 <strong>Create a Google Application</strong> in <a href="https://keycloakthemes.com/blog/how-to-setup-sign-in-with-google-using-keycloak" target="_blank" rel="noopener">How to setup Sign in with Google using Keycloak</a></p></blockquote><p>如下图，一般授权流程（<code>standard flow</code>）中客户端和<code>auth server</code>主要是两个阶段</p><ul><li>生成<code>auth url</code>跳转登录后请求换取授权令牌的<code>code</code></li><li>在<code>auth callback</code>中用<code>code</code>换取<code>token</code>，得到能代表用户的<code>credentials</code>，一般是<code>accessToken</code></li></ul><p><img src="https://blog.postman.com/wp-content/uploads/2020/06/image5.png" alt="Authorization Code flow for OAuth"></p><p>这个流程自己也可以实现，但一般都用<code>oidc client</code>（其实现了<code>OpenID connect</code>协议，是建立在<code>OAuth2.0</code>上的身份验证协议，用来为应用提供用户身份信息）来实现。</p><p>编程语言实现上大同小异，下边代码以<code>rust</code>的<code>oauth2</code>库为例讲解</p><p>如果不熟悉<code>rust</code>，可以重点看<strong>代码注释</strong>，也不影响理解</p><h3 id="初始化oidc-client"><a href="#初始化oidc-client" class="headerlink" title="初始化oidc client"></a>初始化<code>oidc client</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::new</span></span><br><span class="line"><span class="comment">// 注册auth server 的授权登录地址，授权时会生成带有相应参数的 auth url</span></span><br><span class="line"><span class="keyword">let</span> auth_url =</span><br><span class="line">    AuthUrl::new(<span class="string">"https://accounts.google.com/o/oauth2/v2/auth"</span>.to_string()).unwrap();</span><br><span class="line"><span class="comment">// 注册auth server 的授权登录成功后要跳转到的客户端地址（auth callback url），会携带code</span></span><br><span class="line"><span class="keyword">let</span> redirect_url = RedirectUrl::new(config.redirect_url).unwrap();</span><br><span class="line"><span class="comment">// 注册auth server 的code换取token的地址</span></span><br><span class="line"><span class="keyword">let</span> token_url =</span><br><span class="line">    TokenUrl::new(<span class="string">"https://www.googleapis.com/oauth2/v3/token"</span>.to_string()).unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = BasicClient::new(</span><br><span class="line">    <span class="comment">// 注册google application client credentials, 会有相应权限和客户端限制，如web application类型会有访问地址origin及callback地址的白名单限制</span></span><br><span class="line">    ClientId::new(config.client_id),</span><br><span class="line">    <span class="literal">Some</span>(ClientSecret::new(config.client_secret)),</span><br><span class="line">    auth_url,</span><br><span class="line">    <span class="literal">Some</span>(token_url),</span><br><span class="line">)</span><br><span class="line">.set_redirect_uri(redirect_url);</span><br></pre></td></tr></table></figure><h3 id="生成auth-url"><a href="#生成auth-url" class="headerlink" title="生成auth url"></a>生成auth url</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::auth_url</span></span><br><span class="line"><span class="keyword">let</span> (url, csrf_token) = client</span><br><span class="line">    <span class="comment">// 参数是用于生成state的函数，这里用csrftoken,可以在auth callback中校验state参数是否合法</span></span><br><span class="line">    .authorize_url(CsrfToken::new_random)</span><br><span class="line">    <span class="comment">// auth请求需要的权限（scope）,一般获取用户信息的话，profile和email就好了</span></span><br><span class="line">    .add_scope(Scope::new(</span><br><span class="line">        <span class="string">"https://www.googleapis.com/auth/userinfo.profile"</span>.to_string(),</span><br><span class="line">    ))</span><br><span class="line">    .add_scope(Scope::new(</span><br><span class="line">        <span class="string">"https://www.googleapis.com/auth/userinfo.email"</span>.to_string(),</span><br><span class="line">    ))</span><br><span class="line">    <span class="comment">// 需要显示OAuth需要授权的内容给用户来确认是否同意，就是我们常见的google授权确认页面</span></span><br><span class="line">    .add_extra_param(<span class="string">"prompt"</span>, <span class="string">"consent"</span>)</span><br><span class="line">    <span class="comment">// 允许应用程序获得长期有效的访问令牌（accessToken）和刷新令牌(refreshToken)</span></span><br><span class="line">    .add_extra_param(<span class="string">"access_type"</span>, <span class="string">"offline"</span>)</span><br><span class="line">    .url();</span><br></pre></td></tr></table></figure><p>这里参数<code>access_type=offline</code>对于应用需要长期<code>accessToken</code>是很关键的。一般<code>accessToken</code>都有过期时间，如果没有有效的<code>refreshToken</code>来刷新<code>accessToken</code>，就会有<code>accessToken</code>失效后还要用户再登录的尴尬局面-_-!</p><p>另外为安全考虑除了可以用<code>state</code>做请求合法校验，还可以用<a href="https://blog.postman.com/pkce-oauth-how-to" target="_blank" rel="noopener"><code>PKCE(Proof Key for Code Exchange)</code></a>来加强, 实际用到的代码有实现，感兴趣可以看下</p><h3 id="auth-callback换取token"><a href="#auth-callback换取token" class="headerlink" title="auth callback换取token"></a>auth callback换取token</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::get_tokens</span></span><br><span class="line"><span class="comment">// 校验请求，state及pkce, 这里省略展示</span></span><br><span class="line"><span class="comment">// code 换取token</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> res = client.exchange_code(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求发送，axum中不能使用block请求，防止阻塞框架的异步事件循环</span></span><br><span class="line"><span class="keyword">let</span> res = res.request_async(async_http_client).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line"><span class="literal">Ok</span>(TokenInfo &#123;</span><br><span class="line">    refresh_token: res.refresh_token().unwrap().secret().to_string(),</span><br><span class="line">    access_token: res.access_token().secret().to_string(),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这部分不复杂，按文档配好本地，可以访问<code>http://localhost:8000/google/auth</code>来尝试上述<code>flow</code></p><h2 id="使用keycloak-IDP"><a href="#使用keycloak-IDP" class="headerlink" title="使用keycloak IDP"></a>使用keycloak IDP</h2><h3 id="keycloak-配置"><a href="#keycloak-配置" class="headerlink" title="keycloak 配置"></a>keycloak 配置</h3><p>上边流程怎么让keycloak这个身份和访问管理系统接管呢，答案是使用<code>keycloak IDP</code> (<code>Identity provider</code>)</p><p>我们先看下需要如何配置相应配置，这里先用<a href="https://registry.terraform.io/providers/mrparkers/keycloak/latest/docs" target="_blank" rel="noopener"><code>terraform - keycloak provider</code></a> 展示下配置。</p><blockquote><p>等效的页面配置可以后边参考之前的链接 <a href="https://keycloakthemes.com/blog/how-to-setup-sign-in-with-google-using-keycloak" target="_blank" rel="noopener">How to setup Sign in with Google using Keycloak</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 这里使用默认的admin-cli配置keycloak</span><br><span class="line"># 也可生成一个专门的client，用clientId+clientSecret的方式</span><br><span class="line">provider &quot;keycloak&quot; &#123;</span><br><span class="line">  client_id &#x3D; &quot;admin-cli&quot;</span><br><span class="line">  url       &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&quot;</span><br><span class="line">  username  &#x3D; &quot;***&quot;</span><br><span class="line">  password  &#x3D; &quot;***&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 1. 创建一个realm（领域），并启用, 类似命名空间，代表一个安全的独立区域</span><br><span class="line">resource &quot;keycloak_realm&quot; &quot;realm_axum_koans&quot; &#123;</span><br><span class="line">  realm   &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  enabled &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 2. 添加google idp， 这里需要google client credentials</span><br><span class="line"></span><br><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  realm         &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  # client_id和secret通过环境变量获取</span><br><span class="line">  client_id     &#x3D; var.google_client_id</span><br><span class="line">  client_secret &#x3D; var.google_client_secret</span><br><span class="line">  trust_email   &#x3D; true</span><br><span class="line">  # &quot;*&quot; 则不约束使用此idp的domain</span><br><span class="line">  hosted_domain &#x3D; &quot;*&quot;</span><br><span class="line">  sync_mode     &#x3D; &quot;IMPORT&quot;</span><br><span class="line">  provider_id   &#x3D; &quot;google&quot;</span><br><span class="line"></span><br><span class="line">  default_scopes &#x3D; &quot;openid profile email&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 3. 添加将要用来google auth打交道的client</span><br><span class="line">resource &quot;keycloak_openid_client&quot; &quot;client_axum_koans&quot; &#123;</span><br><span class="line">  realm_id &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  name     &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  enabled  &#x3D; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  client_id             &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  client_secret         &#x3D; &quot;***&quot;</span><br><span class="line">  standard_flow_enabled &#x3D; true</span><br><span class="line"></span><br><span class="line">  access_type &#x3D; &quot;CONFIDENTIAL&quot;</span><br><span class="line">  # 配置auth callback url</span><br><span class="line">  valid_redirect_uris &#x3D; [</span><br><span class="line">    &quot;http:&#x2F;&#x2F;localhost:8000&#x2F;keycloak&#x2F;login-callback&quot;</span><br><span class="line">  ]</span><br><span class="line">  web_origins        &#x3D; [&quot;*&quot;]</span><br><span class="line">  use_refresh_tokens &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看代码版的配置稍微有点多，主要配置其实就只有注释里的三处，然后google OAuth的代理设置就完成了，不信我们继续往下看怎么代码接入</p><h3 id="keycloak-auth接入"><a href="#keycloak-auth接入" class="headerlink" title="keycloak auth接入"></a>keycloak auth接入</h3><p>上边<code>keycloak</code>配置了<code>realm</code>，后边授权和<code>token</code>获取都会和这个<code>realm</code>下的<code>issueUrl</code>打交道，这里<code>issueUrl</code>就类似<code>google</code>的<code>auth server</code> 地址。 </p><ol><li>初始化<code>keycloak oidc client</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::new</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们配置生成的issue_url将会是： http://localhost:8080/realms/axum-koans</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置token url, auth url 和auth callback url(redirect url)</span></span><br><span class="line"><span class="keyword">let</span> token_url = TokenUrl::new(get_url_with_issuer(</span><br><span class="line">    &amp;config.issuer_url,</span><br><span class="line">    <span class="string">"/protocol/openid-connect/token"</span>,</span><br><span class="line">))</span><br><span class="line">.unwrap();</span><br><span class="line"><span class="keyword">let</span> auth_url = AuthUrl::new(get_url_with_issuer(</span><br><span class="line">    &amp;config.issuer_url,</span><br><span class="line">    <span class="string">"/protocol/openid-connect/auth"</span>,</span><br><span class="line">))</span><br><span class="line">.unwrap();</span><br><span class="line"><span class="keyword">let</span> redirect_url = RedirectUrl::new(config.redirect_url).unwrap();</span><br><span class="line"><span class="keyword">let</span> client = BasicClient::new(client_id, <span class="literal">Some</span>(client_secret), auth_url, <span class="literal">Some</span>(token_url))</span><br><span class="line">    .set_redirect_uri(redirect_url);</span><br></pre></td></tr></table></figure><ol start="2"><li>生成<code>auth_url</code></li></ol><p>方法基本和之前<code>google</code>配置一模一样。</p><p>这里也能看出为啥需要<code>oidc</code>协议，其实就是抽象化，提供了一种安全、标准化和可扩展的身份验证和授权协议。它简化了应用程序中的身份管理和访问控制，提供了一致的用户登录体验，并提高了应用程序的安全性。</p><p>这里<code>auth url</code>默认跳转的是<code>keycloak</code>登录页面，然后<code>google idp</code>是作为一种登录选项让用户选择。但如果就打算让用户直接<code>google</code>登录，可以跳过<code>keycloak</code>登录页。</p><p>方法是使用客户端建议的<code>idp（kc_idp_hint）</code>:<a href="https://www.keycloak.org/docs/latest/server_admin/#_client_suggested_idp" target="_blank" rel="noopener"><code>Client-suggested Identity Provider</code></a></p><p>这样就可以直接使用指定的<code>idp</code>进行授权登录</p><p>代码如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::auth_url</span></span><br><span class="line">client.add_extra_param(<span class="string">"kc_idp_hint"</span>, <span class="string">"google"</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li><code>auth callback</code>换取<code>token</code></li></ol><p>方法也同 <code>google auth callback</code>, 这里不赘述了。</p><p>不过这里拿到的是<code>keycloak</code>的<code>token</code>。要是需要<code>google</code>的<code>token</code>怎么办？</p><p>别急，有两种办法。</p><h2 id="方法一：-token-exchange"><a href="#方法一：-token-exchange" class="headerlink" title="方法一： token-exchange"></a>方法一： token-exchange</h2><p><a href="https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange" target="_blank" rel="noopener"><code>token-exchange</code></a> 是用于<code>token</code>交换场景，我们这里是用<code>keycloak token</code>换取外部<code>google token</code>（<code>external token</code>）</p><h3 id="相应keycloak配置"><a href="#相应keycloak配置" class="headerlink" title="相应keycloak配置"></a>相应<code>keycloak</code>配置</h3><blockquote><p><code>token-exchange</code>目前还是<code>keycloak</code>预览（<code>preview</code>）功能，需要至少在<code>features</code>中启用<code>admin-fine-grained-authz,token-exchange</code>才可使用(详见<code>keycloak docker-composer</code>配置 )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启用idp获取refresh token</span><br><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">  # for token exchange to get google access token</span><br><span class="line">  request_refresh_token &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启用 idp token exchange permission, 并用policy关联对应的client</span><br><span class="line">resource &quot;keycloak_identity_provider_token_exchange_scope_permission&quot; &quot;oidc_idp_permission&quot; &#123;</span><br><span class="line">  realm_id       &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  provider_alias &#x3D; keycloak_oidc_google_identity_provider.google.alias</span><br><span class="line">  policy_type    &#x3D; &quot;client&quot;</span><br><span class="line">  clients &#x3D; [</span><br><span class="line">    keycloak_openid_client.client_axum_koans.id</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> token_url =</span><br><span class="line">   <span class="built_in">format!</span>( <span class="string">"&#123;&#125;/protocol/openid-connect/token"</span>,&amp;<span class="keyword">self</span>.config.issuer_url);</span><br><span class="line"><span class="keyword">let</span> response = Client::new()</span><br><span class="line">    .post(token_url)</span><br><span class="line">    .form(&amp;[</span><br><span class="line">        <span class="comment">// token exchange type</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"grant_type"</span>,</span><br><span class="line">            <span class="string">"urn:ietf:params:oauth:grant-type:token-exchange"</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 传入keycloak access token</span></span><br><span class="line">        (<span class="string">"subject_token"</span>, &amp;access_token),</span><br><span class="line">        (<span class="string">"client_id"</span>, &amp;<span class="keyword">self</span>.config.client_id),</span><br><span class="line">        (<span class="string">"client_secret"</span>, &amp;<span class="keyword">self</span>.config.client_secret),</span><br><span class="line">        <span class="comment">// 请求换取google access token</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"requested_token_type"</span>,</span><br><span class="line">            <span class="string">"urn:ietf:params:oauth:token-type:access_token"</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 要换取的external idp: google</span></span><br><span class="line">        (<span class="string">"requested_issuer"</span>, <span class="string">"google"</span>),</span><br><span class="line">    ])</span><br><span class="line">    .send()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"><span class="comment">// json deserialized as access token</span></span><br><span class="line"><span class="literal">Ok</span>(from_str(&amp;response.text().<span class="keyword">await</span>?)?)</span><br></pre></td></tr></table></figure><p>这样就获取到了可用的<code>google access token</code>， 实际上内部是通过<code>google refresh token</code>换取到的。</p><p>这样常规请求没问题了，只要你有<code>keycloak access token</code>, 就能换取到<code>google access token</code>来请求<code>google api</code>。so easy?!</p><h2 id="方法二：broker-读取-stored-token"><a href="#方法二：broker-读取-stored-token" class="headerlink" title="方法二：broker 读取 stored token"></a>方法二：broker 读取 stored token</h2><p>然而，要是需要<code>google refresh token</code>怎么办？</p><p>有些场景是客户端需要自己通过<code>google refresh token</code>换取<code>access token</code>来发起请求的，难道这个时候客户端先去拿个<code>keycloak access token</code>么。。。？</p><p>这就可以用<a href="https://www.keycloak.org/docs/latest/server_admin/#retrieving-external-idp-tokens" target="_blank" rel="noopener">Retrieving external IDP tokens</a></p><p>底层实现是授权时存储了<code>external token</code>,再配合添加<code>broker read token</code>权限给生成的用户，就可以用<code>keycloak access token</code>换取存储的<code>external access token + refresh token</code>.</p><h3 id="相应keycloak配置-1"><a href="#相应keycloak配置-1" class="headerlink" title="相应keycloak配置"></a>相应keycloak配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">  # for retrieve idp token (with refresh token)</span><br><span class="line">  &#x2F;&#x2F; 存储idp token</span><br><span class="line">  store_token                   &#x3D; true</span><br><span class="line">  &#x2F;&#x2F; 用户生成是添加broker read token 权限</span><br><span class="line">  add_read_token_role_on_create &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题外话：这里<code>add_read_token_role_on_create</code>对应的配置在21.1.1版<code>keycloak admin</code>页面没有，但<code>admin api</code>确可以设置，也是很tricky</p></blockquote><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>就是直接换取<code>refresh_token</code>, 请求地址指明对应的<code>idp</code>即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::get_idp_token</span></span><br><span class="line"><span class="keyword">let</span> token_url = <span class="built_in">format!</span>( <span class="string">"&#123;&#125;/broker/google/token"</span>,&amp;<span class="keyword">self</span>.config.issuer_url);</span><br><span class="line"><span class="keyword">let</span> response = Client::new()</span><br><span class="line">    .get(token_url)</span><br><span class="line">    .bearer_auth(access_token)</span><br><span class="line">    .header(CONTENT_TYPE, HeaderValue::from_static(<span class="string">"application/json"</span>))</span><br><span class="line">    .send()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> res = response.text().<span class="keyword">await</span>?;</span><br><span class="line"><span class="literal">Ok</span>(from_str(&amp;res)?)</span><br></pre></td></tr></table></figure><blockquote><p>题外话：当然直接给用户这么获取<code>refresh token</code>的能力并不安全，还需要考虑对<code>broker read token</code>接口的访问约束等来更好的保证安全<code>token</code>换取。</p></blockquote><p>上边<code>keycloak</code>授权方案可以本地配好环境后，用<a href="http://localhost:8000/keycloak/login" target="_blank" rel="noopener">http://localhost:8000/keycloak/login</a> 来尝试。</p><hr><p>好了，<code>keycloak</code>如何管理<code>external auth</code>到这里就结束了。以上是我在使用<code>keycloak</code>的一些摸索和思考，欢迎大家一起探讨。</p><p>再次附上本文的代码地址以供验证：<a href="https://github.com/NewbMiao/axum-koans" target="_blank" rel="noopener">https://github.com/NewbMiao/axum-koans</a></p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](https://newbmiao.github.io/categories/opa/)[Dig101-Go系列](https://newbmiao.github.io/categories/go/dig101/)![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      深入解读-如何用keycloak管理external auth
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="terraform" scheme="https://newbmiao.github.io/tags/terraform/"/>
    
      <category term="oauth2" scheme="https://newbmiao.github.io/tags/oauth2/"/>
    
      <category term="OIDC" scheme="https://newbmiao.github.io/tags/OIDC/"/>
    
      <category term="axum" scheme="https://newbmiao.github.io/tags/axum/"/>
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="keycloak" scheme="https://newbmiao.github.io/tags/keycloak/"/>
    
      <category term="token-exchange" scheme="https://newbmiao.github.io/tags/token-exchange/"/>
    
  </entry>
  
</feed>
