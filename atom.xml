<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟Miao</title>
  <icon>https://www.gravatar.com/avatar/644a62fb3ee1c60061ebca1d0996b0ae</icon>
  <subtitle>start from a newb...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.newbmiao.com/"/>
  <updated>2023-10-11T08:59:17.704Z</updated>
  <id>http://blog.newbmiao.com/</id>
  
  <author>
    <name>菜鸟Miao</name>
    <email>newbvirgil@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊共享所有权之Rc和Arc</title>
    <link href="http://blog.newbmiao.com/2023/10/07/ownership-of-rc-and-arc.html"/>
    <id>http://blog.newbmiao.com/2023/10/07/ownership-of-rc-and-arc.html</id>
    <published>2023-10-07T11:44:05.000Z</published>
    <updated>2023-10-11T08:59:17.704Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><h2 id="1v1-所有权"><a href="#1v1-所有权" class="headerlink" title="1v1 所有权"></a>1v1 所有权</h2><p><code>Rust</code>中所有权约束了值只能有一个所有者，当值离开作用域时，它将被销毁。</p><p>像如下代码，字符串<code>a</code>如果直接移动给<code>b</code>后就没法后边再去打印，因为它的所有权已经转移给了<code>b</code>。</p><a id="more"></a><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"a = &#123;&#125;, b = &#123;&#125;"</span>, a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// got error:</span></span><br><span class="line"><span class="comment">// error[E0382]: borrow of moved value: `a`</span></span><br><span class="line"><span class="comment">// 3 |     let a = String::from("hello");</span></span><br><span class="line"><span class="comment">//   |         - move occurs because `a` has type `String`, which does not implement the `Copy` trait</span></span><br><span class="line"><span class="comment">// 4 |     let b = a;</span></span><br><span class="line"><span class="comment">//   |             - value moved here</span></span><br><span class="line"><span class="comment">// 5 |     println!("a = &#123;&#125;, b = &#123;&#125;", a, b);</span></span><br><span class="line"><span class="comment">//   |                                ^ value borrowed here after move</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝（clone）"><a href="#深拷贝（clone）" class="headerlink" title="深拷贝（clone）"></a>深拷贝（clone）</h2><p>如果<code>clone</code>的话可以复制一份，但是这样的话就需要开辟一块新的内存，不是很高效。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// let b = a;</span></span><br><span class="line"><span class="keyword">let</span> b = a.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"a = &#123;&#125;, b = &#123;&#125;"</span>, a, b);</span><br><span class="line"><span class="comment">// output: a = hello, b = hello</span></span><br></pre></td></tr></table></figure><h2 id="引用计数-（reference-count）"><a href="#引用计数-（reference-count）" class="headerlink" title="引用计数 （reference count）"></a>引用计数 （reference count）</h2><p>想要实现多个所有者，又开销小，可以用引用计数，对应的类型是<code>Rc</code>。</p><p><code>Rc</code>只会在复制时增加引用计数，当引用计数为0时，会自动调用<code>drop</code>方法，释放内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line"><span class="keyword">let</span> _b = Rc::clone(&amp;a);</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">let</span> _b = Rc::clone(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"reference count &#123;&#125;"</span>, Rc::strong_count(&amp;a)); </span><br><span class="line">    <span class="comment">// 3, will be 2 after this block out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"reference count &#123;&#125;"</span>, Rc::strong_count(&amp;a)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="写时复制（copy-on-write）"><a href="#写时复制（copy-on-write）" class="headerlink" title="写时复制（copy on write）"></a>写时复制（copy on write）</h2><p><code>Rc</code>引用的值是不可变的，如果想要修改，可以使用<code>Rc::make_mut</code>方法，它会检查引用计数，在有别的有效引用（<code>strong</code>）时，会复制一份，然后修改。否则就直接修改原来的值。这也是写时复制，只有在需要修改时才会复制。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line"><span class="keyword">let</span> b = Rc::clone(&amp;a);</span><br><span class="line"><span class="comment">//  allocate a new string (copy on write)</span></span><br><span class="line">(*Rc::make_mut(&amp;<span class="keyword">mut</span> a)).push_str( <span class="string">" world"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>,  a, b); </span><br><span class="line"><span class="comment">// hello world hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = Rc::clone(&amp;a);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125; &#123;&#125;"</span>,  a, b, c); </span><br><span class="line"><span class="comment">// hello world hello hello world</span></span><br></pre></td></tr></table></figure><p>所以这么用有一个好处，如果有修改，修改是独立于之前的引用的，不用担心修改会影响之前引用的值。</p><blockquote><p>当然，如果想保持值修改的同步，可以使用之前提到的<code>Cell</code>和<code>RefCell</code>，这两个类型可以实现内部可变性，可以在不可变引用的情况下修改值。</p></blockquote><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p><code>Rc</code>是不允许循环引用的，因为它的引用计数是在编译时就确定的，如果有循环引用，那么引用计数永远不会为0，也就永远不会调用<code>drop</code>方法，导致内存泄漏。</p><p>这里用官方的一个例子说明：下边代码用来描述工具（gadget）和工具所有者（owner）的关系，一个工具可以有一个个所有者，一个所有者可以有多个工具。</p><p>如果用<code>Rc</code>来实现的话，会出现循环引用，工具和工具所有者互相引用，导致谁都无法对引用计数减一，也就无法释放对应的内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    gadgets: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Gadget&gt;&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gadget</span></span> &#123;</span><br><span class="line">    id: <span class="built_in">i32</span>,</span><br><span class="line">    owner: Rc&lt;Owner&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> gadget_owner : Rc&lt;Owner&gt; = Rc::new(</span><br><span class="line">            Owner &#123; name: <span class="built_in">String</span>::from(<span class="string">"Gadget Man"</span>), gadgets: RefCell::new(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 两个工具，都有同一个所有者</span></span><br><span class="line">    <span class="keyword">let</span> gadget1 = Rc::new(Gadget &#123; id: <span class="number">1</span>, owner: gadget_owner.clone() &#125;);</span><br><span class="line">    <span class="keyword">let</span> gadget2 =Rc::new(Gadget &#123; id: <span class="number">2</span>, owner: gadget_owner.clone() &#125;);</span><br><span class="line"></span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(gadget1.clone());</span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(gadget2.clone());</span><br><span class="line">    <span class="comment">// 释放gadget_owner的引用计数，保留工具的owner引用计数</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget_owner);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1));</span><br><span class="line">    <span class="comment">// strong count of gadget1: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget1.owner: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放gadget1的引用计数，正常没有引用循环的话，owner对应的引用计数也需要释放</span></span><br><span class="line">    <span class="comment">// 但是gadget1的owner的引用计数不会减一，导致内存泄漏</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget2.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget2.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget2.owner: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环引用如下图所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gadgets和owner的引用形成了一个环，谁也没法释放，对应的引用计数无法减到0，也就没法释放</span><br><span class="line"></span><br><span class="line">+-----------+       +-----------+</span><br><span class="line">|   Owner   |&lt;------|  Gadget   |</span><br><span class="line">|           |       |           |</span><br><span class="line">|   Rc      |       |   Rc      |</span><br><span class="line">|           |       |           |</span><br><span class="line">| gadgets --|------&gt;| owner ----+</span><br><span class="line">+-----------+       +-----------+</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>这个时候就是弱引用的用武之地了，弱引用不会增加引用计数，所以不会导致循环引用。</p><p>但是它也不能保证引用的值一定存在，因为它的引用计数可能为0，所以用时，需要用<code>upgrade</code>方法来获取<code>Option</code>类型的引用。</p><p>也就是说引用的值释放与否只取决于强引用的引用计数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::rc::Weak;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    gadgets: RefCell&lt;<span class="built_in">Vec</span>&lt;Weak&lt;Gadget&gt;&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gadget</span></span> &#123;</span><br><span class="line">    id: <span class="built_in">i32</span>,</span><br><span class="line">    owner: Rc&lt;Owner&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> gadget_owner : Rc&lt;Owner&gt; = Rc::new(</span><br><span class="line">            Owner &#123;</span><br><span class="line">                name: <span class="string">"Gadget Man"</span>.to_string(),</span><br><span class="line">                gadgets: RefCell::new(<span class="built_in">Vec</span>::new())</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> gadget1 = Rc::new(Gadget&#123;id: <span class="number">1</span>, owner: gadget_owner.clone()&#125;);</span><br><span class="line">    <span class="keyword">let</span> gadget2 = Rc::new(Gadget&#123;id: <span class="number">2</span>, owner: gadget_owner.clone()&#125;);</span><br><span class="line"></span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget1.clone()));</span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget2.clone()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gadget_opt <span class="keyword">in</span> gadget_owner.gadgets.borrow().iter() &#123;</span><br><span class="line">        <span class="keyword">let</span> gadget = gadget_opt.upgrade().unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Gadget &#123;&#125; owned by &#123;&#125;"</span>, gadget.id, gadget.owner.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">drop</span>(gadget_owner);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1));</span><br><span class="line">    <span class="comment">// strong count of gadget1: 1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget1.owner: 2</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget2.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget2.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget2.owner: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><code>Rc</code>是线程不安全的，如果想要在多线程中使用，可以使用<code>Arc</code>，它是<code>Rc</code>的线程安全版本。 （<code>A</code>代表<code>atomic</code>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> val = Arc::new(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val = Arc::clone(&amp;val);</span><br><span class="line">        thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> v = *val.as_ref() + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;v:?&#125;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    thread::sleep(std::time::Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果想要在多线程中修改值，可以使用<code>Mutex</code>和<code>RwLock</code>，它们都是线程安全的。 如<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。</p><hr><p>最后还有一点想提下，<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>都实现了自动解引用<code>Deref</code>到<code>T</code>，所以可以直接在<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>上调用<code>T</code>的方法。而为了防止方法名冲突，一般习惯用全限定语法调用方法来调用<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>的方法，如<code>Rc::clone</code>。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊所有权之Rc和Arc
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/categories/rust/"/>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/tags/rust/"/>
    
      <category term="ownership" scheme="http://blog.newbmiao.com/tags/ownership/"/>
    
      <category term="rc" scheme="http://blog.newbmiao.com/tags/rc/"/>
    
      <category term="arc" scheme="http://blog.newbmiao.com/tags/arc/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Rust的Cell和RefCell</title>
    <link href="http://blog.newbmiao.com/2023/10/03/rust-cell-and-refcell.html"/>
    <id>http://blog.newbmiao.com/2023/10/03/rust-cell-and-refcell.html</id>
    <published>2023-10-03T08:53:52.000Z</published>
    <updated>2023-10-03T09:01:13.724Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>内部可变性（<code>interior mutability</code>）是<code>Rust</code>用来表示在一个值的外部看起来是不可变的，但是在内部是可变的。这种模式通常用于在拥有不可变引用的同时修改目标数据。</p><p><code>Cell</code>和<code>RefCell</code>是<code>Rust</code>提供的两种内部可变性的实现。<code>Cell</code>是用于<code>Copy</code>类型的，而<code>RefCell</code>是用于非<code>Copy</code>类型的。</p><p>不知道你有没有好奇过具体内部可变性应用在什么场景，为啥要分两种实现。</p><p>今天我们针对一些场景来聊聊这两个类型的应用。</p><a id="more"></a><h2 id="Why-interior-mutability"><a href="#Why-interior-mutability" class="headerlink" title="Why interior mutability?"></a>Why interior mutability?</h2><p>如下代码所示，当需要多个可变引用时，会违反<code>Rust</code>的所有权要求：同一时间只能有一个可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"><span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line">*z = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line"># will get error:</span><br><span class="line"># error[E0499]: cannot borrow `x` <span class="keyword">as</span> mutable more than once at a time</span><br><span class="line">#  --&gt; src/main.rs:<span class="number">5</span>:<span class="number">9</span></span><br><span class="line">#   |</span><br><span class="line"># <span class="number">4</span> | <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ------ first mutable borrow occurs here</span><br><span class="line"># <span class="number">5</span> | <span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ^^^^^^ second mutable borrow occurs here</span><br><span class="line"># <span class="number">6</span> | x = <span class="number">2</span>;</span><br><span class="line"># <span class="number">7</span> | *y = <span class="number">3</span>;</span><br><span class="line">#   | ------ first borrow later used here</span><br><span class="line"></span><br><span class="line"># error[E0506]: cannot assign to `x` because it is borrowed</span><br><span class="line">#  --&gt; src/main.rs:<span class="number">6</span>:<span class="number">1</span></span><br><span class="line">#   |</span><br><span class="line"># <span class="number">4</span> | <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ------ `x` is borrowed here</span><br><span class="line"># <span class="number">5</span> | <span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"># <span class="number">6</span> | x = <span class="number">2</span>;</span><br><span class="line">#   | ^^^^^ `x` is assigned to here but it was already borrowed</span><br><span class="line"># <span class="number">7</span> | *y = <span class="number">3</span>;</span><br><span class="line">#   | ------ borrow later used here</span><br></pre></td></tr></table></figure><p>这个时候就是内部可变性发挥作用的时候了。拿<code>Cell</code>来举例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = Cell::new(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> y = &amp;x;</span><br><span class="line"><span class="keyword">let</span> z = &amp;x;</span><br><span class="line">x.set(<span class="number">2</span>);</span><br><span class="line">y.set(<span class="number">3</span>);</span><br><span class="line">z.set(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x.get());</span><br></pre></td></tr></table></figure><p>通过<code>Cell</code>，其封装了<code>get</code>和<code>set</code>,可以在不需要显示声明为可变的情况下修改值。</p><h3 id="修改结构体的字段"><a href="#修改结构体的字段" class="headerlink" title="修改结构体的字段"></a>修改结构体的字段</h3><p>一般我们要修改一个结构体的值，需要将其声明为<code>mut</code>, 而对应的方法也需要接收<code>&amp;mut self</code> 举例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    age: <span class="built_in">u32</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">celebrate_birthday</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> current_age = <span class="keyword">self</span>.age;</span><br><span class="line">        <span class="keyword">self</span>.age = current_age + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> Person = Person::default();</span><br><span class="line">Person.celebrate_birthday();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Age after birthday: &#123;&#125;"</span>, Person.age);</span><br></pre></td></tr></table></figure><p>但是有时候我们并不想这么做，因为我们只是想<strong>修改其中的某个字段</strong>，而不是整个结构体，亦或者<strong>接口并不想暴露一个<code>&amp;mut self</code>的方法</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    age: Cell&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="comment">// 方法receiver无需声明为`mut`</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">celebrate_birthday</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> current_age = <span class="keyword">self</span>.age.get();</span><br><span class="line">        <span class="keyword">self</span>.age.set(current_age + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.celebrate_birthday();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Age after birthday: &#123;&#125;"</span>, person.age.get());</span><br></pre></td></tr></table></figure><h2 id="Cell-只适合-Copy-类型"><a href="#Cell-只适合-Copy-类型" class="headerlink" title="Cell 只适合 Copy 类型"></a>Cell 只适合 Copy 类型</h2><p>对于非<code>Copy</code>类型，<code>Cell</code>并不适用, 因为其约束了<code>get</code>方法的返回值必须是<code>Copy</code>类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>&gt; Cell&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(&amp;<span class="keyword">self</span>) -&gt; T &#123;</span><br></pre></td></tr></table></figure><p>那是不是不能往<code>Cell</code>里面放非<code>Copy</code>类型的值呢？当然不是，只是失去了意义，代码如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = Cell::new(<span class="built_in">String</span>::from(<span class="string">"value"</span>));</span><br><span class="line"><span class="comment">// 没有 `s.get()`，因为 `String` 不是 `Copy` 类型</span></span><br><span class="line"><span class="comment">// 而`get_mut()`返回的是 要求自身是可变的，就失去了用`Cell`的意义</span></span><br><span class="line">*s.get_mut() = <span class="built_in">String</span>::from(<span class="string">"value2"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s.into_inner());</span><br></pre></td></tr></table></figure><h2 id="RefCell-提供引用"><a href="#RefCell-提供引用" class="headerlink" title="RefCell 提供引用"></a>RefCell 提供引用</h2><p><code>RefCell</code>主要的不同是支持非<code>Copy</code>类型，且返回的是引用，而不是值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="string">"hello"</span>.to_owned());</span><br><span class="line">*c.borrow_mut() = <span class="string">"bonjour"</span>.to_owned();</span><br><span class="line"><span class="keyword">let</span> val = c.borrow();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;*val, <span class="string">"bonjour"</span>);</span><br></pre></td></tr></table></figure><h2 id="运行时检查"><a href="#运行时检查" class="headerlink" title="运行时检查"></a>运行时检查</h2><p>如果把上边代码换成如下先借用，编译能通过，但是运行时会报错。</p><p><code>RefCell</code> 依旧要遵守借用规则，只是推迟检查从编译期到运行时，如果违反了借用规则，会 <code>panic</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```rust</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="string">"hello"</span>.to_owned());</span><br><span class="line"><span class="keyword">let</span> val = c.borrow(); <span class="comment">// 先借用再修改，最后读取借用的值</span></span><br><span class="line">*c.borrow_mut() = <span class="string">"bonjour"</span>.to_owned();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;*val, <span class="string">"bonjour"</span>);</span><br><span class="line"></span><br><span class="line"># will panic:</span><br><span class="line"># thread <span class="symbol">'main</span>' panicked at <span class="symbol">'already</span> borrowed: BorrowMutError', src/main.rs:<span class="number">7</span>:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>综上可以看出，<code>Cell</code>和<code>RefCell</code>是不同粒度的内部可变性实现，简单的<code>Copy</code>类型可以考虑开销小的<code>Cell</code>来获取有内部可变性的<strong>值</strong>， 需要更灵活的内部可变<strong>借用</strong>就要用<code>RefCell</code>。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊Rust的Cell和RefCell
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/categories/rust/"/>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/tags/rust/"/>
    
      <category term="cell" scheme="http://blog.newbmiao.com/tags/cell/"/>
    
      <category term="refcell" scheme="http://blog.newbmiao.com/tags/refcell/"/>
    
  </entry>
  
  <entry>
    <title>掌握Rust：从零开始的所有权之旅</title>
    <link href="http://blog.newbmiao.com/2023/08/13/master-rust-ownership-from-scratch.html"/>
    <id>http://blog.newbmiao.com/2023/08/13/master-rust-ownership-from-scratch.html</id>
    <published>2023-08-13T14:25:08.000Z</published>
    <updated>2023-08-22T02:55:23.061Z</updated>
    
    <content type="html"><![CDATA[<p>所有权是 <code>Rust</code> 很有意思的一个语言特性，但对于初学者却是一个比较有挑战的内容。</p><p>今天尝试用代码示例来聊聊 <code>Rust</code> 的所有权是什么，以及为什么要有所有权。希望能给初学的朋友一点帮助。</p><blockquote><p>Tips：文中代码有相应注释，建议可以先不用纠结细节，关注整体。后边可以再挨个去研究具体代码细节</p></blockquote><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="移动？拷贝？"><a href="#移动？拷贝？" class="headerlink" title="移动？拷贝？"></a>移动？拷贝？</h2><p>先来试试常规的赋值语句在<code>Rust</code>有什么样的表现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"start"</span>);</span><br><span class="line"><span class="comment">// code 1:</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> _b = a;</span><br><span class="line"><span class="keyword">let</span> _c = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code 2:</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> _e = d;</span><br><span class="line"><span class="keyword">let</span> _f = d;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `d`</span><br><span class="line">  --&gt; src/main.rs:<span class="number">12</span>:<span class="number">10</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> | <span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |     - move occurs because `d` has type `String`, which does not implement the `Copy` trait</span><br><span class="line"><span class="number">11</span> | <span class="keyword">let</span> _e = d;</span><br><span class="line">   |          - value moved here</span><br><span class="line"><span class="number">12</span> | <span class="keyword">let</span> _f = d;</span><br><span class="line">   |          ^ value used here after <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">help: consider cloning the value <span class="keyword">if</span> the performance cost is acceptable</span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> | <span class="keyword">let</span> _e = d.clone();</span><br><span class="line">   |           ++++++++</span><br></pre></td></tr></table></figure><p>为什么 <code>code 2</code> 出错了？ <code>code 1</code> 没有？</p><p>看起来都是初始化赋值操作，分别将数字 <code>a</code> 和字符串 <code>d</code> <strong>多次赋值</strong>给别的变量<br>为什么字符串的赋值失败了。</p><p>这里要引出 <code>Rust</code> 世界里对<strong>值拷贝</strong>和<strong>所有</strong>的区分</p><p>对于一切变量，当把他传递给别的变量或函数，如果他可以拷贝（<code>Copy</code>）就复制一份；否则就将值的所有权移动（<code>Move</code>）过去。</p><p>这里<code>a</code>是数字，数字是可以拷贝的，所以 <code>code 1</code> 是可以编译通过的。<br>而<code>d</code>是字符串，字符串是不可以拷贝的，第一次赋值就将所有权move给了<code>_e</code>，只能<code>move</code>一次，所以 <code>code 2</code> 编译不通过。</p><p>为什么要拷贝或移动？先剧透下 <code>Rust</code> 没有内存垃圾回收器（<code>GC</code>），它对内存的管理就是依赖所有权，谁持有（<code>Own</code>）变量，谁可以在变量需要销毁时释放内存。</p><p>我们拿代码看看它如何销毁变量</p><h2 id="作用域和销毁"><a href="#作用域和销毁" class="headerlink" title="作用域和销毁"></a>作用域和销毁</h2><p>这里我们关注在何时销毁的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为孤儿原则，包装原生string类型，来支持添加drop trait实现，来观察销毁</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyString</span></span>(<span class="built_in">String</span>);</span><br><span class="line"><span class="keyword">impl</span> MyString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        MyString(<span class="built_in">String</span>::from(name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyData</span></span> &#123;</span><br><span class="line">    data: MyString,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁时打印字符串</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyString with value: &#123;:?&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁时打印包含字符串的结构体</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyData &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyData with value: &#123;:?&#125;"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"not used"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> _wrapper = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as variable"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dropping MyData with value: MyString(<span class="string">"not used"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"not used"</span></span><br><span class="line">End of the scope inside main.</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as variable"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as variable"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>代码分了两个作用域（<code>Scope</code>）</p><blockquote><p>Tips: 其实有多个，每个<code>let</code>也可以看做是一个作用域，这里为了方便理解，只分了两个</p></blockquote><ul><li><p>main函数自身的<code>scope</code></p></li><li><p>main函数内的<code>scope</code></p><p>  在此作用域内<code>_</code>变量的结构体及包含的字符串就销毁了。<br>  这里<code>let _</code>代表这个变量被忽略，也无法再被别人使用，所以当即销毁</p><p>  离开此作用域时，局部变量<code>_wrapper</code>也被销毁</p></li></ul><p>结合之前字符串不能多次移动，这里就展示<code>Rust</code>对内存管理的两个原则：</p><ul><li><strong>值只能有一个所有者，当离开作用域，值将被丢弃</strong>。</li><li><strong>所有权可以转移</strong></li></ul><p>嗯，这么搞确实很利于内存管理。</p><p>那要只是想引用一个变量，不想移动怎么办？（毕竟移动只能一次）</p><h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>先来看看常规的“引用”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"start"</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> d = &amp;a;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="comment">// let ref d = a;</span></span><br><span class="line"><span class="keyword">let</span> _e = d;</span><br><span class="line"><span class="keyword">let</span> _f = d;</span><br></pre></td></tr></table></figure><p>这段代码是可以编译通过的</p><blockquote><p>Tips，<code>Rust</code>在编译阶段就能分析出很多代码问题，这也是为什么前边的错误里没有打印“start”，因为编译就失败了</p></blockquote><p><code>Rust</code>里对“引用”有细分，这里叫借用（<code>Borrow</code>），至于为什么，我们后边讲</p><p>从目前的代码看，如果一个变量借用了字符串变量，这个借用是可以赋值给多个变量的。</p><p>这样对于不需要<code>Move</code>整个字符串，只是要借用值来说，使用确实方便多了，那借用什么时候回收呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个借用结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDataRef</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    reference: &amp;<span class="symbol">'a</span> MyData,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的drop trait实现</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyDataRef&lt;<span class="symbol">'_</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyDataRef"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as variable"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> b = MyDataRef &#123; reference: &amp;a &#125;;</span><br><span class="line">        <span class="keyword">let</span> c = MyDataRef &#123; reference: &amp;a &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">End of the scope inside main.</span><br><span class="line">Dropping MyDataRef</span><br><span class="line">Dropping MyDataRef</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as variable"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as variable"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>在销毁借用的变量前，先销毁了所有的借用。哈哈，你可以有多个借用（准确说是<strong>不可变借用</strong>（<code>immutable borrow</code>），后边在展开），但销毁变量时，所有借用都会被一起销毁，这样保证你不是借用一个已经销毁的变量（<code>use after free</code>）</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>到这里我们都没有修改过一个变量</p><p><code>Rust</code>能像别的语言这样赋值修改么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>结果是不行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0384]: cannot assign twice to immutable variable `d`</span><br><span class="line">  --&gt; src/main.rs:<span class="number">33</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">32</span> |     <span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |         -</span><br><span class="line">   |         |</span><br><span class="line">   |         first assignment to `d`</span><br><span class="line">   |         help: consider making this binding mutable: `<span class="keyword">mut</span> d`</span><br><span class="line"><span class="number">33</span> |     d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br><span class="line">   |     ^ cannot assign twice to immutable variable</span><br></pre></td></tr></table></figure><p><code>Rust</code>对读取和修改是有区分的，像错误提示那样</p><p>需要<code>mut</code>关键字来声明变量可修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>那对应的销毁时什么样的呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> wrapper = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as mut variable1"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        wrapper.data = MyString::from(<span class="string">"used as mut variable2"</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"[Mutable] End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dropping MyString with value: <span class="string">"used as mut variable1"</span></span><br><span class="line">[Mutable] End of the scope inside main.</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as mut variable2"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as mut variable2"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>基本和之前不可变（<code>immutable</code>）变量销毁类似，唯一不同是赋值后，赋值前的值要被销毁，内存的管理很是细致啊。</p><p>现在说了借用，说了可变，我们可以来看看前边提到借用是有区分的：还有一个可变借用（<code>mutable borrow</code>）</p><h2 id="可变借用"><a href="#可变借用" class="headerlink" title="可变借用"></a>可变借用</h2><p>对于可变变量，是可以有对应的可变借用的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">*g = <span class="string">"world"</span>.to_string();</span><br></pre></td></tr></table></figure><p>那如果同时有可变借用和不可变借用，下边的代码可以么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> e = &amp;d;</span><br><span class="line">    <span class="keyword">let</span> f = &amp;d;</span><br><span class="line">    <span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">    *g = <span class="string">"world"</span>.to_string();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;f&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不可以</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `d` <span class="keyword">as</span> mutable because it is also borrowed <span class="keyword">as</span> immutable</span><br><span class="line"> --&gt; src/main.rs:<span class="number">5</span>:<span class="number">13</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> f = &amp;d;</span><br><span class="line">  |             -- immutable borrow occurs here</span><br><span class="line"><span class="number">5</span> |     <span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">  |             ^^^^^^ mutable borrow occurs here</span><br><span class="line"><span class="number">6</span> |     *g = <span class="string">"world"</span>.to_string();</span><br><span class="line"><span class="number">7</span> |     <span class="built_in">println!</span>(<span class="string">"&#123;f&#125;"</span>);</span><br><span class="line">  |               --- immutable borrow later used here</span><br></pre></td></tr></table></figure><p>编译器明确告诉我们，可变借用的时候不能同时有不可变借用。</p><p>为什么，如果拿<strong>读写互斥锁</strong>来类比，就很好理解了，我有可变借用，就像拿到写锁，这个时候是不允许有读锁的，不然我修改和你读取不一致怎么办。</p><p>这是就得出了所有权里借用的规则：</p><ul><li><strong>不可变借用可以有多个</strong></li><li><strong>可变借用同一时间只能有一个，且和不可变借用互斥</strong></li></ul><h2 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h2><p>到此，所有权的三条原则就全部出来了</p><ul><li>值有且只有一个所有者, 且所有者离开作用域时, 值将被丢弃</li><li>所有权可转移</li><li>借用<ul><li>不可变借用可以有多个</li><li>可变借用同一时间只能有一个</li></ul></li></ul><p>这些规则，规范了对于一个变量谁持有，离开作用域是否可以释放，变量的修改和借用有什么样要求，避免释放后的内存被借用，也防止修改和读取的内容不一致有<code>race condition</code>的问题。</p><p>最厉害的是这些都是编译阶段就分析保证了的，提前暴露了问题，不然等到代码上线了遇到问题再crash，追查起来就滞后太久了。</p><p>到这所有权就结束了么？还没有，快了，再耐着性子往下看</p><h2 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h2><p>目前为止，一个借用要么是只读的要么是可写的，限制都很严格，万一我想需要写的时候再可写，平时只要一个只读的借用就可以，能搞定么？</p><p>能！</p><p>Rust提供了<code>Cell</code>（针对实现<code>Copy</code>的简单类型）<br>和<code>RefCell</code>(针对任何类型，运行时做借用检查)<br><code>Arc</code>（多线程安全的引用计数类型）等类型，来支持内部可变性。<br><code>Mutex</code>和<code>RwLock</code>也是内部可变性的一种实现，只不过是在多线程场景下的。</p><blockquote><p>Tips: 本质上可以理解为对读写互斥的不同粒度下的封装，不需要显式声明可变借用，但内部有可变的能力</p></blockquote><p>以<code>RefCell</code>为例，来看看内部可变性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">let</span> value = RefCell::new(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Mutate the value using an immutable reference</span></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">let</span> borrowed = value.borrow();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Before mutation: &#123;&#125;"</span>, *borrowed);</span><br><span class="line"><span class="built_in">drop</span>(borrowed);</span><br><span class="line"><span class="comment">// Interior mutation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> borrowed_mut = value.borrow_mut();</span><br><span class="line">    *borrowed_mut += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">let</span> borrowed = value.borrow();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"After mutation: &#123;&#125;"</span>, *borrowed);</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>终于到了最后一个话题，生命周期</p><p>下边一段简单的字符串切片的长度比较函数</p><p>你能想到它为什么编译不通过么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(str1:  &amp;<span class="built_in">str</span>, str2: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str1.len() &gt; str2.len() &#123;</span><br><span class="line">        str1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">let</span> str2 = <span class="string">"world！"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest(str1, str2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:<span class="number">1</span>:<span class="number">39</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> | <span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(str1: &amp;<span class="built_in">str</span>, str2: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  |                  ----        ----     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function<span class="symbol">'s</span> <span class="keyword">return</span> <span class="class"><span class="keyword">type</span> <span class="title">contains</span></span> a borrowed value, but the signature does not say whether it is borrowed from `str1` or `str2`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> | <span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(str1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, str2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">  |           ++++        ++             ++          ++</span><br></pre></td></tr></table></figure><p>编译器再一次友好的提示我们，函数入参两个借用，返回值一个借用，无法确定返回值是用了哪个入参的生命周期。</p><p>一个新的概念出现了：<strong>生命周期</strong></p><p>生命周期是<code>Rust</code>用来标注引用存活周期，借此标识变量的借用与作用域是否合法，即借用是否在作用域内还有效，毕竟不能悬空指针（<code>dangling pointer</code>， 借用一个失效的内存地址）啊。</p><p>就像这里，函数返回一个借用，那返回的借用是否在作用域内合法，和入参的两个引用的关系是什么，靠的就是生命周期标注。如果入参和出参都是一个生命周期，即出参的借用在入参的借用作用域内，只要入参的生命周期合法，那出参的就是合法的。不然如果出参用了只是借用函数内部变量的生命周期，那函数返回后，函数内部变量就被销毁了，出参就是悬空指针了。</p><p>你可以简单理解为给借用多增加了一个参数，用来标识其借用在一个<code>scope</code>内使用是否合法。</p><blockquote><p>题外话，其实你如果了解<code>Golang</code>的逃逸分析，比如当函数内部变量需要返回给函数外部继续使用，其实是要扩大内部变量的作用域（即内部变量的生命周期），不能只依靠当前函数栈来保存变量，就会把它逃逸到堆上。 它做的其实也是变量的生命周期分析，用增加堆的内存开销来避免悬空指针。<br>只不过那是在gc基础上一种优化，而<code>Rust</code>则是在编译期就能通过生命周期标注就能确定借用是否合法。<br>对于想把内部变量返回给外部使用的情况，<code>Rust</code>也提供了<code>Box</code>来支持，这里就不展开了。</p></blockquote><p><strong>那是不是每个借用都要标注?</strong></p><p>也不是，rust默认会对所有借用自动标注，只有出现冲突无法自动标注的时候才需要程序员手动标注。如果感兴趣的话，可以深入看下<a href="https://doc.rust-lang.org/nomicon/subtyping.html" target="_blank" rel="noopener">Subtyping and Variance</a>，了解下生命周期的一些约束。</p><p>最后我们看下下边编译不通过的代码，从编译期的报错你就应该能明白，为什么要生命周期标注了，它对于让编译期做借用的作用域合法性检查很有用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_longest</span></span>&lt;<span class="symbol">'a</span>&gt;(str1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, str2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str1.len() &gt; str2.len() &#123;</span><br><span class="line">        str1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> str1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">let</span> str2 = <span class="string">"world!"</span>;</span><br><span class="line">        result = get_longest(str1.as_str(), str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `str1` does not live long enough</span><br><span class="line">  --&gt; src/main.rs:<span class="number">15</span>:<span class="number">30</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |         <span class="keyword">let</span> str1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |             ---- binding `str1` declared here</span><br><span class="line"><span class="number">14</span> |         <span class="keyword">let</span> str2 = <span class="string">"world!"</span>;</span><br><span class="line"><span class="number">15</span> |         result = get_longest(str1.as_str(), str2);</span><br><span class="line">   |                              ^^^^^^^^^^^^^ borrowed value does not live long enough</span><br><span class="line"><span class="number">16</span> |     &#125;</span><br><span class="line">   |     - `str1` dropped here <span class="keyword">while</span> still borrowed</span><br><span class="line"><span class="number">17</span> |</span><br><span class="line"><span class="number">18</span> |     <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">   |                                           ------ borrow later used here</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，收个尾吧：</p><ul><li>所有权关注的是值的拥有和管理</li><li>借用检查器在编译时保证借用的有效性和安全性</li><li>生命周期关注的是借用的有效范围和引用的合法性</li></ul><p>他们配合在一起，构建起了<code>Rust</code>强大的内存管理能力。避免了内存泄漏和悬空指针的问题，也避免了<code>GC</code>带来的性能问题。</p><p>怎么样？是不是感觉<code>Rust</code>的所有权设计还挺有意思的？一个所有权把内存管理的清晰又明了！</p><p>欢迎有问题的朋友留言讨论。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      掌握Rust：从零开始的所有权之旅
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/categories/rust/"/>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/tags/rust/"/>
    
      <category term="ownership" scheme="http://blog.newbmiao.com/tags/ownership/"/>
    
      <category term="borrow" scheme="http://blog.newbmiao.com/tags/borrow/"/>
    
      <category term="lifetime" scheme="http://blog.newbmiao.com/tags/lifetime/"/>
    
  </entry>
  
  <entry>
    <title>代码是负债，而不是资产</title>
    <link href="http://blog.newbmiao.com/2023/08/12/seeing-code-as-debt-not-value.html"/>
    <id>http://blog.newbmiao.com/2023/08/12/seeing-code-as-debt-not-value.html</id>
    <published>2023-08-12T10:19:54.000Z</published>
    <updated>2023-08-22T02:55:23.062Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《Google软件工程》，其中有一句话让我印象深刻：<br>代码是负债，而不是资产。</p><p>然而作为程序员，相信很多人都认为自己的代码就是资产，是自己智慧的结晶，怎么会是负债呢？</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><p>首先这个当然是要限定在软件工程领域来讨论。</p><p>在软件工程领域，代码的构建是要花费时间和人力成本的，但代码并不因此就能算作资产，真正有价值的是代码所要解决的产品问题，给用户和公司带来的价值。</p><p>而且写好的代码也是需要长期维护，长期运行的，而不是一次性的。<br>虽然维护的时间或长或短，决定于其服务的产品的生命。</p><p>所以代码是有维护成本的，就像负债，在没还清前，是需要源源不断的投入的。</p><p>我觉得这其实才道出了代码的本质。</p><p>为什么软件工程领域围绕代码有那么多方法论？</p><p>结对编程，代码评审，代码风格指南，测试驱动开发，设计文档评审，流水线集成和发布，清理技术负债，等等。</p><p>身处其中的程序员当然知道这是为了保证代码质量，但仅仅就是这样么？</p><p>要是从一开始就明白代码是负债，这一切就好理解了。</p><p>因为代码是需要维护的，不合理维护的代码就会像逐渐发霉的苹果，早晚有一天变成人人厌恶的坏代码，那些你眼里讨厌的legacy。</p><p>所以从一开始，代码就应该结合产品生命周期的规划，明白构建的代码将会存活大概多长时间。基于此再去设计，去实现，去计划相应的代码维护方案。</p><p>前期合适的流程能构建出当下场景合理的代码，避免代码一开始就腐烂。</p><p>但重要的是，团队能一开始就意识到代码需要长期合理的维护。</p><p>不会因为新需求的交付，而忽视那些将要后已经有问题但没人问津的技术负债。毕竟负债分散到日常去处理成本远远要小于最后一次偿还。</p><p>而且，当代码不能很好的服务产品的时候，要考虑何时弃用，将负债彻底清理。这反而是很多团队会忽略的东西。</p><p>不过有人就说，代码不用了不清理可以么？好像也没什么问题是不。</p><p>等遗留的旧代码依旧被别的代码引用，新老服务代码还有一些纠缠剪不断，代码仓库变得越来越臃肿，代码缺陷检查通不过，到时候开始抱怨的你猜会是谁？</p><p>到这里，你有没有发现，代码永远是程序员的负债，如果你自己还混不自知的话，最后很容易把自己搅入泥潭。</p><p>那个时候你能怪PM或者EM没有给你规划技术负债的清理维护么？</p><p>可能他们也知道，但是他们的屁股更关心的是需求的交付，产品的迭代。</p><p>而你有没有提前识别出代码负债的问题，有没有把技术负债也加入到日常交付中，是你要关心和负责的事情。</p><p>以前觉得软件工程都是些虚头巴脑的东西，不如写代码实在。</p><p>现在慢慢觉得写代码确实实在，但那些“虚头巴脑”的东西反而更考验一个程序员的能力。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      代码是负债，而不是资产
    
    </summary>
    
    
      <category term="thoughts" scheme="http://blog.newbmiao.com/categories/thoughts/"/>
    
      <category term="software-engineering" scheme="http://blog.newbmiao.com/categories/thoughts/software-engineering/"/>
    
    
      <category term="thoughts" scheme="http://blog.newbmiao.com/tags/thoughts/"/>
    
      <category term="software-engineering" scheme="http://blog.newbmiao.com/tags/software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>深入解读-如何用keycloak管理external auth</title>
    <link href="http://blog.newbmiao.com/2023/06/18/auth-manage-via-keycloak.html"/>
    <id>http://blog.newbmiao.com/2023/06/18/auth-manage-via-keycloak.html</id>
    <published>2023-06-18T14:10:20.000Z</published>
    <updated>2023-08-22T02:56:08.831Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>提到<code>OAuth2</code>，大家多少都有些了解。</p><blockquote><p>不了解的话可以先看下之前的<a href="http://blog.newbmiao.com/2021/09/19/tech-behind-authentication.html">简单聊聊鉴权背后的那些技术</a>先回顾一下基本概念和流程。</p></blockquote><p>简单来说，以<code>google</code>授权为例，一般就是通过用户授权页面登录<code>google</code>账号，再跳转用<code>code</code>换取到相应权限的<code>token</code>，就可以代表用户去发起一些<code>google api</code>的请求。</p><p>直接代码实现这套授权逻辑并不复杂，不过如果还需要接入<code>facebook</code>授权，<code>instagram</code>授权呢，总不能挨个去实现一遍吧。</p><p>最好能有一套通用的解决方案来解放双手， 今天我们就聊聊如何用<code>keycloak</code>实现一套通用的身份验证和授权管理方案。</p><blockquote><p>提前说明，无法本地复刻的技术方案不利于理解，也不利于方案探讨。虽然本文章所用代码是使用了<code>rust</code>的<code>axum</code>框架（为啥？因为<code>rust</code> is future！）+<code>keycloak</code>，但从服务启动到<code>keycloak</code>服务及相关配置，都用<code>docker-compose+terraform+shell</code> 脚本化管理，可100%本地复刻，欢迎本地尝试。（当然我说的是<code>Mac</code>下）代码地址： <a href="https://github.com/NewbMiao/axum-koans" target="_blank" rel="noopener">https://github.com/NewbMiao/axum-koans</a></p></blockquote><a id="more"></a><h2 id="初探OAuth"><a href="#初探OAuth" class="headerlink" title="初探OAuth"></a>初探<code>OAuth</code></h2><p>在引入<code>keycloak</code>之前我们以<code>google</code>为例先看下常规<code>OAuth</code>怎么接入，方便后边和<code>keycloak</code>接入对比。</p><blockquote><p>前置工作： 获取<code>google OAuth application</code>的<code>clientId</code>和<code>clientSecret</code>，不清楚的话，可以参考 <strong>Create a Google Application</strong> in <a href="https://keycloakthemes.com/blog/how-to-setup-sign-in-with-google-using-keycloak" target="_blank" rel="noopener">How to setup Sign in with Google using Keycloak</a></p></blockquote><p>如下图，一般授权流程（<code>standard flow</code>）中客户端和<code>auth server</code>主要是两个阶段</p><ul><li>生成<code>auth url</code>跳转登录后请求换取授权令牌的<code>code</code></li><li>在<code>auth callback</code>中用<code>code</code>换取<code>token</code>，得到能代表用户的<code>credentials</code>，一般是<code>accessToken</code></li></ul><p><img src="https://blog.postman.com/wp-content/uploads/2020/06/image5.png" alt="Authorization Code flow for OAuth"></p><p>这个流程自己也可以实现，但一般都用<code>oidc client</code>（其实现了<code>OpenID connect</code>协议，是建立在<code>OAuth2.0</code>上的身份验证协议，用来为应用提供用户身份信息）来实现。</p><p>编程语言实现上大同小异，下边代码以<code>rust</code>的<code>oauth2</code>库为例讲解</p><p>如果不熟悉<code>rust</code>，可以重点看<strong>代码注释</strong>，也不影响理解</p><h3 id="初始化oidc-client"><a href="#初始化oidc-client" class="headerlink" title="初始化oidc client"></a>初始化<code>oidc client</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::new</span></span><br><span class="line"><span class="comment">// 注册auth server 的授权登录地址，授权时会生成带有相应参数的 auth url</span></span><br><span class="line"><span class="keyword">let</span> auth_url =</span><br><span class="line">    AuthUrl::new(<span class="string">"https://accounts.google.com/o/oauth2/v2/auth"</span>.to_string()).unwrap();</span><br><span class="line"><span class="comment">// 注册auth server 的授权登录成功后要跳转到的客户端地址（auth callback url），会携带code</span></span><br><span class="line"><span class="keyword">let</span> redirect_url = RedirectUrl::new(config.redirect_url).unwrap();</span><br><span class="line"><span class="comment">// 注册auth server 的code换取token的地址</span></span><br><span class="line"><span class="keyword">let</span> token_url =</span><br><span class="line">    TokenUrl::new(<span class="string">"https://www.googleapis.com/oauth2/v3/token"</span>.to_string()).unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = BasicClient::new(</span><br><span class="line">    <span class="comment">// 注册google application client credentials, 会有相应权限和客户端限制，如web application类型会有访问地址origin及callback地址的白名单限制</span></span><br><span class="line">    ClientId::new(config.client_id),</span><br><span class="line">    <span class="literal">Some</span>(ClientSecret::new(config.client_secret)),</span><br><span class="line">    auth_url,</span><br><span class="line">    <span class="literal">Some</span>(token_url),</span><br><span class="line">)</span><br><span class="line">.set_redirect_uri(redirect_url);</span><br></pre></td></tr></table></figure><h3 id="生成auth-url"><a href="#生成auth-url" class="headerlink" title="生成auth url"></a>生成auth url</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::auth_url</span></span><br><span class="line"><span class="keyword">let</span> (url, csrf_token) = client</span><br><span class="line">    <span class="comment">// 参数是用于生成state的函数，这里用csrftoken,可以在auth callback中校验state参数是否合法</span></span><br><span class="line">    .authorize_url(CsrfToken::new_random)</span><br><span class="line">    <span class="comment">// auth请求需要的权限（scope）,一般获取用户信息的话，profile和email就好了</span></span><br><span class="line">    .add_scope(Scope::new(</span><br><span class="line">        <span class="string">"https://www.googleapis.com/auth/userinfo.profile"</span>.to_string(),</span><br><span class="line">    ))</span><br><span class="line">    .add_scope(Scope::new(</span><br><span class="line">        <span class="string">"https://www.googleapis.com/auth/userinfo.email"</span>.to_string(),</span><br><span class="line">    ))</span><br><span class="line">    <span class="comment">// 需要显示OAuth需要授权的内容给用户来确认是否同意，就是我们常见的google授权确认页面</span></span><br><span class="line">    .add_extra_param(<span class="string">"prompt"</span>, <span class="string">"consent"</span>)</span><br><span class="line">    <span class="comment">// 允许应用程序获得长期有效的访问令牌（accessToken）和刷新令牌(refreshToken)</span></span><br><span class="line">    .add_extra_param(<span class="string">"access_type"</span>, <span class="string">"offline"</span>)</span><br><span class="line">    .url();</span><br></pre></td></tr></table></figure><p>这里参数<code>access_type=offline</code>对于应用需要长期<code>accessToken</code>是很关键的。一般<code>accessToken</code>都有过期时间，如果没有有效的<code>refreshToken</code>来刷新<code>accessToken</code>，就会有<code>accessToken</code>失效后还要用户再登录的尴尬局面-_-!</p><p>另外为安全考虑除了可以用<code>state</code>做请求合法校验，还可以用<a href="https://blog.postman.com/pkce-oauth-how-to" target="_blank" rel="noopener"><code>PKCE(Proof Key for Code Exchange)</code></a>来加强, 实际用到的代码有实现，感兴趣可以看下</p><h3 id="auth-callback换取token"><a href="#auth-callback换取token" class="headerlink" title="auth callback换取token"></a>auth callback换取token</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::get_tokens</span></span><br><span class="line"><span class="comment">// 校验请求，state及pkce, 这里省略展示</span></span><br><span class="line"><span class="comment">// code 换取token</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> res = client.exchange_code(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求发送，axum中不能使用block请求，防止阻塞框架的异步事件循环</span></span><br><span class="line"><span class="keyword">let</span> res = res.request_async(async_http_client).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line"><span class="literal">Ok</span>(TokenInfo &#123;</span><br><span class="line">    refresh_token: res.refresh_token().unwrap().secret().to_string(),</span><br><span class="line">    access_token: res.access_token().secret().to_string(),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这部分不复杂，按文档配好本地，可以访问<code>http://localhost:8000/google/auth</code>来尝试上述<code>flow</code></p><h2 id="使用keycloak-IDP"><a href="#使用keycloak-IDP" class="headerlink" title="使用keycloak IDP"></a>使用keycloak IDP</h2><h3 id="keycloak-配置"><a href="#keycloak-配置" class="headerlink" title="keycloak 配置"></a>keycloak 配置</h3><p>上边流程怎么让keycloak这个身份和访问管理系统接管呢，答案是使用<code>keycloak IDP</code> (<code>Identity provider</code>)</p><p>我们先看下需要如何配置相应配置，这里先用<a href="https://registry.terraform.io/providers/mrparkers/keycloak/latest/docs" target="_blank" rel="noopener"><code>terraform - keycloak provider</code></a> 展示下配置。</p><blockquote><p>等效的页面配置可以后边参考之前的链接 <a href="https://keycloakthemes.com/blog/how-to-setup-sign-in-with-google-using-keycloak" target="_blank" rel="noopener">How to setup Sign in with Google using Keycloak</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 这里使用默认的admin-cli配置keycloak</span><br><span class="line"># 也可生成一个专门的client，用clientId+clientSecret的方式</span><br><span class="line">provider &quot;keycloak&quot; &#123;</span><br><span class="line">  client_id &#x3D; &quot;admin-cli&quot;</span><br><span class="line">  url       &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&quot;</span><br><span class="line">  username  &#x3D; &quot;***&quot;</span><br><span class="line">  password  &#x3D; &quot;***&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 1. 创建一个realm（领域），并启用, 类似命名空间，代表一个安全的独立区域</span><br><span class="line">resource &quot;keycloak_realm&quot; &quot;realm_axum_koans&quot; &#123;</span><br><span class="line">  realm   &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  enabled &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 2. 添加google idp， 这里需要google client credentials</span><br><span class="line"></span><br><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  realm         &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  # client_id和secret通过环境变量获取</span><br><span class="line">  client_id     &#x3D; var.google_client_id</span><br><span class="line">  client_secret &#x3D; var.google_client_secret</span><br><span class="line">  trust_email   &#x3D; true</span><br><span class="line">  # &quot;*&quot; 则不约束使用此idp的domain</span><br><span class="line">  hosted_domain &#x3D; &quot;*&quot;</span><br><span class="line">  sync_mode     &#x3D; &quot;IMPORT&quot;</span><br><span class="line">  provider_id   &#x3D; &quot;google&quot;</span><br><span class="line"></span><br><span class="line">  default_scopes &#x3D; &quot;openid profile email&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 3. 添加将要用来google auth打交道的client</span><br><span class="line">resource &quot;keycloak_openid_client&quot; &quot;client_axum_koans&quot; &#123;</span><br><span class="line">  realm_id &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  name     &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  enabled  &#x3D; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  client_id             &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  client_secret         &#x3D; &quot;***&quot;</span><br><span class="line">  standard_flow_enabled &#x3D; true</span><br><span class="line"></span><br><span class="line">  access_type &#x3D; &quot;CONFIDENTIAL&quot;</span><br><span class="line">  # 配置auth callback url</span><br><span class="line">  valid_redirect_uris &#x3D; [</span><br><span class="line">    &quot;http:&#x2F;&#x2F;localhost:8000&#x2F;keycloak&#x2F;login-callback&quot;</span><br><span class="line">  ]</span><br><span class="line">  web_origins        &#x3D; [&quot;*&quot;]</span><br><span class="line">  use_refresh_tokens &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看代码版的配置稍微有点多，主要配置其实就只有注释里的三处，然后google OAuth的代理设置就完成了，不信我们继续往下看怎么代码接入</p><h3 id="keycloak-auth接入"><a href="#keycloak-auth接入" class="headerlink" title="keycloak auth接入"></a>keycloak auth接入</h3><p>上边<code>keycloak</code>配置了<code>realm</code>，后边授权和<code>token</code>获取都会和这个<code>realm</code>下的<code>issueUrl</code>打交道，这里<code>issueUrl</code>就类似<code>google</code>的<code>auth server</code> 地址。 </p><ol><li>初始化<code>keycloak oidc client</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::new</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们配置生成的issue_url将会是： http://localhost:8080/realms/axum-koans</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置token url, auth url 和auth callback url(redirect url)</span></span><br><span class="line"><span class="keyword">let</span> token_url = TokenUrl::new(get_url_with_issuer(</span><br><span class="line">    &amp;config.issuer_url,</span><br><span class="line">    <span class="string">"/protocol/openid-connect/token"</span>,</span><br><span class="line">))</span><br><span class="line">.unwrap();</span><br><span class="line"><span class="keyword">let</span> auth_url = AuthUrl::new(get_url_with_issuer(</span><br><span class="line">    &amp;config.issuer_url,</span><br><span class="line">    <span class="string">"/protocol/openid-connect/auth"</span>,</span><br><span class="line">))</span><br><span class="line">.unwrap();</span><br><span class="line"><span class="keyword">let</span> redirect_url = RedirectUrl::new(config.redirect_url).unwrap();</span><br><span class="line"><span class="keyword">let</span> client = BasicClient::new(client_id, <span class="literal">Some</span>(client_secret), auth_url, <span class="literal">Some</span>(token_url))</span><br><span class="line">    .set_redirect_uri(redirect_url);</span><br></pre></td></tr></table></figure><ol start="2"><li>生成<code>auth_url</code></li></ol><p>方法基本和之前<code>google</code>配置一模一样。</p><p>这里也能看出为啥需要<code>oidc</code>协议，其实就是抽象化，提供了一种安全、标准化和可扩展的身份验证和授权协议。它简化了应用程序中的身份管理和访问控制，提供了一致的用户登录体验，并提高了应用程序的安全性。</p><p>这里<code>auth url</code>默认跳转的是<code>keycloak</code>登录页面，然后<code>google idp</code>是作为一种登录选项让用户选择。但如果就打算让用户直接<code>google</code>登录，可以跳过<code>keycloak</code>登录页。</p><p>方法是使用客户端建议的<code>idp（kc_idp_hint）</code>:<a href="https://www.keycloak.org/docs/latest/server_admin/#_client_suggested_idp" target="_blank" rel="noopener"><code>Client-suggested Identity Provider</code></a></p><p>这样就可以直接使用指定的<code>idp</code>进行授权登录</p><p>代码如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::auth_url</span></span><br><span class="line">client.add_extra_param(<span class="string">"kc_idp_hint"</span>, <span class="string">"google"</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li><code>auth callback</code>换取<code>token</code></li></ol><p>方法也同 <code>google auth callback</code>, 这里不赘述了。</p><p>不过这里拿到的是<code>keycloak</code>的<code>token</code>。要是需要<code>google</code>的<code>token</code>怎么办？</p><p>别急，有两种办法。</p><h2 id="方法一：-token-exchange"><a href="#方法一：-token-exchange" class="headerlink" title="方法一： token-exchange"></a>方法一： token-exchange</h2><p><a href="https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange" target="_blank" rel="noopener"><code>token-exchange</code></a> 是用于<code>token</code>交换场景，我们这里是用<code>keycloak token</code>换取外部<code>google token</code>（<code>external token</code>）</p><h3 id="相应keycloak配置"><a href="#相应keycloak配置" class="headerlink" title="相应keycloak配置"></a>相应<code>keycloak</code>配置</h3><blockquote><p><code>token-exchange</code>目前还是<code>keycloak</code>预览（<code>preview</code>）功能，需要至少在<code>features</code>中启用<code>admin-fine-grained-authz,token-exchange</code>才可使用(详见<code>keycloak docker-composer</code>配置 )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启用idp获取refresh token</span><br><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">  # for token exchange to get google access token</span><br><span class="line">  request_refresh_token &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启用 idp token exchange permission, 并用policy关联对应的client</span><br><span class="line">resource &quot;keycloak_identity_provider_token_exchange_scope_permission&quot; &quot;oidc_idp_permission&quot; &#123;</span><br><span class="line">  realm_id       &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  provider_alias &#x3D; keycloak_oidc_google_identity_provider.google.alias</span><br><span class="line">  policy_type    &#x3D; &quot;client&quot;</span><br><span class="line">  clients &#x3D; [</span><br><span class="line">    keycloak_openid_client.client_axum_koans.id</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> token_url =</span><br><span class="line">   <span class="built_in">format!</span>( <span class="string">"&#123;&#125;/protocol/openid-connect/token"</span>,&amp;<span class="keyword">self</span>.config.issuer_url);</span><br><span class="line"><span class="keyword">let</span> response = Client::new()</span><br><span class="line">    .post(token_url)</span><br><span class="line">    .form(&amp;[</span><br><span class="line">        <span class="comment">// token exchange type</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"grant_type"</span>,</span><br><span class="line">            <span class="string">"urn:ietf:params:oauth:grant-type:token-exchange"</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 传入keycloak access token</span></span><br><span class="line">        (<span class="string">"subject_token"</span>, &amp;access_token),</span><br><span class="line">        (<span class="string">"client_id"</span>, &amp;<span class="keyword">self</span>.config.client_id),</span><br><span class="line">        (<span class="string">"client_secret"</span>, &amp;<span class="keyword">self</span>.config.client_secret),</span><br><span class="line">        <span class="comment">// 请求换取google access token</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"requested_token_type"</span>,</span><br><span class="line">            <span class="string">"urn:ietf:params:oauth:token-type:access_token"</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 要换取的external idp: google</span></span><br><span class="line">        (<span class="string">"requested_issuer"</span>, <span class="string">"google"</span>),</span><br><span class="line">    ])</span><br><span class="line">    .send()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"><span class="comment">// json deserialized as access token</span></span><br><span class="line"><span class="literal">Ok</span>(from_str(&amp;response.text().<span class="keyword">await</span>?)?)</span><br></pre></td></tr></table></figure><p>这样就获取到了可用的<code>google access token</code>， 实际上内部是通过<code>google refresh token</code>换取到的。</p><p>这样常规请求没问题了，只要你有<code>keycloak access token</code>, 就能换取到<code>google access token</code>来请求<code>google api</code>。so easy?!</p><h2 id="方法二：broker-读取-stored-token"><a href="#方法二：broker-读取-stored-token" class="headerlink" title="方法二：broker 读取 stored token"></a>方法二：broker 读取 stored token</h2><p>然而，要是需要<code>google refresh token</code>怎么办？</p><p>有些场景是客户端需要自己通过<code>google refresh token</code>换取<code>access token</code>来发起请求的，难道这个时候客户端先去拿个<code>keycloak access token</code>么。。。？</p><p>这就可以用<a href="https://www.keycloak.org/docs/latest/server_admin/#retrieving-external-idp-tokens" target="_blank" rel="noopener">Retrieving external IDP tokens</a></p><p>底层实现是授权时存储了<code>external token</code>,再配合添加<code>broker read token</code>权限给生成的用户，就可以用<code>keycloak access token</code>换取存储的<code>external access token + refresh token</code>.</p><h3 id="相应keycloak配置-1"><a href="#相应keycloak配置-1" class="headerlink" title="相应keycloak配置"></a>相应keycloak配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">  # for retrieve idp token (with refresh token)</span><br><span class="line">  &#x2F;&#x2F; 存储idp token</span><br><span class="line">  store_token                   &#x3D; true</span><br><span class="line">  &#x2F;&#x2F; 用户生成是添加broker read token 权限</span><br><span class="line">  add_read_token_role_on_create &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题外话：这里<code>add_read_token_role_on_create</code>对应的配置在21.1.1版<code>keycloak admin</code>页面没有，但<code>admin api</code>确可以设置，也是很tricky</p></blockquote><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>就是直接换取<code>refresh_token</code>, 请求地址指明对应的<code>idp</code>即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::get_idp_token</span></span><br><span class="line"><span class="keyword">let</span> token_url = <span class="built_in">format!</span>( <span class="string">"&#123;&#125;/broker/google/token"</span>,&amp;<span class="keyword">self</span>.config.issuer_url);</span><br><span class="line"><span class="keyword">let</span> response = Client::new()</span><br><span class="line">    .get(token_url)</span><br><span class="line">    .bearer_auth(access_token)</span><br><span class="line">    .header(CONTENT_TYPE, HeaderValue::from_static(<span class="string">"application/json"</span>))</span><br><span class="line">    .send()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> res = response.text().<span class="keyword">await</span>?;</span><br><span class="line"><span class="literal">Ok</span>(from_str(&amp;res)?)</span><br></pre></td></tr></table></figure><blockquote><p>题外话：当然直接给用户这么获取<code>refresh token</code>的能力并不安全，还需要考虑对<code>broker read token</code>接口的访问约束等来更好的保证安全<code>token</code>换取。</p></blockquote><p>上边<code>keycloak</code>授权方案可以本地配好环境后，用<a href="http://localhost:8000/keycloak/login" target="_blank" rel="noopener">http://localhost:8000/keycloak/login</a> 来尝试。</p><hr><p>好了，<code>keycloak</code>如何管理<code>external auth</code>到这里就结束了。以上是我在使用<code>keycloak</code>的一些摸索和思考，欢迎大家一起探讨。</p><p>再次附上本文的代码地址以供验证：<a href="https://github.com/NewbMiao/axum-koans" target="_blank" rel="noopener">https://github.com/NewbMiao/axum-koans</a></p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      深入解读-如何用keycloak管理external auth
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/categories/rust/"/>
    
      <category term="OIDC" scheme="http://blog.newbmiao.com/categories/rust/OIDC/"/>
    
      <category term="oauth2" scheme="http://blog.newbmiao.com/categories/rust/OIDC/oauth2/"/>
    
    
      <category term="terraform" scheme="http://blog.newbmiao.com/tags/terraform/"/>
    
      <category term="rust" scheme="http://blog.newbmiao.com/tags/rust/"/>
    
      <category term="oauth2" scheme="http://blog.newbmiao.com/tags/oauth2/"/>
    
      <category term="OIDC" scheme="http://blog.newbmiao.com/tags/OIDC/"/>
    
      <category term="axum" scheme="http://blog.newbmiao.com/tags/axum/"/>
    
      <category term="keycloak" scheme="http://blog.newbmiao.com/tags/keycloak/"/>
    
      <category term="token-exchange" scheme="http://blog.newbmiao.com/tags/token-exchange/"/>
    
      <category term="google-idp" scheme="http://blog.newbmiao.com/tags/google-idp/"/>
    
  </entry>
  
  <entry>
    <title>如何在docker中缓存加速Rust依赖构建</title>
    <link href="http://blog.newbmiao.com/2021/11/21/cache-rust-dependencies-with-docker-build.html"/>
    <id>http://blog.newbmiao.com/2021/11/21/cache-rust-dependencies-with-docker-build.html</id>
    <published>2021-11-21T09:14:23.000Z</published>
    <updated>2023-06-18T00:52:29.957Z</updated>
    
    <content type="html"><![CDATA[<!-- [TOC] --><p>最近开始学习《陈天 · Rust 编程第一课》，在用<code>docker</code>镜像打包构建代码示例时，每次都会在更新<code>crate.io</code>索引上等上一会，即便在没有修改<code>Cargo.tomal</code>依赖的前提下。</p><p>想着难道没有办法缓存下更新么，于是就有了这篇新手踩坑指南。</p><a id="more"></a><h2 id="本地缓存-失败"><a href="#本地缓存-失败" class="headerlink" title="本地缓存 - 失败"></a>本地缓存 - 失败</h2><p>查阅有在<code>docker</code>中指定<code>CARGO_HOME</code>到宿主机来缓存<code>crate.io</code>索引</p><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --user "$(id -u)":"$(id -g)" -v "$PWD":/usr/src/myapp -w /usr/src/myapp -e CARGO_HOME=".cargo" rust cargo run</span><br></pre></td></tr></table></figure><p>结果，镜像run失败了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   Compiling libc v0.2.107</span><br><span class="line">   Compiling autocfg v1.0.1</span><br><span class="line">   Compiling siphasher v0.3.7</span><br><span class="line">   Compiling unicode-xid v0.2.2</span><br><span class="line">   Compiling memchr v2.4.1</span><br><span class="line">   Compiling lazy_static v1.4.0</span><br><span class="line">   Compiling ppv-lite86 v0.2.15</span><br><span class="line">   Compiling pin-project-lite v0.2.7</span><br><span class="line">   Compiling pkg-config v0.3.22</span><br><span class="line">error: failed to build archive: Input/output error</span><br><span class="line"></span><br><span class="line">error: error writing dependencies to `/usr/src/myapp/.target/debug/deps/pkg_config-8dafe7024c916ac6.d`: Input/output error (os error 5)</span><br></pre></td></tr></table></figure><p>一番查阅，应该是环境不一致时<code>pkg-config</code>编译时链接库有问题，详见 <a href="https://ttys3.dev/post/rust-cross-compile-darwin-target-troubleshooting/" target="_blank" rel="noopener">Rust 交叉编译 OSX 二进制失败原因分析</a> 和 <a href="https://stackoverflow.com/a/49173699/4431337" target="_blank" rel="noopener">Unable to run a Docker image with a Rust executable</a></p><h2 id="镜像缓存-成功"><a href="#镜像缓存-成功" class="headerlink" title="镜像缓存 - 成功"></a>镜像缓存 - 成功</h2><p>然后就搜到了这篇<a href="https://stackoverflow.com/a/58474618/4431337" target="_blank" rel="noopener">cache-rust-dependencies-with-docker-build</a></p><p>真是非常tricky！</p><p>思想很简单，就是缓存要在依赖不变的前提下，而docker build时源代码更改会使缓存的<code>docker layer</code>失效。</p><p>那就先用一个不会变得源代码编译依赖，编译好依赖缓存layer，再文件替换到实际代码，重新进行编译就正常运行加缓存两不误了。</p><p>具体构建方式如下：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> rust</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"fn main() &#123;&#125;"</span> &gt; dummy.rs</span></span><br><span class="line"><span class="keyword">ARG</span> SRC_DIR</span><br><span class="line"><span class="keyword">ENV</span> SRC_DIR=$&#123;SRC_DIR:-&#125;</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;SRC_DIR&#125;</span>/Cargo.toml .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s#src/main.rs#dummy.rs#'</span> Cargo.toml</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cargo build --release</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s#dummy.rs#src/main.rs#'</span> Cargo.toml</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;SRC_DIR&#125;</span>/. .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cargo build --release</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"target/release/app"</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>这里构建参数<code>SRC_DIR</code>是为了指定不同代码，复用同一个<code>Dockerfile</code></p></blockquote><p>相应的<code>Cargo.toml</code>指定打包的程序名和路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[bin]]</span><br><span class="line">name = "app"</span><br><span class="line">path = "src/main.rs"</span><br></pre></td></tr></table></figure><p>打包和运行则可以一行命令搞定：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run.sh</span></span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">WORKSPACE=$(cd <span class="string">"$(dirname "</span>$<span class="number">0</span><span class="string">")"</span> &amp;&amp; pwd -P)</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --rm -it <span class="string">"<span class="variable">$(docker build --build-arg SRC_DIR="$SRC_DIR" -q "$WORKSPACE" -t "rust-$SRC_DIR")</span>"</span> <span class="comment">#"$@"</span></span></span><br></pre></td></tr></table></figure><p>运行时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> eg：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SRC_DIR=scrape_url sh run.sh https://www.rust-lang.org/ rust.md</span></span><br></pre></td></tr></table></figure><p>完美缓存了依赖更新，可以继续学习了</p><p>另外也推荐下陈天老师的rust课，由浅入深，感兴趣的同学可以试试</p><p><img src="http://media.newbmiao.com/assets/rust.jpeg" alt="陈天 · Rust 编程第一课"></p><blockquote><p>本文代码示例详见<a href="https://github.com/NewbMiao/rust-koan" target="_blank" rel="noopener">rust-koan</a></p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      cache-rust-dependencies-with-docker-build
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/categories/rust/"/>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/tags/rust/"/>
    
      <category term="docker" scheme="http://blog.newbmiao.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊鉴权背后的那些技术</title>
    <link href="http://blog.newbmiao.com/2021/09/19/tech-behind-authentication.html"/>
    <id>http://blog.newbmiao.com/2021/09/19/tech-behind-authentication.html</id>
    <published>2021-09-19T15:00:09.000Z</published>
    <updated>2023-06-18T15:04:08.040Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>最近弄了一个<code>keycloak</code>鉴权相关demo(地址附文末)， 可以让不熟悉的<code>keycloak</code>的同学有一个快速、直观的了解。</p><p>今天结合背后的技术概念，简单聊聊：鉴权（<code>authentication</code>）和授权（<code>authorization</code>）以及<code>Oauth2</code>、<code>OpenID Connect</code>、<code>JWT</code> 和 <code>JWKS</code>。</p><a id="more"></a><h2 id="鉴权-VS-授权"><a href="#鉴权-VS-授权" class="headerlink" title="鉴权 VS 授权"></a>鉴权 VS 授权</h2><p>这两个概念的英文太相近，真是傻傻分不清，不过中文还好。</p><p>鉴权（<code>Authentication</code>, 也作<code>AuthN</code>）：判断你是谁，通过密码或者授权码之类凭证</p><p>授权（<code>Authorization</code>，也作<code>AuthZ</code>）：授权用户或角色等访问资源的权限，</p><p>如下图：</p><p><img src="https://www.okta.com/sites/default/files/styles/1640w_scaled/public/media/image/2020-10/Authentication_vs_Authorization.png?itok=uBFRCfww" alt="Authentication VS Authorization"></p><p>举例来说会更清晰：</p><p>假如你需要让A帮忙喂宠物，你给A了一个一次性的密码Key让其可以通过你家门禁（鉴权）。<br>但A进去后，只有到厨房拿宠物粮和客厅喂宠物，不能到其他房间则是其持有密码Key的权限（授权）</p><h2 id="Oauth2"><a href="#Oauth2" class="headerlink" title="Oauth2"></a>Oauth2</h2><p><code>Oauth2</code>是一个授权的协议，为客户端授权提供了一系列授权的流程来获取授权的访问令牌（<code>AccessToken</code>），比如</p><ul><li><code>Authorization Code flow</code><br>需要提供注册的clientID和clientSecret<br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image5.png" alt="Authorization Code flow"></li><li><del><code>Implicit flow</code></del><br>省掉了<code>Code</code>环节, 放松了对客户端的校验，牺牲安全性来提高效率，<strong>已不推荐</strong><br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image1.png" alt="Implicit flow"></li><li><code>Authorization Code flow (with PKCE)</code><br>需要提供注册的clientID和即时生成的 <code>code challenge</code>（像一次性的secret，不可被篡改）<br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image6.png" alt="PKCE flow"></li></ul><p>为什么需要<code>Oauth2</code>?</p><p>还拿喂宠物的例子来说，你找代理喂宠物，不会想把自己的密码直接给他，那太不安全，需要一个安全的机制来临时授予尽量少的权限给代理方。</p><h2 id="OpenID-connect-OIDC"><a href="#OpenID-connect-OIDC" class="headerlink" title="OpenID connect (OIDC)"></a>OpenID connect (OIDC)</h2><p><code>OIDC</code>是在<code>Oauth2</code>协议基础上扩展的认证层，提供ID令牌（<code>IDToken</code>）可以让客户端通过认证来识别用户.</p><p>应该是当今最常用的鉴权实现协议，有很多相关实现的通用类库。</p><h2 id="JWT-amp-amp-JWKS"><a href="#JWT-amp-amp-JWKS" class="headerlink" title="JWT &amp;&amp; JWKS"></a>JWT &amp;&amp; JWKS</h2><p>上边提到的<code>AccessToken</code>和<code>IDToken</code>都是用<code>Json Web Token（JWT）</code>技术来实现的。</p><p><code>JWT</code>分为三段（<code>.</code>分隔，各自<code>base64Url</code>编码）</p><ul><li>header<br>包含如签名算法<code>alg</code>，签名公钥ID <code>kid</code>, 类型等</li><li>payload<br>包含令牌签发相关数据如签发人<code>iss</code>，过期时间<code>exp</code>,签发时间<code>iat</code>等，及自定义的数据如权限及用户标识等<br>具体token所携带的信息可以通过<a href="https://jwt.io/" target="_blank" rel="noopener">jwt.io</a>来查看</li><li>signature<br>token前两部分的签名，防止被篡改</li></ul><p>这里校验可以用签名的公钥,可以在<code>JSON Web Key Set（JWKS）</code>中通过<code>header</code>的公钥id<code>kid</code>和<code>payload</code>的签发服务<code>iss</code>的配置服务中（<code>/.well-known/openid-configuration</code>）找到。</p><p>如demo中:</p><ul><li>签发服务（<code>iss</code>)<br><code>http://localhost/auth/realms/myrealm</code></li><li>配置发现（<code>discovery configuration</code>)<br><code>http://localhost/auth/realms/myrealm/.well-known/openid-configuration</code></li><li><code>JWK</code>公钥配置(<code>jwks_uri</code>)<br><code>http://localhost/auth/realms/myrealm/protocol/openid-connect/certs</code></li></ul><h2 id="Keycloak"><a href="#Keycloak" class="headerlink" title="Keycloak"></a>Keycloak</h2><p>说这么一圈，回到demo的主题，<code>keycloak</code>,一种开源的身份及访问管理（<code>IAM</code>）服务。官方称，“为现代应用系统和服务提供开源的鉴权和授权访问控制管理”。</p><p>实现了<code>Oauth2,OpenID Connet,Saml</code>协议的单点登陆<code>SSO</code>，支持多种第三方身份服务<code>Identity Provider(IdP)</code> （OpenID Connect, SAML2.0 IdPs，Github，Google等）来做鉴权，方便简单可以开箱即用。</p><p>在我提供的demo中，主要展示了鉴权相关：</p><ul><li>获取<code>token</code>：在客户端（<code>web</code>页面）使用推荐的<code>PKCE</code>方式获取`accessToken</li><li>校验<code>token</code>：用<code>token issuer</code>配置中<code>jwks</code>的公钥来验证token签名是否合法</li></ul><blockquote><p>相当于离线验证，只能知道<code>token</code>是否合法，不能知道token是否被失效等，更安全的方式是通过<code>token introspection</code>接口验证token是否还有效)</p></blockquote><p>其中<code>web</code>页面内用了<code>react</code>,获取<code>token</code>用了<code>@react-keycloak/web</code>, <code>token</code>校验用了<code>OpenPolicyAgent</code>(单纯为玩，不是推荐用法)<br>为了避免网页跨域<code>cors</code>问题加了<code>nginx</code>反向代理</p><p>动图如下：<br><img src="http://media.newbmiao.com/tech/kecloak-authN.gif" alt="demo"></p><p>具体示例详见：<strong><a href="https://github.com/NewbMiao/keycloak-authN" target="_blank" rel="noopener">https://github.com/NewbMiao/keycloak-authN</a></strong>, 有<code>readme</code>，一键启动。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      tech-behind-authentication
    
    </summary>
    
    
      <category term="tech" scheme="http://blog.newbmiao.com/categories/tech/"/>
    
      <category term="OIDC" scheme="http://blog.newbmiao.com/categories/tech/OIDC/"/>
    
      <category term="oauth2" scheme="http://blog.newbmiao.com/categories/tech/OIDC/oauth2/"/>
    
    
      <category term="oauth2" scheme="http://blog.newbmiao.com/tags/oauth2/"/>
    
      <category term="OIDC" scheme="http://blog.newbmiao.com/tags/OIDC/"/>
    
      <category term="keycloak" scheme="http://blog.newbmiao.com/tags/keycloak/"/>
    
      <category term="authentication" scheme="http://blog.newbmiao.com/tags/authentication/"/>
    
      <category term="authorization" scheme="http://blog.newbmiao.com/tags/authorization/"/>
    
  </entry>
  
  <entry>
    <title>二分递归版or-channel模式的问题</title>
    <link href="http://blog.newbmiao.com/2021/08/22/recursive-ordone-issue.html"/>
    <id>http://blog.newbmiao.com/2021/08/22/recursive-ordone-issue.html</id>
    <published>2021-08-22T13:04:19.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>今天在修正昨天的文章《orDone的两种实现》中的压测代码时，无意发现其中的二分递归版的代码是有问题的。</p><p>主要是<code>goroutine</code>泄露的问题，下边简单说明下，也参考自文章<a href="https://tjjsjwhj.me/2021/04/25/go-or-done/" target="_blank" rel="noopener">记一次学习 orDone 模式爬坑经历</a></p><a id="more"></a><h2 id="goroutine泄露"><a href="#goroutine泄露" class="headerlink" title="goroutine泄露"></a>goroutine泄露</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">    <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 2个也是一种特殊情况</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//超过两个，二分法递归处理</span></span><br><span class="line">        m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-or(channels[:m]...):</span><br><span class="line">        <span class="keyword">case</span> &lt;-or(channels[m:]...):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>原代码递归时，没有将结束通道<code>orDone</code>合并，在<code>orDone</code>关闭后，没法通知递归中的<code>goroutine</code>退出，有<code>goroutine</code>泄露的可能</p><p>可修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrWithIssue(<span class="built_in">append</span>(channels[:m:m], orDone)...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrWithIssue(<span class="built_in">append</span>(channels[m:], orDone)...):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无限递归"><a href="#无限递归" class="headerlink" title="无限递归"></a>无限递归</h2><p>以上代码时，还有个问题是在参数为三个<code>chan</code>时会无限递归，(文末参考文章里有通过打印协程数来测试这个问题的代码，感兴趣可以去看下)</p><p>递归树如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3个时有无限递归的问题:</span></span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">    f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">       f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure><p>所以需要对3这种<code>case</code>区分处理</p><p>最终代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrRecur</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 特殊情况，只有0个或者1个chan</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 特殊情况</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 特殊情况</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">2</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 超过3个，二分法递归处理</span></span><br><span class="line">   m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrRecur(<span class="built_in">append</span>(channels[:m:m], orDone)...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrRecur(<span class="built_in">append</span>(channels[m:], orDone)...):</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再补充下修正后压测结果，二分递归比反射性能更好些</p><p><img src="http://media.newbmiao.com/dig101/go/orDoneTime.png" alt="时间消耗"><br><img src="http://media.newbmiao.com/dig101/go/orDoneMemory.png" alt="内存消耗"></p><p>感兴趣可以自己跑下<a href="https://github.com/NewbMiao/Dig101-Go/tree/master/concurrency/channel/schedule/orDone" target="_blank" rel="noopener">压测代码</a></p><blockquote><p>虽然是常见的orDone模式，但还是有不少可以探究的地方，想要用好chan还是需要足够仔细啊。</p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      recursive-o-issue
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="or-channel-pattern" scheme="http://blog.newbmiao.com/tags/or-channel-pattern/"/>
    
  </entry>
  
  <entry>
    <title>or-channel模式的两种实现</title>
    <link href="http://blog.newbmiao.com/2021/08/19/2-way-of-or-done-pattern.html"/>
    <id>http://blog.newbmiao.com/2021/08/19/2-way-of-or-done-pattern.html</id>
    <published>2021-08-19T14:08:01.000Z</published>
    <updated>2023-06-18T00:52:29.950Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p><code>or</code> channel模式是一种并发控制模式，旨在多任务场景下实现，有一个任务成功返回即立即结束等待。</p><p>今天我们来看下两种不同的实现方式：</p><a id="more"></a><h2 id="方式一-递归"><a href="#方式一-递归" class="headerlink" title="方式一 递归"></a>方式一 递归</h2><p>利用二分法递， 将所有待监听信号的<code>chan</code>都<code>select</code>起来，</p><p>当有第一个<code>chan</code>返回时，<code>close orDone</code> 来通知读取方已有第一个任务返回</p><p>代码如下比较直观：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入多个并发chan，返回是否结束的 orDone chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Or</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 只有零个或者1个chan</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 返回nil， 让读取阻塞等待</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 返回时利用close做结束信号的广播</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用select监听第一个chan的返回</span></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 直接select</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 二分法递归处理</span></span><br><span class="line">   m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-Or(channels[:m]...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-Or(channels[m:]...):</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二-利用反射"><a href="#方式二-利用反射" class="headerlink" title="方式二 利用反射"></a>方式二 利用反射</h2><p>这里要用到<code>reflect.SelectCase</code>, 他可以描述一种<code>select</code>的<code>case</code>,<br>来指明其接受的是<code>chan</code>的读取或发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SelectCase <span class="keyword">struct</span> &#123;</span><br><span class="line"> Dir  SelectDir <span class="comment">// direction of case</span></span><br><span class="line"> Chan Value     <span class="comment">// channel to use (for send or receive)</span></span><br><span class="line"> Send Value     <span class="comment">// value to send (for send)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个，就可以之间遍历，不用递归来实现有限的<code>select case</code>构造</p><p>最后用<code>reflect.Select(cases)</code>监听信号就可以了，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrInReflect</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 只有0个或者1个</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">  <span class="comment">// 利用反射构建SelectCase，这里是读取</span></span><br><span class="line">  <span class="keyword">var</span> cases []reflect.SelectCase</span><br><span class="line">  <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line">   cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">    Dir:  reflect.SelectRecv,</span><br><span class="line">    Chan: reflect.ValueOf(c),</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机选择一个可用的case</span></span><br><span class="line">  reflect.Select(cases)</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h2><p>这两种都可以支持大量<code>chan</code>的信号监听，那性能差异大么</p><p>虽说递归开销肯定不小，反射也不一定效率高，拿个压测来试试吧</p><p>先构造一下<code>chan</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsStream</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, values ...<span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> s := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 退出时关闭chan             </span></span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(s)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">case</span> s &lt;- v:</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后压测</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []<span class="keyword">struct</span> &#123;</span><br><span class="line"> name <span class="keyword">string</span></span><br><span class="line"> f    <span class="function"><span class="keyword">func</span><span class="params">(...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;&#123;</span><br><span class="line"> &#123;<span class="string">"reflection"</span>, OrInReflect&#125;,</span><br><span class="line"> &#123;<span class="string">"recursion"</span>, OrRecur&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkOr</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">  <span class="keyword">for</span> n := <span class="number">8</span>; n &lt;= <span class="number">1024</span>; n *= <span class="number">2</span> &#123;</span><br><span class="line">   b.Run(fmt.Sprintf(<span class="string">"%s/%d"</span>, f.name, n), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">     b.StopTimer()</span><br><span class="line">     done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">     <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">     streams := <span class="built_in">make</span>([]&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, n)</span><br><span class="line">     <span class="keyword">for</span> i := <span class="keyword">range</span> streams &#123;</span><br><span class="line">      streams[i] = AsStream(done, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>&#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     b.StartTimer()</span><br><span class="line">     &lt;-f.f(streams...)</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了下结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/NewbMiao/Dig101-Go/concurrency/channel/schedule/or</span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-8750</span>H CPU @ <span class="number">2.20</span>GHz</span><br><span class="line">BenchmarkOr/reflection/<span class="number">8</span><span class="number">-12</span>                    <span class="number">60044</span>             <span class="number">22924</span> ns/op            <span class="number">2839</span> B/op         <span class="number">28</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">16</span><span class="number">-12</span>                   <span class="number">82941</span>             <span class="number">27764</span> ns/op            <span class="number">4684</span> B/op         <span class="number">41</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">32</span><span class="number">-12</span>                   <span class="number">56890</span>             <span class="number">40326</span> ns/op            <span class="number">8397</span> B/op         <span class="number">66</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">64</span><span class="number">-12</span>                   <span class="number">33350</span>             <span class="number">90301</span> ns/op           <span class="number">16485</span> B/op        <span class="number">116</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">128</span><span class="number">-12</span>                  <span class="number">17476</span>            <span class="number">109545</span> ns/op           <span class="number">34300</span> B/op        <span class="number">230</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">256</span><span class="number">-12</span>                   <span class="number">8155</span>            <span class="number">257080</span> ns/op           <span class="number">68398</span> B/op        <span class="number">443</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">512</span><span class="number">-12</span>                   <span class="number">4018</span>            <span class="number">429550</span> ns/op          <span class="number">134260</span> B/op        <span class="number">842</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">1024</span><span class="number">-12</span>                  <span class="number">2131</span>            <span class="number">890946</span> ns/op          <span class="number">266877</span> B/op       <span class="number">1648</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">8</span><span class="number">-12</span>                    <span class="number">186949</span>              <span class="number">6770</span> ns/op            <span class="number">1190</span> B/op         <span class="number">12</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">16</span><span class="number">-12</span>                   <span class="number">127618</span>             <span class="number">10651</span> ns/op            <span class="number">2048</span> B/op         <span class="number">21</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">32</span><span class="number">-12</span>                    <span class="number">83200</span>             <span class="number">24578</span> ns/op            <span class="number">3405</span> B/op         <span class="number">35</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">64</span><span class="number">-12</span>                    <span class="number">69890</span>             <span class="number">33589</span> ns/op            <span class="number">5162</span> B/op         <span class="number">53</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">128</span><span class="number">-12</span>                   <span class="number">32719</span>             <span class="number">58391</span> ns/op            <span class="number">8301</span> B/op         <span class="number">86</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">256</span><span class="number">-12</span>                   <span class="number">10000</span>            <span class="number">162016</span> ns/op           <span class="number">13487</span> B/op        <span class="number">140</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">512</span><span class="number">-12</span>                    <span class="number">7225</span>            <span class="number">283879</span> ns/op           <span class="number">24199</span> B/op        <span class="number">252</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">1024</span><span class="number">-12</span>                   <span class="number">3112</span>            <span class="number">645105</span> ns/op           <span class="number">50744</span> B/op        <span class="number">528</span> allocs/op</span><br></pre></td></tr></table></figure><p>压测结果如图所示<br><img src="http://media.newbmiao.com/dig101/go/orBenchmark.png" alt="orBenchmark"></p><p>可以看出，大量并发<code>chan</code>场景下， 递归效率更好一些。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      2-way-of-or-channel-pattern
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="or-channel-pattern" scheme="http://blog.newbmiao.com/tags/or-channel-pattern/"/>
    
  </entry>
  
  <entry>
    <title>举例来学cond原语</title>
    <link href="http://blog.newbmiao.com/2021/08/09/one-example-to-learn-cond.html"/>
    <id>http://blog.newbmiao.com/2021/08/09/one-example-to-learn-cond.html</id>
    <published>2021-08-09T13:04:19.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>最近看了鸟窝的《Go并发编程实战课》，写的挺有意思的，打算后边弄些例子再回顾下并发原语。</p><p>今天来看看<code>cond</code>原语。</p><p><code>cond</code> 是用于等待或通知场景下的并发原语，条件不满足时，阻塞(<code>wait</code>)一组<code>goroutine</code>；条件满足后，唤醒单个（<code>signal</code>）或所有(<code>broadcast</code>)阻塞的<code>goroutine</code>.</p><p>比如10个运动员跑步，都准备好了，裁判才发令的例子：</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化带锁的条件变量</span></span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> ready <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起10个协程，随机等待后模拟运动员就位，并记录就位人数（加锁更新）</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Duration(rand.Int63n(<span class="number">5</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">    ready++</span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"运动员#%d 已准备就绪\n"</span>, i)</span><br><span class="line">    <span class="comment">// 广播唤醒所有的等待者</span></span><br><span class="line">    <span class="comment">// 这里用signal也可以，因为等待者只有一个main goroutine</span></span><br><span class="line">    c.Broadcast()</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件满足：10人都就位</span></span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> ready != <span class="number">10</span> &#123;</span><br><span class="line">  c.Wait()</span><br><span class="line">  log.Println(<span class="string">"裁判员被唤醒一次"</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的运动员是否就绪</span></span><br><span class="line">log.Println(<span class="string">"所有运动员都准备就绪。比赛开始，3，2，1, ......"</span>)</span><br></pre></td></tr></table></figure><p>输出差不多如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 运动员#<span class="number">0</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 运动员#<span class="number">4</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">5</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">3</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">9</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">10</span> 运动员#<span class="number">7</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">10</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">11</span> 运动员#<span class="number">1</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">11</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 运动员#<span class="number">6</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 运动员#<span class="number">2</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 运动员#<span class="number">8</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 所有运动员都准备就绪。比赛开始，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span>, ......</span><br></pre></td></tr></table></figure><p>可以看出<code>cond</code>在更改条件或者检查条件时需要加锁处理，避免并发下读写不一致问题。</p><p>里边<code>wait</code>等待条件满足时比较特殊，需要加锁并在<code>for</code>循环中等待，为什么呢？</p><p>根据源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line"> c.checker.check()</span><br><span class="line"> <span class="comment">// 更新等待groutine的计数： wait</span></span><br><span class="line"> t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line"> <span class="comment">// 释放锁，防止阻塞后别的goroutine拿不到锁</span></span><br><span class="line"> c.L.Unlock()</span><br><span class="line"> <span class="comment">// 切走当前goroutine，等待唤起</span></span><br><span class="line"> runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line"> <span class="comment">// 唤起后持有锁</span></span><br><span class="line"> c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wait</code>时，将当前<code>goroutine</code>加到等待队列（<code>notifyList</code>）前释放了锁，避免锁持有导致别的<code>goroutine</code>死锁；</p><p>唤起后，又持有锁，再持有锁前，可能有别的<code>goroutine</code>持有过锁，比如多次<code>signal</code>或者<code>broadcast</code>,<br>这里没法确定，当前<code>goroutine</code>唤起后条件没有改变，所以需要在<code>for</code>循环中检测条件是否依然满足</p><p>即，官方文档说明的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  c.L.Lock()</span></span><br><span class="line"><span class="comment">//  for !condition() &#123;</span></span><br><span class="line"><span class="comment">//      c.Wait()</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  ... make use of condition ...</span></span><br><span class="line"><span class="comment">//  c.L.Unlock()</span></span><br></pre></td></tr></table></figure><p>如果用<code>channel</code>来实现，也可以做类似的事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unbuffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  ch &lt;- <span class="number">1</span> <span class="comment">// i is ready</span></span><br><span class="line"> &#125;(i) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"all is ready!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// buffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(ch) != <span class="number">10</span> &#123;</span><br><span class="line">  time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"all is ready!"</span>)</span><br></pre></td></tr></table></figure><p>但<code>cond</code>的优势在于其同时支持<code>signal</code>和<code>broadcast</code>，<code>channel</code>同时只能实现一种（<code>close</code>算<code>broadcast</code>，但只能用一次，不可重复调用）</p><p>用<code>waitGroup</code>也可以模拟等待条件满足，但是针对的是主<code>goroutine</code>对确定数量<code>goroutine</code>的等待，不像<code>cond</code>只关心条件是否满足，对等待<code>goroutine</code>数目没有要求。</p><p>最后，推荐一个《concurrency-in-go》中提到的代码例子，<a href="https://github.com/kat-co/concurrency-in-go-src/blob/master/an-introduction-to-concurrency/why-is-concurrency-hard/deadlocks-livelocks-and-starvation/livelock/fig-livelock-hallway.go" target="_blank" rel="noopener">fig-livelock-hallway</a></p><p>展示了用<code>cond</code>模拟的狭路相逢谁也过不去的活锁问题。</p><blockquote><p>关于鸟窝的《Go并发编程实战课》，我链接放到<a href="https://time.geekbang.org/column/intro/355?code=pLKPP5Hiu4B61apPRONmbYHopf6Y0TlfGvbXwOEDKKc%3D&utm_term=SPoster" target="_blank" rel="noopener">这里</a>，感兴趣的同学可以去听听，质量很高！</p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      one-example-to-learn-cond
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="cond" scheme="http://blog.newbmiao.com/tags/cond/"/>
    
  </entry>
  
  <entry>
    <title>一个8bytes的内存优化</title>
    <link href="http://blog.newbmiao.com/2021/08/07/one-8-bytes-optimization.html"/>
    <id>http://blog.newbmiao.com/2021/08/07/one-8-bytes-optimization.html</id>
    <published>2021-08-07T07:36:13.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>最近看<a href="https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memor" target="_blank" rel="noopener">Dave Cheney的一篇文章</a>，发现一个有趣的代码片段，里面展示了一个8byte的内存优化。</p><p>代码片段是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSortStrings</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> s := []<span class="keyword">string</span>&#123;<span class="string">"heart"</span>, <span class="string">"lungs"</span>, <span class="string">"brain"</span>, <span class="string">"kidneys"</span>, <span class="string">"pancreas"</span>&#125;</span><br><span class="line"> b.ReportAllocs()</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  <span class="keyword">var</span> ss sort.StringSlice = s</span><br><span class="line">  <span class="keyword">var</span> si sort.Interface = ss</span><br><span class="line">  sort.Sort(si)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码很简单，是对一个<code>[]string</code>做排序的内存分配压测</p><p>其中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ss sort.StringSlice = s</span><br><span class="line"><span class="keyword">var</span> si sort.Interface = ss</span><br><span class="line">sort.Sort(si)</span><br></pre></td></tr></table></figure><p>等同于代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Strings(s)</span><br></pre></td></tr></table></figure><p>涉及了对 <code>[]string</code> 转换为实现排序的接口 <code>sort.Interface</code></p><p>了解<code>iface</code>实现的同学知道其<code>data</code>会存储底层数据，一般是一个机器字长的大小（<code>8bytes</code>）</p><p>而<code>slice</code>是<code>24bytes</code>: 底层数组指针（<code>8bytes</code>）+ 长度（<code>8bytes</code>）+ 容量（<code>8bytes</code>）</p><p>直接存不下，就只能<code>indirection</code>, 存指向切片的指针了</p><p>创建前片指针的过程中，切片escape到了heap上，因为不知道原切片<code>ss</code>是否会在<code>si</code>使用过程中消失。</p><p>即，内存分配发生在了这里！</p><p>看下压测结果（<code>go1.16</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test sort_test.<span class="keyword">go</span> -bench . -benchmem </span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i5<span class="number">-5257</span>U CPU @ <span class="number">2.70</span>GHz</span><br><span class="line">BenchmarkInts<span class="number">-4</span>         <span class="number">18846020</span>                <span class="number">90.09</span> ns/op           <span class="number">24</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  <span class="number">2.663</span>s</span><br></pre></td></tr></table></figure><p>结果就是<code>24bytes</code>啊，那所谓的<code>8bytes</code>优化在哪里呢</p><p>是相对于的<code>go1.16</code>前版本的<code>go</code>的, 比如<code>go1.15</code>下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go1<span class="number">.15</span> test sort_test.<span class="keyword">go</span> -bench . -benchmem </span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkSortStrings<span class="number">-4</span>           <span class="number">8617881</span>               <span class="number">172</span> ns/op              <span class="number">32</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  <span class="number">1.649</span>s</span><br></pre></td></tr></table></figure><p>找了下具体提交，其实就是在内存分配里针对三个机器字大小增加了<code>24bytes</code>的<code>sizeClass</code>，避免原来的向上取整到<code>32bytes</code></p><p>感兴趣的同学可以去看着具体实现：<br><a href="https://github.com/golang/go/commit/14c7caae5074fdf0d97a3ad995e20c63e4065cbf" target="_blank" rel="noopener">runtime: add 24 byte allocation size class</a></p><blockquote><p>题外话，好久没有更新了，不好意思了都，后边再捡起来😂</p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      one-8-bytes-optimization
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="memory" scheme="http://blog.newbmiao.com/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>2020年回顾</title>
    <link href="http://blog.newbmiao.com/2021/01/02/summary-of-2020.html"/>
    <id>http://blog.newbmiao.com/2021/01/02/summary-of-2020.html</id>
    <published>2021-01-02T09:23:34.000Z</published>
    <updated>2023-06-18T00:52:29.957Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，2020年就过去了，是时候说一声再见了。</p><p>2020对于我还是有比较多的新体验。</p><a id="more"></a><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>年初父母来西安一起过年，不料被疫情隔离在小区近一个多月，过了一个慵懒的年，也多了许多陪娃的时间。</p><p>因某些原因，公司不需要我在家办公，然后再大家都开始上班后，我又有近两周的赋闲时间。</p><p>一时兴起，就花时间倒腾了一系列<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1345369054160306177#wechat_redirect" target="_blank" rel="noopener">Go源码分析</a>, 让好久不用的公众号也有了更新。</p><p>那段时间，静下心刨根问底的去研究Go语言设计背后的逻辑，让自己多Go有了更深的理解。</p><p>期间也接触了许多Go社区活跃的大佬，有幸一起探讨一些问题，并做了一期分享，都是之前不曾尝试的体验。</p><p>不得不说，技术这东西只要你感兴趣肯花时间，确实是可以一直挖下去。</p><p>隔离结束后，上半年又搞了许多不曾接触的云原生自动化与策略配置。</p><p>从很有压力、略有排斥，到不去逃避，看英文文档自行解决遇到的技术问题。</p><p>这期间也分享一系列<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1345371288113725441#wechat_redirect" target="_blank" rel="noopener">云原生通用规则引擎（OPA）的入门教程</a>，推广了下这项自己很看好的策略描述语言。</p><p>然后下半年又面向需求开发，学习了前端，把以前只是听过的一些技术单词变成了能力。顺带把自己之前做的小程序云开发重新优化成了一期<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1554691207543504896#wechat_redirect" target="_blank" rel="noopener">入门教程</a>。</p><p>这搁以前，怕是更不会去尝试的东西。</p><p>一路走来，现在的自己，对于技术已经不再执著于某一语言、前端或后端，面向需求开发，只看技术是否合适罢了。</p><h2 id="奶爸"><a href="#奶爸" class="headerlink" title="奶爸"></a>奶爸</h2><p>去年5月，喜提小可爱一枚。</p><p>如今小可爱都快两岁了，吃饭，走路，学本领都很快，不得不说，我和她妈的基因还是挺强大的，哈哈。（其实都是她妈带得好）</p><p>不过好久没能睡过懒觉了，另外抱娃哄睡这一技能也已经日益娴熟。所以前不久奖励了自己一个45千克的室内引体向上架，让（希望）自己臂力可以跟上娃日益上涨的体重。</p><p>现在耐心也好了许多（虽然有时还是容易急），渐渐开始适应奶爸这一角色。</p><p>偶尔生气时也懊恼为啥要生娃添堵，但过后看着娃的笑脸，觉得这一切都是值得的，一切都是最好的安排。</p><p>只要陪她一起快乐长大就好了。</p><h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><p>最后这一年的收益率跑赢了沪深300，虽对于翻倍的行情不是很完美，但至少跑赢了市场也学到一些去年做不到的东西。</p><p>用曾经看到的一句话作为投资的总结就是：</p><p>做投资一定要路子对，路子对的话，无非是三年成功还是五年成功。但如果路子不对，你永远不行。</p><p>感兴趣可以去看我的<a href="https://mp.weixin.qq.com/s/MJ3aujCNYjRYJ2x1SGBc8w" target="_blank" rel="noopener">2020投资回顾</a>，细节这里就不展开了</p><hr><p>2021，继续干就好了！</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉，2020年就过去了，是时候说一声再见了。&lt;/p&gt;
&lt;p&gt;2020对于我还是有比较多的新体验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="summary" scheme="http://blog.newbmiao.com/categories/summary/"/>
    
    
      <category term="summary" scheme="http://blog.newbmiao.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>Dig101-Go之深入理解mutex</title>
    <link href="http://blog.newbmiao.com/2020/07/01/dig101-golang-understanding-mutex.html"/>
    <id>http://blog.newbmiao.com/2020/07/01/dig101-golang-understanding-mutex.html</id>
    <published>2020-06-30T23:38:33.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><!-- **文章目录** --><!-- [TOC] --><p><code>sync.Mutex</code>是<code>Go</code>实现的互斥锁，提供了基本的同步操作，使用很方便。</p><p>不过，你是否好奇过，<code>Go</code>是如何实现的<code>Mutex</code>，又是为什么要这样实现？</p><p>今天跟随几个问题，我们一起探索下<code>Mutex</code>背后的设计。</p><p>（不用担心，不会有大段的源码分析出现在本文😳）</p><a id="more"></a><h2 id="0x01-为什么需要锁"><a href="#0x01-为什么需要锁" class="headerlink" title="0x01 为什么需要锁"></a>0x01 为什么需要锁</h2><p>锁当然是为了保证同步操作，或者应该这样问：没有锁的时候，为什么会有不同步？</p><p>这里导致不同步的原因主要有两点：</p><h3 id="非原子操作"><a href="#非原子操作" class="headerlink" title="非原子操作"></a>非原子操作</h3><p>如果一个线程的内存操作的<strong>中间状态</strong>（比如只完成一半），可以被<strong>另一个线程获取到</strong>，那么其操作就是非原子操作。</p><p>或者说其操作不是<strong>不可再分</strong>的。</p><p>比如自增操作<code>i++</code>, <code>i</code>的读取、修改、写入（<code>RMW</code>），其底层<strong>cpu和内存实际交互了两次</strong>，自然没法保证操作过程的原子性。</p><p><img src="http://media.newbmiao.com/dig101/go/self-incr.png" alt="自增操作"></p><p>那直接读取操作是否就能保证原子性呢？</p><p>也不一定，比如一般操作系统操作内存的最小粒度是一个机器字<code>machine word</code>(32位系统是<code>4B</code>,64位系统是<code>8B</code>)</p><p>内存对齐的情况下，在32位系统上读取一个<code>int64</code>(<code>8B</code>)就不可能是原子的，更别说如果内存是不对齐的了。</p><h3 id="内存重排"><a href="#内存重排" class="headerlink" title="内存重排"></a>内存重排</h3><p>我们写的代码顺序与实际执行的顺序可能并不一致。这是因为有内存重排的存在。他会发生在两个地方：</p><ul><li>语言编译时</li></ul><p>语言为了一些优化考虑，可能会在编译期间重排代码顺序。</p><ul><li>系统执行时</li></ul><p>这个完全取决于系统底层指令的实现，主要是为了更好利用那些原本要浪费掉的<strong>指令周期</strong>，提升程序的执行速度。</p><p>比如cpu和主存（<code>main memory</code>）访问延时是很高的。多核时代，每个cpu核为了加速访问，就增加了各自与主存交互的缓存(<code>cache</code>)。</p><p>如果缓存中有就无需再和主存交互了。如下图所示：</p><p><img src="http://media.newbmiao.com/dig101/go/cpu-cache-main-memory.png" alt="cpu的缓存与主存"></p><p>但有多份缓存，就需要有缓存一致（<code>cache coherency</code>）协议保证他们的结果一致。(具体可以了解<a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">MESI协议</a>)。</p><p>这种情况下，如果多个cpu核同时修改或读取同一份数据，且这份数据在各自的缓存中，为避免<strong>缓存间不一致</strong>，就不可避免有的cpu核要等待其他cpu核先操作数据。</p><p>所以在这些cpu核<strong>等待期间</strong>，他可以先执行其他内存指令。</p><blockquote><p>详细可以参考 <a href="https://www.internalpointers.com/post/understanding-memory-ordering" target="_blank" rel="noopener">Understanding memory reordering</a> 这篇文章。</p></blockquote><h2 id="0x02-mutex如何实现原子操作"><a href="#0x02-mutex如何实现原子操作" class="headerlink" title="0x02 mutex如何实现原子操作"></a>0x02 mutex如何实现原子操作</h2><p>利用<code>atomic</code>提供的<code>AddInt32</code>和<code>CompareAndSwapInt32</code>函数，其底层使用了系统架构提供的<code>LOCK</code>前缀指令。</p><p>该指令会设置处理器的<code>LOCK</code>信号。</p><p>这个信号会使总线锁定，阻止其他处理器接管总线访问内存，直到使用<code>LOCK</code>前缀指令执行结束，这会使这条指令的执行变为原子操作。</p><p>在多处理器环境下，设置<code>LOCK</code>信号能保证某个处理器对共享内存的独占使用。</p><p>具体指令参见：<code>runtime/internal/atomic/asm_amd64.s</code></p><p>如<code>Cas</code>的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bool Cas(int32 *val, int32 old, int32 new)</span></span><br><span class="line"><span class="comment">// Atomically:</span></span><br><span class="line"><span class="comment">//if(*val == old)&#123;</span></span><br><span class="line"><span class="comment">//*val = new;</span></span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="comment">//&#125; else</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$<span class="number">0</span><span class="number">-17</span></span><br><span class="line">MOVQptr+<span class="number">0</span>(FP), BX</span><br><span class="line">MOVLold+<span class="number">8</span>(FP), AX</span><br><span class="line">MOVL<span class="built_in">new</span>+<span class="number">12</span>(FP), CX</span><br><span class="line">LOCK</span><br><span class="line">CMPXCHGLCX, <span class="number">0</span>(BX)</span><br><span class="line">SETEQret+<span class="number">16</span>(FP)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><h2 id="0x03-mutex如何避免内存重排"><a href="#0x03-mutex如何避免内存重排" class="headerlink" title="0x03 mutex如何避免内存重排"></a>0x03 mutex如何避免内存重排</h2><p>上边提到的<code>LOCK</code>指令及<code>XCHG</code>等指令，会引入内存屏障（<code>memory barrier</code>）</p><p>内存屏障是强制处理器按照可预知的方式访问内存的CPU指令。</p><p>内存屏障的工作方式类似路障：内存屏障之前的指令保证先于内存屏障之后的指令执行。</p><blockquote><p>更多关于内存屏障可以看看这篇文章中对 <a href="https://my.oschina.net/chuqq/blog/3022854" target="_blank" rel="noopener">POSIX多线程程序设计-3.4节</a> 引用。</p></blockquote><h2 id="0x04-Go对mutex的优化点"><a href="#0x04-Go对mutex的优化点" class="headerlink" title="0x04 Go对mutex的优化点"></a>0x04 Go对mutex的优化点</h2><p>有了底层架构指令支持，如果<code>Go</code>直接基于<code>atomic.CAS</code>+cpu时钟周期阻塞，就可实现常见的自旋锁（<code>spinLock</code>）：</p><p>未获取锁前阻塞线程，每次等待一些cpu时钟周期，直到锁可用就好了。</p><p>但Go自己还是做了一些优化，一般情况下会优于常见的多线程互斥锁。</p><p>主要优化点是：</p><h3 id="不一直让cpu空转等待锁"><a href="#不一直让cpu空转等待锁" class="headerlink" title="不一直让cpu空转等待锁"></a>不一直让cpu空转等待锁</h3><p>一直自旋最大的问题就是浪费cpu时钟周期，会占用一些cpu，除非锁能很快获取到的。</p><p>所以Go在<strong>多核</strong>且<strong>不会影响其他<code>Goroutine</code>调度</strong>时，会最多自旋4次，且每次空转30个cpu时钟周期。以期能短期内获取锁。</p><p>详见<code>runtime_canSpin</code>和<code>runtime_doSpin</code> (源码见<code>runtime/proc.go</code>)</p><h3 id="用信号量实现睡眠的协程唤起"><a href="#用信号量实现睡眠的协程唤起" class="headerlink" title="用信号量实现睡眠的协程唤起"></a>用信号量实现睡眠的协程唤起</h3><p>上边说了不会一直空转cpu，那4次空转之后锁还没好，怎么办？</p><p>在多线程场景里一般就会基于信号量（<code>semaphore</code>）实现 <a href="https://zh.wikipedia.org/wiki/Futex" target="_blank" rel="noopener"><code>futex</code></a>，来让线程睡眠直至条件满足后唤醒。</p><p>Go也用信号量实现了类似<code>futex</code>的<code>wake</code>和<code>sleep</code>. 只不过他们管理的Go自己调度的<strong>协程</strong>而非线程。</p><p>这样好处是，让协程等待的代价要比线程更低，而且<strong>协程上下文切换</strong>也更快一些。</p><h3 id="避免过多无效的协程唤起"><a href="#避免过多无效的协程唤起" class="headerlink" title="避免过多无效的协程唤起"></a>避免过多无效的协程唤起</h3><p>如果一个锁有多个协程在抢，且已经有被挂起的协程在等待唤起。</p><p>这种情况下，当锁释放，等待被唤起的协程被唤醒时，他会和其他<strong>已经在cpu上运行的协程</strong>一起去抢锁，自然很容易失败而导致继续挂起。</p><p>为缓解这种极端情况的延迟。<code>Go</code>增加饥饿模式（<code>starvation mode</code>）：</p><p>正常情况按先进先出唤醒抢锁；如果有协程获取锁失败被挂起超过<strong>1ms</strong>，就将其放到队首，并转为饥饿模式。</p><p>这种模式下，下次唤醒就直接把锁<strong>交给</strong>（<code>handoff</code>）队首等待已久的协程。</p><p>了解这些，再去看<code>mutex</code>的源码可能会更好理解一些。</p><p>最后推荐一个talk，是英文版的，里边有很详细的关于<code>mutex</code>的讨论。</p><!-- ![Kavya Joshi - Let’s talk locks](https://www.bilibili.com/video/BV1kz411e7dL/) --><iframe src="//player.bilibili.com/player.html?aid=201155404&bvid=BV1kz411e7dL&cid=206127447&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><!-- ---文章首发公众号：newbmiao推荐阅读：[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      dig101-golang-understanding-mutex
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="mutex" scheme="http://blog.newbmiao.com/tags/mutex/"/>
    
      <category term="memory-reordering" scheme="http://blog.newbmiao.com/tags/memory-reordering/"/>
    
      <category term="atomic" scheme="http://blog.newbmiao.com/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>Go之如何操作结构体的非导出字段</title>
    <link href="http://blog.newbmiao.com/2020/06/13/dig101-golang-reflect-handle-unexport-field.html"/>
    <id>http://blog.newbmiao.com/2020/06/13/dig101-golang-reflect-handle-unexport-field.html</id>
    <published>2020-06-13T14:42:03.000Z</published>
    <updated>2023-06-18T00:52:29.950Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><p>我们都知道<code>Go</code>的<code>struct</code>里，小写字段是非导出的，即不可从包外部访问。</p><p>但非导出字段在外部也并不是没有办法访问，也不是不可以修改。</p><p>今天看下<code>reflect</code>包如何在包外操作非导出字段。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="取地址访问"><a href="#取地址访问" class="headerlink" title="取地址访问"></a>取地址访问</h2><p>先来看第一个函数<code>NewAt</code>：</p><p>对于结构体，通过其底层地址（指针p）和类型，返回指向该结构体的一个<strong>指针</strong>，</p><p>该值是可寻址的（<code>addressable</code>），即可<strong>访问</strong>该结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflect/value.go</span></span><br><span class="line"><span class="comment">// NewAt returns a Value representing a pointer to a value of the</span></span><br><span class="line"><span class="comment">// specified type, using p as that pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAt</span><span class="params">(typ Type, p unsafe.Pointer)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">  fl := flag(Ptr)</span><br><span class="line">  t := typ.(*rtype)</span><br><span class="line">  <span class="keyword">return</span> Value&#123;t.ptrTo(), p, fl&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个这个方法，就可以通过<code>struct</code>的反射获取非导出字段</p><p>比如访问，对于如下含有非导出字段的结构体<code>Example</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testData</span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line">  a <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便可以通过对结构体<code>eg</code>取地址的方式，获取其非导出字段<code>a</code>的内容</p><p>这里<code>Elem</code>是获取其底层数据对象的方式，</p><p>如果知道类型，也可显示指定调用，如<code>reflect.value.Interface,reflect.value.Int...</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eg testData.Example</span><br><span class="line">a:=GetStructPtrUnExportedField(&amp;eg, <span class="string">"a"</span>).String()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructPtrUnExportedField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取非导出字段反射对象</span></span><br><span class="line">  v := reflect.ValueOf(source).Elem().FieldByName(fieldName)</span><br><span class="line">  <span class="comment">// 构建指向该字段的可寻址（addressable）反射对象</span></span><br><span class="line">  <span class="keyword">return</span> reflect.NewAt(v.Type(), unsafe.Pointer(v.UnsafeAddr())).Elem()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意必须要对<code>eg</code><strong>取地址</strong>, 否则会<code>panic</code>:</p><p><code>panic: reflect: call of reflect.Value.Elem on struct Value</code></p><p>因为<code>reflect.Value.Elem</code>需要<code>reflect.Value</code>类型必须是<code>interface</code>或者<code>ptr</code>,</p><p>这样获取其<strong>底层的值</strong>才有意义：要么返回<code>interface</code>底层的值或者<code>ptr</code>指向的值</p><p>其注释如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Elem returns the value that the interface v contains</span></span><br><span class="line"><span class="comment">// or that the pointer v points to.</span></span><br><span class="line"><span class="comment">// It panics if v's Kind is not Interface or Ptr.</span></span><br><span class="line"><span class="comment">// It returns the zero Value if v is nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span> &#123;</span><br></pre></td></tr></table></figure><h2 id="取地址修改"><a href="#取地址修改" class="headerlink" title="取地址修改"></a>取地址修改</h2><p>那可以访问了，如何修改呢？</p><p>利用<code>reflect.value.Set</code>就可以：</p><p>上边<code>Elem</code>获取到的反射值是可修改的（<code>assignable</code>）,突破了非导出字段不能从外部修改的限制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eg testData.Example</span><br><span class="line">err := SetStructPtrUnExportedStrField(&amp;eg, <span class="string">"a"</span>, <span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetStructPtrUnExportedStrField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>, fieldVal <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  v := GetStructPtrUnExportedField(source, fieldName)</span><br><span class="line">  rv := reflect.ValueOf(fieldVal)</span><br><span class="line">  <span class="keyword">if</span> v.Kind() != rv.Kind() &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid kind: expected kind %v, got kind: %v"</span>, v.Kind(), rv.Kind())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改非导出字段值</span></span><br><span class="line">  v.Set(rv)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是以反射值来修改非导出字段值，内部类型须一致。修改后内容会直接反应到<code>eg</code>上</p><p>类似的还有指定类型的设置方法如<code>SetString,SetBool...</code></p><h2 id="非取地址访问"><a href="#非取地址访问" class="headerlink" title="非取地址访问"></a>非取地址访问</h2><p>当然不取地址也是可以访问非导出字段的。</p><p>这里用到的第二个函数是<code>New</code>:</p><p>基于指定类型创建一个可以表示该类型的<strong>指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns a Value representing a pointer to a new zero value</span></span><br><span class="line"><span class="comment">// for the specified type. That is, the returned Value's Type is PtrTo(typ).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(typ Type)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"reflect: New(nil)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  t := typ.(*rtype)</span><br><span class="line">  ptr := unsafe_New(t)</span><br><span class="line">  fl := flag(Ptr)</span><br><span class="line">  <span class="keyword">return</span> Value&#123;t.ptrTo(), ptr, fl&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体访问代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructUnExportedField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>)</span> <span class="params">(accessableField, addressableSourceCopy reflect.Value)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(source)</span><br><span class="line">  <span class="comment">// since source is not a ptr, get an addressable copy of source to modify it later</span></span><br><span class="line">    addressableSourceCopy = reflect.New(v.Type()).Elem()</span><br><span class="line">    <span class="comment">// make a copy of source</span></span><br><span class="line">  addressableSourceCopy.Set(v)</span><br><span class="line">  accessableField = addressableSourceCopy.FieldByName(fieldName)</span><br><span class="line">  accessableField = reflect.NewAt(accessableField.Type(), unsafe.Pointer(accessableField.UnsafeAddr())).Elem()</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样其实是内部构造了一个对该结构其取地址的指针，以满足后续调用<code>Elem</code>时可寻址!</p><h2 id="非取地址修改"><a href="#非取地址修改" class="headerlink" title="非取地址修改"></a>非取地址修改</h2><p>非取地址的方式访问没有问题，要还想修改就不会反应到原始结构体上了</p><p>毕竟是内部重新拷贝了一个结构体进行的操作。</p><p>具体操作类似取地址修改的方式，这里不赘述了。</p><p>实际使用中，还是通过<code>NewAt</code>获取可读写的非导出字段更方便一些。</p><blockquote><p>本文代码见 <a href="https://github.com/NewbMiao/Dig101-Go/blob/master/reflect" target="_blank" rel="noopener">NewbMiao/Dig101-Go</a></p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      dig101-golang-reflect-handle-unexport-field
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="reflect" scheme="http://blog.newbmiao.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>Dig101-Go之如何在函数内修改指针指向</title>
    <link href="http://blog.newbmiao.com/2020/05/22/how-to-modify-a-pointer-of-go-inside.html"/>
    <id>http://blog.newbmiao.com/2020/05/22/how-to-modify-a-pointer-of-go-inside.html</id>
    <published>2020-05-22T13:51:32.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><!-- **文章目录** --><!-- [TOC] --><p>今天来看一个小问题：<strong>如何在函数内部修改一个指针（参数或接收者）指向，使其值的改变能反映在函数外部</strong>？</p><p>直接上代码，这样可以么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArgType <span class="keyword">struct</span> &#123;</span><br><span class="line">  A <span class="keyword">string</span></span><br><span class="line">  b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg1</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  arg = &amp;ArgType&#123;<span class="string">"arg1"</span>, <span class="number">1</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg1:"</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>答案是【不可以】</p><p>等会分析，再看一个，这个呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg2</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  *arg = ArgType&#123;<span class="string">"arg2"</span>, <span class="number">2</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg2:"</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是【可以】</p><p>仔细看下，你应该就明白了。</p><p>第一个替换的是<strong>指针变量本身</strong>,</p><p>也就是在函数<code>modifyPointerArg1</code>的作用域内，其修改是有效</p><p>函数返回后，并不影响指针<code>arg</code>所指向的值（别忘了，Go参数传递是值传递嘛！）</p><p>至于<code>modifyPointerArg2</code>则是对指针解引用，修改了<strong>其指向的值</strong></p><hr><p>这样的方式其实还有很多，比如这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg3</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  val := reflect.ValueOf(arg)</span><br><span class="line">  val.Elem().FieldByName(<span class="string">"A"</span>).SetString(<span class="string">"arg3"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg3:"</span>, arg)</span><br><span class="line">  <span class="comment">// val.Elem().FieldByName("b").SetInt(3)</span></span><br><span class="line">  <span class="comment">// panic: reflect: reflect.flag.mustBeAssignable using value obtained using unexported field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际是利用反射的<code>Elem()</code>获取<code>val</code>的值</p><ul><li>如果其为空接口（<code>empty interface</code>），则获取其内部值（空接口值字段的类型是指针哦）</li><li>如果其为指针（<code>pointer</code>），则获取其指向的值</li></ul><p>获取到的结构如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    typ *rtype</span><br><span class="line">    <span class="comment">// 值指针</span></span><br><span class="line">    ptr unsafe.Pointer</span><br><span class="line">    <span class="comment">// 标志位</span></span><br><span class="line">  flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对应类型修改时, 实际就是对指针解引用修改其指向的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetString</span><span class="params">(x <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  v.mustBeAssignable()</span><br><span class="line">  v.mustBe(String)</span><br><span class="line">  <span class="comment">// 这里</span></span><br><span class="line">  *(*<span class="keyword">string</span>)(v.ptr) = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips： 这里注意一点，不导出的字段（结构体内小写的字段）不能用此类方法修改，会panic！</p></blockquote><p>再如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg4</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  jsonStr := <span class="string">`&#123;"A":"arg4","b":4&#125;`</span></span><br><span class="line">  json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部实际也是用了反射修改指针指向的值</p><p>另外，把上边几个测试函数由<strong>指针参数</strong>换为<strong>指针接受者</strong>，也是一样的</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ArgType)</span> <span class="title">modifyPointerReceiver4</span><span class="params">()</span></span> &#123;</span><br><span class="line">  jsonStr := <span class="string">`&#123;"A":"arg4","b":4&#125;`</span></span><br><span class="line">  json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣可以去自行尝试下其他几个函数。</p><p>说了这么多，这样修改有啥用么？</p><p>常见的一个场景便是：</p><p><strong>测试时，可以通过对接口实现对应的mock函数，改变参数或接收者，以达到排除依赖，进行单元测试的目的。</strong></p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://mp.weixin.qq.com/mp/homepage?__biz=MzUxNzA2NzEzNw==&hid=3&sn=6ded611e164ec49132752fdbdaac552f&scene=18#wechat_redirect)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      how-to-modify-a-pointer-inside-function
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="reflect" scheme="http://blog.newbmiao.com/tags/reflect/"/>
    
      <category term="dereference" scheme="http://blog.newbmiao.com/tags/dereference/"/>
    
  </entry>
  
  <entry>
    <title>记一次奇妙的go-protobuf包升级之旅</title>
    <link href="http://blog.newbmiao.com/2020/04/17/the-drama-of-updating-protobuf-go.html"/>
    <id>http://blog.newbmiao.com/2020/04/17/the-drama-of-updating-protobuf-go.html</id>
    <published>2020-04-17T14:58:00.000Z</published>
    <updated>2023-06-18T00:52:29.952Z</updated>
    
    <content type="html"><![CDATA[<p>今天聊一个最近升级go的<code>protobuf</code>的故事。过程很是奇妙（曲折）😳</p><!-- **文章目录** --><!-- [TOC] --><p>前两天，一个项目的<code>dependabot</code>提示包<code>github.com/golang/protobuf</code> 可以从<code>V1.3.5</code>升级到<code>V1.4.0</code></p><a id="more"></a><h2 id="Round-One"><a href="#Round-One" class="headerlink" title="Round One"></a>Round One</h2><p>本以为直接升级就行，但是没过CI，是发现旧版（<code>V1.3.5</code>）测试代码用了pb生成代码的<code>XXX_Size()</code>方法计算消息大小</p><p>在新版（<code>v1.4.0</code>）里<code>panic</code>了</p><p>我们来看下他们有啥不同：</p><p>为简化，我们proto文件用官方的<a href="https://github.com/grpc/grpc-go/blob/master/examples/helloworld/helloworld/helloworld.proto" target="_blank" rel="noopener">helloworld.proto</a></p><p>通过以下方式生成<code>V1.3.5</code>版本的pb文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/grpc/grpc-go/master/examples/helloworld/helloworld/helloworld.proto</span><br><span class="line">brew install protobuf</span><br><span class="line">GO111MODULE=on go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.5</span><br><span class="line">protoc  --go_out=plugins=grpc:. helloworld.proto</span><br></pre></td></tr></table></figure><p>再替换<code>github.com/golang/protobuf/protoc-gen-go@v1.4.0</code>，生成新版pb文件</p><p>查找<code>XXX_Size</code>函数</p><p>旧版中没问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helloword.pb.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *HelloRequest)</span> <span class="title">XXX_Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> xxx_messageInfo_HelloRequest.Size(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xxx_messageInfo_HelloRequest proto.InternalMessageInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// github.com/golang/protobuf@v1.3.5/proto/table_marshal.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *InternalMessageInfo)</span> <span class="title">Size</span><span class="params">(msg Message)</span> <span class="title">int</span></span> &#123;</span><br></pre></td></tr></table></figure><p>新版pb文件中没有了<code>InternalMessageInfo</code>类型</p><p>但源码中能找到，是被废弃了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// github.com/golang/protobuf@v1.4.0/proto/deprecated.go</span></span><br><span class="line"><span class="comment">// Deprecated: Do not use.</span></span><br><span class="line"><span class="keyword">type</span> InternalMessageInfo <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*InternalMessageInfo)</span> <span class="title">Size</span><span class="params">(Message)</span> <span class="title">int</span></span> &#123; <span class="built_in">panic</span>(<span class="string">"not implemented"</span>) &#125;</span><br><span class="line"><span class="comment">// 同样废弃的还有： DiscardUnknown, Marshal, Merge, Unmarshal</span></span><br></pre></td></tr></table></figure><p>那新版代码中怎么获取大小？</p><p>查看源码中例子，<code>proto.Size(m Message) int</code>可以实现</p><p><code>InternalMessageInfo</code>也变成了接口<code>type Message = protoiface.MessageV1</code></p><p>这个<code>InternalMessageInfo</code>的废弃在版本升级中也提到了，详见<a href="https://github.com/protocolbuffers/protobuf-go/releases/tag/v1.20.0#v1.20-generated-code" target="_blank" rel="noopener">generated-code</a></p><p>好，替换方法，第一回合结束</p><p><img src="http://media.newbmiao.com/emoji/finish.gif" alt="准备收工"></p><h2 id="Round-Two"><a href="#Round-Two" class="headerlink" title="Round Two"></a>Round Two</h2><p>等等，再仔细看了下<code>github.com/golang/protobuf</code>文档，里边提到<code>v1.4.0</code>版本后, 后边代码将交由<code>google.golang.org/protobuf</code> Repo维护，看来谷歌要把pb的包都收到自己组织下</p><p>那我顺手直接把<code>grpc</code>生成工具也替换过去呗！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on <span class="keyword">go</span> get -u google.golang.org/protobuf/cmd/protoc-gen-<span class="keyword">go</span>@v1<span class="number">.21</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>再次生成代码</p><blockquote><p>新工具自动提示要求proto文件中增加：</p><p><code>option go_package = &quot;.;helloworld&quot;;</code></p></blockquote><p>居然失败了。。。提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--go_out: protoc-gen-go: plugins are not supported; use 'protoc --go-grpc_out=...' to generate gRPC</span><br></pre></td></tr></table></figure><p>难道是新增了flag，尝试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc  --go-grpc_out=. helloworld.proto</span><br></pre></td></tr></table></figure><p>What? 失败+1。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc-gen-go-grpc: program not found or is not executable</span><br><span class="line">Please specify a program using absolute path or make sure the program is available in your PATH system variable</span><br><span class="line">--go-grpc_out: protoc-gen-go-grpc: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure><p><img src="http://media.newbmiao.com/emoji/block.jpg" alt="心塞x1"></p><p><code>protoc-gen-go-grpc</code>是新工具？</p><p>搜了下，确实有这个工具，说新版本会用他来生成<code>grpc</code>，主要是为了更好支持<code>protobuf reflection</code></p><blockquote><p>这里说一下:</p><p>proto文件中的<code>service</code>是需要<code>grpc</code>的<code>plugin</code>才能生成对应pb代码<br>所以旧版工具有参数<code>--go_out=plugins=grpc:</code></p></blockquote><p>尝试安装下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on go get google.golang.org/protobuf/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><p>失败+2。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get google.golang.org/protobuf/cmd/protoc-gen-go-grpc: module google.golang.org/protobuf@upgrade found (v1.21.0), but does not contain package google.golang.org/protobuf/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><p><img src="http://media.newbmiao.com/emoji/block.jpg" alt="心塞x2"></p><p>goDoc里有<a href="https://pkg.go.dev/google.golang.org/protobuf/cmd/protoc-gen-go-grpc?tab=overview" target="_blank" rel="noopener">protoc-gen-go-grpc</a>，<a href="https://github.com/protocolbuffers/protobuf-go" target="_blank" rel="noopener">Repo</a>里没有，这是什么操作？</p><p>猜测这问题应该有人遇到吧，果然搜到了issue：<a href="https://github.com/golang/protobuf/issues/1070#issuecomment-607465055" target="_blank" rel="noopener">plugins are not supported:grpc</a></p><p>原来是<code>google.golang.org/protobuf</code>先发布了,里边也包含了新版的<code>protoc-gen-go</code>，</p><p>只是其不再支持<code>grpc</code>生成，需要另一个工具<code>protoc-gen-go-grpc</code></p><p>然而它还没有发布，还在<a href="https://github.com/grpc/grpc-go/pull/3453" target="_blank" rel="noopener">Review</a>中。。。（当然目前也不会是稳定版本）</p><p><img src="http://media.newbmiao.com/emoji/unbelieve.jpg" alt="令人窒息的操作"></p><p>不过，官方也说了，依然可以用旧包<code>github.com/golang/protobuf</code>的<code>protoc-gen-go-grpc</code>工具生成<code>grpc</code>代码</p><blockquote><p>因为旧包<code>protoc-gen-go-grpc</code>里依然可以用新包<code>protoc-gen-go-grpc</code>里生成grpc代码的<code>gengogrpc</code>, 见<a href="https://github.com/grpc/grpc-go/pull/3453#issuecomment-600879894" target="_blank" rel="noopener">comment</a></p></blockquote><h2 id="Round-Three"><a href="#Round-Three" class="headerlink" title="Round Three"></a>Round Three</h2><p>好吧，那就只升级代码中调用的protobuf为<code>google.golang.org/protobuf@v1.21.0</code>，代码生成工具还用旧版里<code>github.com/golang/protobuf/protoc-gen-go@v1.4.0</code>吧</p><p>再次生成pb文件, 终于没有问题了, peace finally</p><p><img src="http://media.newbmiao.com/emoji/peace.jpg" alt="peace"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proto <span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">grpc <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">codes <span class="string">"google.golang.org/grpc/codes"</span></span><br><span class="line">status <span class="string">"google.golang.org/grpc/status"</span></span><br><span class="line">protoreflect <span class="string">"google.golang.org/protobuf/reflect/protoreflect"</span></span><br><span class="line">protoimpl <span class="string">"google.golang.org/protobuf/runtime/protoimpl"</span></span><br></pre></td></tr></table></figure><p>只是看着生成代码里的依然需要<code>import</code>的旧包<code>github.com/golang/protobuf</code>，总感觉哪里怪怪的</p><p>升级完了，却依赖了两种<code>protobuf</code>包。。。</p><p>最后，劝大家不着急就再等等再升级吧</p><p>（另外没事干升级到新包干什么！）</p><p>当然这次protobuf的breaking change还是很有意义的，不仅让将protobuf反射作为pb的一级功能，还提供了很多处理工具，详细看下: <a href="https://github.com/protocolbuffers/protobuf-go/releases/tag/v1.21.0" target="_blank" rel="noopener">v1.21.0-release</a></p><!-- ---文章首发公众号：newbmiao推荐阅读：[Dig101-Go系列](http://mp.weixin.qq.com/mp/homepage?__biz=MzUxNzA2NzEzNw==&hid=3&sn=6ded611e164ec49132752fdbdaac552f&scene=18#wechat_redirect)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      记一次奇妙的go-protobuf包升级之旅
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="protobuf" scheme="http://blog.newbmiao.com/tags/protobuf/"/>
    
      <category term="protoc-gen-go" scheme="http://blog.newbmiao.com/tags/protoc-gen-go/"/>
    
      <category term="protoc-gen-go-grpc" scheme="http://blog.newbmiao.com/tags/protoc-gen-go-grpc/"/>
    
  </entry>
  
  <entry>
    <title>OPA进阶-分布式利器Bundle</title>
    <link href="http://blog.newbmiao.com/2020/04/16/opa-bundle.html"/>
    <id>http://blog.newbmiao.com/2020/04/16/opa-bundle.html</id>
    <published>2020-04-16T11:57:40.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<p><code>Bundle</code>是<code>OPA</code>管理<code>policy</code>和<code>data</code>的一种方式。</p><p><code>OPA</code>实现的轻量级策略引擎，一开始就是为了云原生环境的<code>service</code>提供解耦的策略服务，分布式是必然要考虑的问题。</p><p>在<code>Bundle api</code>的设计中，其实就全面考虑并体现了在分布式应用中如何更好的解耦策略引擎的管理。</p><p>比如：</p><ul><li>如何做集中配置管理</li><li>如何动态更新策略</li><li>如何监控策略引擎节点的状态以及决策日志收集</li></ul><p>有了这些功能，再加上其高效的策略描述语言<code>Rego</code>，<code>OPA</code>才真正称得上是<strong>云原生时代的通用策略引擎</strong>。</p><p>本文将带大家简单梳理一遍<code>Bundle</code>的组织方式、管理api、及监控方式。</p><p>考虑到一次性过完不易消化，文末会提供一个直接可实操的<code>docker-compose</code>版本的<code>demo</code>，将全面覆盖本文细节</p><p>建议大家看完本文，本机运行去体验一下，会有更直观的理解。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="Bundle-文件组织方式"><a href="#Bundle-文件组织方式" class="headerlink" title="Bundle 文件组织方式"></a>Bundle 文件组织方式</h2><p>下面我们先来看下<code>Bundle</code>的文件组织方式</p><p>在<code>Bundle</code>下的<code>data</code>,只能被识别<code>data.json</code>和<code>data.yaml</code>的文件, 而其上边的目录会作为其数据前缀</p><p>如下边<code>roles/data.json</code> (<code>bundle/example</code>作为一个<code>bundle</code>)，会将<code>data.json</code>的数据挂在<code>data.roles</code>节点下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd bundle/example</span><br><span class="line">tree -a</span><br><span class="line">.</span><br><span class="line">├── .manifest</span><br><span class="line">├── bindings</span><br><span class="line">│   └── data.json</span><br><span class="line">├── main.rego</span><br><span class="line">├── rbac.rego</span><br><span class="line">└── roles</span><br><span class="line">    └── data.json</span><br></pre></td></tr></table></figure><p>其中<code>.manifest</code>文件是<code>Bundle</code>的一个可选的元数据（<code>metadata</code>）配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat .manifest</span><br><span class="line">&#123;</span><br><span class="line">  "revision" : "9f160bcd446bf50b1b17b570c322198a68d8e106",</span><br><span class="line">  "roots": ["roles", "bindings","rbac","system"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是声明<code>Bundle</code>的版本<code>revision</code>及其下的路径前缀（<code>roots: path prefix</code>）</p><p><code>roots</code>不仅规定了<code>Bundle</code>应该有的路径前缀；在用<code>Bundle api</code>（后边会提到）更新文件时，也会按其规定的路径前缀来更新文件</p><p>然后<code>bundle</code>也支持<code>tarball</code>格式加载到<code>server</code></p><p>例如<code>opa run -b</code>的方式指定<code>Bundle</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd bundle/example</span><br><span class="line">tar -czf bundle.tar.gz .</span><br><span class="line">opa run -b bundle.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 关于如何在交互式命令行里传递<code>input</code>。<br>之前非bundle使用<br><code>opa run  quick-start  repl.input:quick-start/input.json</code><br>到bundle格式时，就需要构建 <strong><code>repl/input/data.json</code></strong> 文件格式作为输入</p></blockquote><p>具体可以用时参考文档<a href="https://www.openpolicyagent.org/docs/latest/management/#bundle-file-format" target="_blank" rel="noopener">bundle-file-format</a></p><h2 id="opa-server-api"><a href="#opa-server-api" class="headerlink" title="opa server api"></a>opa server api</h2><p>在了解<code>Bundle</code>支持的管理api前，我们先看下<a href="https://www.openpolicyagent.org/docs/latest/rest-api/" target="_blank" rel="noopener">opa server api</a></p><p>主要api如下：</p><table><thead><tr><th>type</th><th>用途</th></tr></thead><tbody><tr><td>Data api</td><td>查询文档（能被输出的规则、虚拟文档等）</td></tr><tr><td>Policy api</td><td>查询策略</td></tr><tr><td>Query api</td><td>执行命令</td></tr><tr><td>Compile api</td><td>执行部分查询计算（<code>partial evaluate query</code>）</td></tr><tr><td>Health api</td><td>健康检查</td></tr><tr><td>Metric api</td><td>指标统计（<code>prometheus</code>格式)</td></tr></tbody></table><p>下面我们以文档查询（<code>Data</code>）api为例尝试下：</p><p>我们先用之前<code>quick-start</code>的代码起一个<code>opa sever</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opa run --server quick-start</span><br></pre></td></tr></table></figure><p>(注意：<code>opa server api</code>的路径前缀为<code>/v1/</code>, 对应的，查询api路径前缀为<code>/v1/data/</code>,)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构造input输出请求</span></span><br><span class="line">cat &lt;&lt;EOF &gt; v1-data-input.json</span><br><span class="line">&#123;</span><br><span class="line">    "input": $(cat quick-start/input.json)</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询 example_rbac</span></span><br><span class="line">curl -s  http://0.0.0.0:8181/v1/data/example_rbac?pretty=true -d @v1-data-input.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "result": &#123;</span><br><span class="line">    "allow": true,</span><br><span class="line">    "role_has_permission": [</span><br><span class="line">      "widget-reader"</span><br><span class="line">    ],</span><br><span class="line">    "user_has_role": [</span><br><span class="line">      "widget-reader"</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips：不指定路径时，默认路径为<code>data.system.main</code>，这时输入不需要包裹在<code>input</code> key内。<br>也可以使用<code>--set</code> 和 <code>--set-file</code> 可以覆盖配置文件中的配置<br><code>opa run --server --set=default_decision=example_rbac/allow/  quick-start</code><br><code>curl -s  http://0.0.0.0:8181/ -d @quick-start/input.json</code></p></blockquote><p>而且Data查询也支持组合参数如<code>explain</code>,<code>metrics</code>,<code>provenance</code>等，详细查看文档，这里就不展开了。</p><h2 id="Bundle-管理api"><a href="#Bundle-管理api" class="headerlink" title="Bundle 管理api"></a>Bundle 管理api</h2><p><code>Bundle</code>为了在分布式系统中更好的展现OPA的威力，提供了四种Api：</p><ul><li>Bundles<br>用于策略分发，可以定时轮训更新<code>Bundle</code>包</li><li>Decision Logs<br>定期上传日志包，支持按大小分片，开启后会有日志id，决策日志可追溯</li><li>Status<br>定期上传服务状态，包含<code>metrics</code>等信息</li><li>Discovery<br>服务发现，可以用于集中管理<code>OPA</code>的<code>Bundle</code>配置，各个节点下载定期同步配置后，按配置去更新<code>Bundle</code></li></ul><p>如下图：</p><p><img src="http://media.newbmiao.com/opa/bundle.png" alt="management api"></p><p>这里举个带注释<code>Bundle</code>的四种接口配置例子</p><p>（先扫一遍留个印象，具体使用时查看文档，后边会提供可实操的代码）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># opa/config-bundle.yaml</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 定义服务，支持多个</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example_bundle</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://demo-server:8888/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bundles:</span></span><br><span class="line">  <span class="comment"># 定义bundle, 支持多个</span></span><br><span class="line">  <span class="attr">authz:</span></span><br><span class="line">    <span class="comment"># bundle所处的服务</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">example_bundle</span></span><br><span class="line">    <span class="comment"># 这里指从resource处更新bundle文件包，即：</span></span><br><span class="line">    <span class="comment"># http://demo-server:8888/bundle/rbac.tar.gz</span></span><br><span class="line">    <span class="attr">resource:</span> <span class="string">bundle/rbac.tar.gz</span></span><br><span class="line">    <span class="attr">polling:</span></span><br><span class="line">      <span class="comment"># 300~600s间更新一次</span></span><br><span class="line">      <span class="attr">min_delay_seconds:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">max_delay_seconds:</span> <span class="number">600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">decision_logs:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">example_bundle</span></span><br><span class="line">  <span class="comment"># partition_name为区分上传地址,会跟到 /logs 后, 即：</span></span><br><span class="line">  <span class="comment"># http://demo-server:8888/logs/bundle</span></span><br><span class="line">  <span class="comment"># 注意上传的是gzip日志文件</span></span><br><span class="line">  <span class="attr">partition_name:</span> <span class="string">bundle</span></span><br><span class="line">  <span class="attr">reporting:</span></span><br><span class="line">    <span class="attr">min_delay_seconds:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">max_delay_seconds:</span> <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">example_bundle</span></span><br><span class="line">  <span class="comment"># 即 http://demo-server:8888/status/bundle</span></span><br><span class="line">  <span class="attr">partition_name:</span> <span class="string">bundle</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认查询路径</span></span><br><span class="line"><span class="attr">default_decision:</span> <span class="string">rbac/allow</span></span><br></pre></td></tr></table></figure><h2 id="Bundle-集成方式"><a href="#Bundle-集成方式" class="headerlink" title="Bundle 集成方式"></a>Bundle 集成方式</h2><p>这里我们简单过下集成方式</p><h3 id="opa-server-方式"><a href="#opa-server-方式" class="headerlink" title="opa server 方式"></a>opa server 方式</h3><p>运行方式很简单如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opa run -s -a 0.0.0.0:8181 -c opa/config-bundle.yaml</span><br></pre></td></tr></table></figure><p>运行后，opa server会根据配置自动拉取<code>Bundle</code>包：<code>rbac.tar.gz</code></p><p>下载成功后启动策略服务。同时定期上传决策日志和状态给服务端（即：<code>demo-server:8888</code>）</p><h3 id="go-lib-方式"><a href="#go-lib-方式" class="headerlink" title="go lib 方式"></a>go lib 方式</h3><p>使用lib <code>github.com/open-policy-agent/opa/rego</code>集成</p><p>关键代码举例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建查询，PrepareForEval可重用</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">query, err := rego.New(</span><br><span class="line">    rego.LoadBundle(<span class="string">"./rbac.tar.gz"</span>),</span><br><span class="line">    rego.Query(<span class="string">"x = data.rbac.allow"</span>),</span><br><span class="line">).PrepareForEval(context.Background())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">results, err := query.Eval(context.Background(), rego.EvalInput(input))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fatalln(<span class="string">"Opa eval error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(results) == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Fatalln(<span class="string">"Opa eval error: no result"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Opa result:"</span>, results[<span class="number">0</span>].Expressions[<span class="number">0</span>].Value)</span><br></pre></td></tr></table></figure><p>具体组织方式官方推荐的有下边<strong>集中式</strong>和<strong>分布式</strong>这两种：</p><p><img src="http://media.newbmiao.com/opa/host-local.png" alt="host-local"></p><p><img src="http://media.newbmiao.com/opa/distributed-enforcement.png" alt="distributed-enforcement"></p><p>推荐感兴趣的同学再去看下官方go集成的demo: <a href="https://github.com/open-policy-agent/example-api-authz-go" target="_blank" rel="noopener">example-api-authz-go</a></p><h2 id="Bundle-的监控"><a href="#Bundle-的监控" class="headerlink" title="Bundle 的监控"></a>Bundle 的监控</h2><p>opa server 支持<code>metrics</code>, 而且是<code>prometheus</code>格式的</p><p>所以配合<code>prometheus</code>可以直接进行对其数据指标的监控，如下图：</p><p><img src="http://media.newbmiao.com/opa/prometheus.png" alt="prometheus"></p><p>再配合<code>grafana</code>的<code>dashbord</code>可以更好的展示<code>metrics</code>数据，如下图：</p><p><img src="http://media.newbmiao.com/opa/grafana.png" alt="grafana"></p><h2 id="Bundle-in-action"><a href="#Bundle-in-action" class="headerlink" title="Bundle in action"></a>Bundle in action</h2><p>上边说这么多，不实际试一下怎么知道<code>Bundle</code>究竟如何呢？</p><p>这里提供一个<code>docker-compose</code>版的demo给大家去本地验证尝试</p><p>里边提供了三种<code>Bundle</code>版本：</p><ul><li>opa-bundle</li><li>opa-discovery</li><li>demo-sever (go lib集成)</li></ul><p>也提供了两种版本的<code>monitor</code></p><ul><li>slim version</li><li>advance version</li></ul><p>代码见：<a href="https://github.com/NewbMiao/opa-koans/tree/master/bundle" target="_blank" rel="noopener">NewbMiao/opa-koans/bundle</a></p><p>里边有详细的操作文档，有问题可以在Repo里提issue</p><p>这个Repo包含了这一系列的<code>OPA</code>教程，欢迎感兴趣的同学 <strong><code>star</code></strong> 关注！</p><p>同时我在知乎也建了一个<a href="https://www.zhihu.com/club/1225433566832132096" target="_blank" rel="noopener">OPA技术圈</a>，也欢迎大家参与讨论。</p><p>好了，到此，<code>OPA</code>的基本教程就结束了。后边再抽空结合官方的例子写些实战教程吧。</p><hr><p>最后附上一个Repo中验证Bundle的过程，大家也可以从这里开始尝试哦</p><p><img src="http://media.newbmiao.com/opa/bundleVerify.gif" alt="scripts/bundleVerify.sh"></p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://mp.weixin.qq.com/mp/homepage?__biz=MzUxNzA2NzEzNw==&hid=3&sn=6ded611e164ec49132752fdbdaac552f&scene=18#wechat_redirect)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      OPA进阶-分布式利器Bundle
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="bundle" scheme="http://blog.newbmiao.com/tags/bundle/"/>
    
  </entry>
  
  <entry>
    <title>OPA进阶-测试、性能分析和基准测试</title>
    <link href="http://blog.newbmiao.com/2020/04/05/opa-test-profile-and-benchmark.html"/>
    <id>http://blog.newbmiao.com/2020/04/05/opa-test-profile-and-benchmark.html</id>
    <published>2020-04-05T09:48:30.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>本文来讲讲<code>OPA</code>的测试（<code>test</code>）、性能分析（<code>profile</code>）和（<code>benchmark</code>）</p><p>掌握他们，对于保证策略代码的质量和决策效率有很大的帮助</p><a id="more"></a><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p><code>OPA</code>的测试很简单。</p><p>所有<code>test_</code>前缀的的规则（<code>rule</code>）都是测试。</p><blockquote><p>Tips: 虽然是测试，但其本质上其仍是规则，仍然可以被查询。<br>另外建议文件名遵循<code>_test.rego</code>后缀加以区分</p></blockquote><p>这里拿<code>quick-start</code>的测试例子来看下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example_rbac_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> data.example_rbac</span><br><span class="line"></span><br><span class="line">test_not_allow &#123;</span><br><span class="line">    not example_rbac.allow with input as &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_allow &#123;</span><br><span class="line">  example_rbac.allow with input as &#123;</span><br><span class="line">    <span class="string">"action"</span>: &#123;</span><br><span class="line">      <span class="string">"operation"</span>: <span class="string">"read"</span>,</span><br><span class="line">      <span class="string">"resource"</span>: <span class="string">"widgets"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"subject"</span>: &#123;<span class="string">"user"</span>: <span class="string">"inspector-alice"</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样即覆盖了<code>allow</code>规则的全部测试用例。</p><p>注意这里<code>with</code>起到了数据模拟的作用（<code>data mocking</code>）</p><blockquote><p>Tips: 函数不可用<code>with</code>替换</p></blockquote><p>对应的命令行是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd quick-start</span><br><span class="line">opa test . -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下</span></span><br><span class="line">data.example_rbac_test.test_not_allow: PASS (693.201µs)</span><br><span class="line">data.example_rbac_test.test_allow: PASS (562.02µs)</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">PASS: 2/2</span><br></pre></td></tr></table></figure><p>也可以查看测试覆盖率：</p><p><code>opa test . -c</code></p><p>设定测试覆盖率标准：</p><p><code>opa test . -c --threshold 100</code></p><p>（这里提示下别忘了<code>vscode-opa</code>支持可视化覆盖率展示哦）</p><p>也支持选择测试用例执行：</p><p><code>opa test -r test_allow . -v</code></p><h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cd quick-start</span><br><span class="line">opa eval --profile -d example.rego -d data.json -i input.json -f pretty <span class="string">"data.example_rbac.allow"</span>  </span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">+------------------------------+---------+</span><br><span class="line">|            METRIC            |  VALUE  |</span><br><span class="line">+------------------------------+---------+</span><br><span class="line">| timer_rego_data_parse_ns     | <span class="number">18332</span>   |</span><br><span class="line">| timer_rego_load_files_ns     | <span class="number">5506307</span> |</span><br><span class="line">| timer_rego_module_compile_ns | <span class="number">573408</span>  |</span><br><span class="line">| timer_rego_module_parse_ns   | <span class="number">5226456</span> |</span><br><span class="line">| timer_rego_query_compile_ns  | <span class="number">87390</span>   |</span><br><span class="line">| timer_rego_query_eval_ns     | <span class="number">292198</span>  |</span><br><span class="line">| timer_rego_query_parse_ns    | <span class="number">277932</span>  |</span><br><span class="line">+------------------------------+---------+</span><br><span class="line">+----------+----------+----------+-------------------------+</span><br><span class="line">|   TIME   | NUM EVAL | NUM REDO |        LOCATION         |</span><br><span class="line">+----------+----------+----------+-------------------------+</span><br><span class="line">| <span class="number">54.121</span>µs | <span class="number">1</span>        | <span class="number">1</span>        | data.example_rbac.allow |</span><br><span class="line">| <span class="number">42.776</span>µs | <span class="number">1</span>        | <span class="number">2</span>        | example.rego:<span class="number">15</span>         |</span><br><span class="line">| <span class="number">37.861</span>µs | <span class="number">1</span>        | <span class="number">1</span>        | example.rego:<span class="number">9</span>          |</span><br><span class="line">| <span class="number">35.81</span>µs  | <span class="number">1</span>        | <span class="number">1</span>        | example.rego:<span class="number">25</span>         |</span><br><span class="line">| <span class="number">22.469</span>µs | <span class="number">1</span>        | <span class="number">1</span>        | example.rego:<span class="number">10</span>         |</span><br><span class="line">| <span class="number">21.353</span>µs | <span class="number">2</span>        | <span class="number">2</span>        | example.rego:<span class="number">16</span>         |</span><br><span class="line">| <span class="number">16.888</span>µs | <span class="number">2</span>        | <span class="number">1</span>        | example.rego:<span class="number">17</span>         |</span><br><span class="line">| <span class="number">15.923</span>µs | <span class="number">2</span>        | <span class="number">1</span>        | example.rego:<span class="number">23</span>         |</span><br><span class="line">| <span class="number">14.736</span>µs | <span class="number">1</span>        | <span class="number">2</span>        | example.rego:<span class="number">22</span>         |</span><br><span class="line">| <span class="number">8.798</span>µs  | <span class="number">1</span>        | <span class="number">1</span>        | example.rego:<span class="number">24</span>         |</span><br><span class="line">+----------+----------+----------+-------------------------+</span><br></pre></td></tr></table></figure><blockquote><p>Tips: –profile还支持结果排序和限制显示条数</p><ul><li><code>--profile-sort</code>：对性能分析结果排序，默认按<code>total_time_ns =&gt; num_eval =&gt; num_redo =&gt; file =&gt; line</code>排序, 详见<a href="https://www.openpolicyagent.org/docs/latest/policy-performance/#sort-criteria-for-the-profile-results" target="_blank" rel="noopener">profile-sort文档</a></li><li><code>--profile-limit</code>：显示几条分析结果，默认10条</li></ul></blockquote><h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><p><code>opa</code> 也支持<code>benchmark</code>，基本实现了<code>go</code>的<code>benchmark</code>的使用方式, 甚至有更详细的结果（毕竟一直标榜性能么）</p><p>默认<code>benchmark</code>会展示内存（<code>--benchmem</code>）和查询(<code>--metrics</code>)的基准测试结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ opa bench --count <span class="number">1</span> -d example.rego -d data.json -i input.json -f pretty <span class="string">"data.example_rbac.allow"</span></span><br><span class="line">+-------------------------------------------+------------+</span><br><span class="line">| samples                                   |      <span class="number">14162</span> |</span><br><span class="line">| ns/op                                     |      <span class="number">93655</span> |</span><br><span class="line">| B/op                                      |      <span class="number">15117</span> |</span><br><span class="line">| allocs/op                                 |        <span class="number">311</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_75%    |      <span class="number">89900</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_90%    |     <span class="number">112253</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_95%    |     <span class="number">125465</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_99%    |     <span class="number">222404</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_99<span class="number">.9</span>%  |     <span class="number">549291</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_99<span class="number">.99</span>% |     <span class="number">550611</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_count  |      <span class="number">14162</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_max    |     <span class="number">550611</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_mean   |      <span class="number">76735</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_median |      <span class="number">68336</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_min    |      <span class="number">38896</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_stddev |      <span class="number">38828</span> |</span><br><span class="line">+-------------------------------------------+------------+</span><br></pre></td></tr></table></figure><p>当然也集成到了<code>opa test</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ opa test -v --bench  example.rego example_test.rego data.json </span><br><span class="line">data.example_rbac_test.test_not_allow      <span class="number">15139</span>             <span class="number">74172</span> ns/op             <span class="number">62044</span> timer_rego_query_eval_ns/op     <span class="number">14666</span> B/op     <span class="number">270</span> allocs/op</span><br><span class="line">data.example_rbac_test.test_allow          <span class="number">10000</span>            <span class="number">102658</span> ns/op             <span class="number">90779</span> timer_rego_query_eval_ns/op     <span class="number">17825</span> B/op     <span class="number">367</span> allocs/op</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">PASS: <span class="number">2</span>/<span class="number">2</span></span><br></pre></td></tr></table></figure><p>而且<code>--format</code>指定<code>gobench</code>的话，还支持了<a href="https://github.com/golang/perf" target="_blank" rel="noopener"><code>benchstat</code></a>, 是<code>Go</code>亲生的，无疑了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">opa test -v --bench --count <span class="number">5</span> --format gobench   example.rego example_test.rego data.json| tee b.txt</span><br><span class="line"></span><br><span class="line">BenchmarkDataExampleRbacTestTestNotAllow           <span class="number">15186</span>             <span class="number">87349</span> ns/op             <span class="number">73644</span> timer_rego_query_eval_ns/op     <span class="number">14663</span> B/op        <span class="number">270</span> allocs/op</span><br><span class="line">BenchmarkDataExampleRbacTestTestAllow      <span class="number">10000</span>            <span class="number">115857</span> ns/op            <span class="number">101565</span> timer_rego_query_eval_ns/op     <span class="number">17828</span> B/op        <span class="number">367</span> allocs/op</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">PASS: <span class="number">2</span>/<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">benchstat b.txt</span><br><span class="line"></span><br><span class="line">name                             time/op</span><br><span class="line">DataExampleRbacTestTestNotAllow                  <span class="number">92.9</span>µs ±<span class="number">40</span>%</span><br><span class="line">DataExampleRbacTestTestAllow                      <span class="number">123</span>µs ± <span class="number">8</span>%</span><br><span class="line"></span><br><span class="line">name                             timer_rego_query_eval_ns/op</span><br><span class="line">DataExampleRbacTestTestNotAllow                   <span class="number">79.0</span>k ±<span class="number">41</span>%</span><br><span class="line">DataExampleRbacTestTestAllow                       <span class="number">109</span>k ± <span class="number">9</span>%</span><br><span class="line"></span><br><span class="line">name                             alloc/op</span><br><span class="line">DataExampleRbacTestTestNotAllow                  <span class="number">14.7</span>kB ± <span class="number">0</span>%</span><br><span class="line">DataExampleRbacTestTestAllow                     <span class="number">17.8</span>kB ± <span class="number">0</span>%</span><br><span class="line"></span><br><span class="line">name                             allocs/op</span><br><span class="line">DataExampleRbacTestTestNotAllow                     <span class="number">270</span> ± <span class="number">0</span>%</span><br><span class="line">DataExampleRbacTestTestAllow                        <span class="number">367</span> ± <span class="number">0</span>%</span><br></pre></td></tr></table></figure><p>基准测试前后对比自然也是支持，如<code>benchstat old.txt new.txt</code>，就不详述了。</p><p>这些工具固然好，高性能还是需要follow一些经验法则的</p><p>这里引用官方对于性能优化的建议如下(<a href="https://www.openpolicyagent.org/docs/latest/policy-performance/#key-takeaways" target="_blank" rel="noopener">key-takeaways</a>)：</p><ul><li>编写策略（<code>policy</code>）要最大程度地减少迭代和搜索。<ul><li>使用的数组元素有唯一标识符时，改为唯一标识作为key的对象。</li><li>考虑利用部分评估（<a href="https://blog.openpolicyagent.org/partial-evaluation-162750eaf422" target="_blank" rel="noopener">partial-evaluation</a>）以将非线性策略编译为线性策略。</li></ul></li><li>利用规则索引优化（<a href="https://blog.openpolicyagent.org/optimizing-opa-rule-indexing-59f03f17caf3" target="_blank" rel="noopener">rule-indexing</a>）编写策略，以便规则索引有效。</li><li>使用探查器(<code>profiler</code>)可帮助确定策略的哪些部分将从提高的性能中受益最大。</li><li>使用基准测试工具（<code>benchmark tools</code>）来帮助获取真实世界的时序数据并检测策略性能变化。</li></ul><blockquote><p>里边提到的<code>partial-evaluation</code>和<code>rule-indexing</code>是保证<code>OPA</code>高性能的两个重要特性，感兴趣的同学可以自行查看下。</p></blockquote><p>下一篇，我们来谈谈<code>OPA</code>的一个重磅功能 - <code>bundle</code>, 一种将策略及数据进行包组织的方式，也支持丰富的管理<code>restful api</code>,适合分布式决策服务的构建。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      OPA进阶-测试、性能分析和基准测试
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="test" scheme="http://blog.newbmiao.com/tags/test/"/>
    
      <category term="profile" scheme="http://blog.newbmiao.com/tags/profile/"/>
    
      <category term="benchmark" scheme="http://blog.newbmiao.com/tags/benchmark/"/>
    
  </entry>
  
  <entry>
    <title>OPA进阶-简洁的推导式</title>
    <link href="http://blog.newbmiao.com/2020/03/20/opa-comprehensions.html"/>
    <id>http://blog.newbmiao.com/2020/03/20/opa-comprehensions.html</id>
    <published>2020-03-20T06:58:18.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>本文来讲讲<code>OPA</code>推导式（comprehensions），主要涉及三类数据的推导式：<code>object，array，set</code></p><p>我们将以实现判断配置文件数据的不同聚合方式为例展开。</p><a id="more"></a><p>用到的输入(配置文件列表)为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input.json</span></span><br><span class="line"><span class="comment">// posix为常见路径格式</span></span><br><span class="line"><span class="comment">// traditional-mac为mac的一种文件路径格式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"posix"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/Users/newbmiao/Documents/1.yaml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"posix"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/Users/newbmiao/Documents/2.yaml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"traditional-mac"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.yml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"traditional-mac"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.json"</span></span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="comprehensions"><a href="#comprehensions" class="headerlink" title="comprehensions"></a>comprehensions</h2><p>推导式（<code>comprehensions</code>）提供了一种从子查询构建复合值（<code>Composite Values</code>）的简洁方法。</p><p>定义很晦涩，我们从例子来看会清晰许多</p><h3 id="object-comprehensions"><a href="#object-comprehensions" class="headerlink" title="object comprehensions"></a>object comprehensions</h3><p>首先看一个按文件路径类型聚合文件的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> input.files</span><br><span class="line"></span><br><span class="line">group_files_by_type := &#123;<span class="keyword">type</span>: paths |</span><br><span class="line">  file := files[_]</span><br><span class="line">  <span class="keyword">type</span> := file.<span class="keyword">type</span></span><br><span class="line">  paths := [path |</span><br><span class="line">    tmp := files[_]</span><br><span class="line">    tmp.<span class="keyword">type</span> == <span class="keyword">type</span></span><br><span class="line">    path := tmp.path</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即两层遍历，外层遍历获取<code>type</code></p><p>内层遍历按<code>type</code>匹配推导出<code>paths</code>数组</p><p>对应结果为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">opa eval -f values -d . -i input.json <span class="string">"data.example_comprehensions.group_files_by_type"</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"posix"</span>: [</span><br><span class="line">      <span class="string">"/Users/newbmiao/Documents/1.yaml"</span>,</span><br><span class="line">      <span class="string">"/Users/newbmiao/Documents/2.yaml"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"traditional-mac"</span>: [</span><br><span class="line">      <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.yml"</span>,</span><br><span class="line">      <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.json"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>忽略实现细节，对象的推导式语法为：</p><p><code>{ &lt;key&gt;: &lt;term&gt; | &lt;body&gt; }</code></p><p>定义的<code>key</code>和<code>term</code>需要在<code>body</code>内赋值，最后会复合出一个对象，包含有所有满足的<code>&lt;key&gt;: &lt;term&gt;</code></p><p>这里要注意的事<code>body</code>内条件要都满足才会返回</p><h3 id="array-comprehensions"><a href="#array-comprehensions" class="headerlink" title="array comprehensions"></a>array comprehensions</h3><p>上边例子中<code>paths</code>是一个数组推导式</p><p>其语法为: <code>[ &lt;term&gt; | &lt;body&gt; ]</code></p><p>注意这里的<code>[]</code>， 只有数组推导式用方括号</p><p>而且其内容是<strong>可重复的</strong></p><p>对应再举一个将所有文件路径转为<code>posix</code>的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">convert_all_to_posix_path_array := [path |</span><br><span class="line">  path1 := [p |</span><br><span class="line">    file := files[_]</span><br><span class="line">    file.<span class="keyword">type</span> == <span class="string">"posix"</span></span><br><span class="line">    p := file.path</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  path2 := [p |</span><br><span class="line">    file := files[_]</span><br><span class="line">    file.<span class="keyword">type</span> == <span class="string">"traditional-mac"</span></span><br><span class="line">    p := replace(replace(file.path, <span class="string">"Macintosh HD"</span>, <span class="string">""</span>), <span class="string">":"</span>, <span class="string">"/"</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  paths := array.concat(path1, path2)</span><br><span class="line">  path = paths[_]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里按文件路径类型推导出<code>path1</code>和<code>path2</code>两个数组</p><p>其内部对于<code>file.type</code>的判断达到了过滤匹配的作用</p><h3 id="set-comprehensions"><a href="#set-comprehensions" class="headerlink" title="set comprehensions"></a>set comprehensions</h3><p>上边功能也可以用集合推导式实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">convert_all_to_posix_path_sets := &#123;path |</span><br><span class="line">  path1 := &#123;p |</span><br><span class="line">    file := files[_]</span><br><span class="line">    file.<span class="keyword">type</span> == <span class="string">"posix"</span></span><br><span class="line">    p := file.path</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  path2 := &#123;p |</span><br><span class="line">    file := files[_]</span><br><span class="line">    file.<span class="keyword">type</span> == <span class="string">"traditional-mac"</span></span><br><span class="line">    p := replace(replace(file.path, <span class="string">"Macintosh HD"</span>, <span class="string">""</span>), <span class="string">":"</span>, <span class="string">"/"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  paths := path1 | path2</span><br><span class="line">  path = paths[_]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合推导式语法为：</p><p><code>{ &lt;term&gt; | &lt;body&gt; }</code></p><p>其特点是<strong>不会重复</strong></p><p>可以看出同样功能，集合做组合操作比较表意</p><p>类似的，交集可以用<code>&amp;</code>,差集可以用<code>-</code></p><p>以上就是<code>OPA</code>三类推导式的使用方式。推导式最大的特点就是简洁。</p><p>一旦你熟悉了，就可以写出很多优雅的聚合方式。</p><p>最后出一个题目，大家可以自己练习下(答案可以去<code>opa-koans</code>中查看)</p><p>实现基于文件后缀聚合文件路径, 即输出为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"json"</span>: [</span><br><span class="line">    <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.json"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"yaml"</span>: [</span><br><span class="line">    <span class="string">"/Users/newbmiao/Documents/1.yaml"</span>,</span><br><span class="line">    <span class="string">"/Users/newbmiao/Documents/2.yaml"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"yml"</span>: [</span><br><span class="line">    <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.yml"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示, 对于文件后缀可以用如下两种方式获取</p><p>方式一： <code>hardcode</code></p><p><code>extSets := [&quot;yaml&quot;, &quot;yml&quot;, &quot;json&quot;]</code></p><p>方式二：<code>regex</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extSets := &#123;e |</span><br><span class="line">  e = regex.find_all_string_submatch_n(<span class="string">".*\\.(.*)$"</span>, files[_].path, <span class="number">-1</span>)[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文代码详见:<a href="https://github.com/NewbMiao/opa-koans/tree/master/syntax/comprehensions.rego" target="_blank" rel="noopener">NewbMiao/opa-koans</a></p></blockquote><p>下一篇，我们讲讲如何用<code>OPA</code>的测试和压测保证规则的正确性与效率。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      OPA进阶-简洁的推导式
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="comprehensions" scheme="http://blog.newbmiao.com/tags/comprehensions/"/>
    
  </entry>
  
  <entry>
    <title>OPA进阶-函数与虚拟文档要分清</title>
    <link href="http://blog.newbmiao.com/2020/03/18/opa-func-and-virtual-doc.html"/>
    <id>http://blog.newbmiao.com/2020/03/18/opa-func-and-virtual-doc.html</id>
    <published>2020-03-18T14:27:00.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>本文来讲讲<code>OPA</code>常用的函数（<code>function</code>）和虚拟文档（<code>virtual document</code>），以及他们使用的场景。</p><p>我们将以实现判断配置文件为例展开。</p><a id="more"></a><p>用到的输入(配置文件列表)为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input.json</span></span><br><span class="line"><span class="comment">// posix为常见路径格式</span></span><br><span class="line"><span class="comment">// traditional-mac为mac的一种文件路径格式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"posix"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/Users/newbmiao/Documents/1.yaml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"posix"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/Users/newbmiao/Documents/2.yaml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"traditional-mac"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.yml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"traditional-mac"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.json"</span></span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数基本每个语言都会有，要说<code>OPA</code>里有啥特别的地方，那就是他也实现同名函数，类似“函数重载”，但简化了许多。</p><p>他的特点是：</p><ul><li>默认函数返回值为 true/false</li><li>可以指定函数返回值</li><li>可以存在同名函数, 但参数数目不能变</li><li>相同输入（参数）必须获得相同输出（返回值）</li></ul><p>举例来说，如果实现判断文件是否是配置文件后缀：</p><p>下边<code>is_config_file</code>就是不指定返回值</p><p>条件满足则返回true，三个实现只要满足一个就为true</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">is_config_file(str) &#123;</span><br><span class="line">  contains(str, <span class="string">".yaml"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_config_file(str) &#123;</span><br><span class="line">  contains(str, <span class="string">".yml"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_config_file(str) &#123;</span><br><span class="line">  contains(str, <span class="string">".json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以使用<code>else</code>关键字合并到一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">is_config_file2(str) &#123;</span><br><span class="line">  contains(str, <span class="string">".yaml"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  contains(str, <span class="string">".yml"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  contains(str, <span class="string">".json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果指定返回值怎么重载呢？</p><p>以实现不同路径格式的文件名为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getFileName(<span class="keyword">type</span>, str) = x &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">"posix"</span></span><br><span class="line">  str = trim(str)</span><br><span class="line">  tmp := split(str, <span class="string">"/"</span>)</span><br><span class="line">  x := tmp[minus(count(tmp), <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileName(<span class="keyword">type</span>, str) = x &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">"traditional-mac"</span></span><br><span class="line">  str = trim(str)</span><br><span class="line">  tmp := split(str, <span class="string">":"</span>)</span><br><span class="line">  x := tmp[minus(count(tmp), <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现两个函数输入和返回不是相同的么？</p><p>其实不是，仔细看他们内都做了 <code>type = {&quot;traditional-mac&quot;|&quot;posix&quot;}</code> 的判断</p><p>这实际类似函数声明为 <code>getFileName(&quot;posix&quot;, str) = x {}</code>, 所以输入是不同的</p><p>如果你省略了<code>type</code>的判断，会报错的：</p><p><code>eval_conflict_error: functions must not produce multiple outputs for same inputs</code></p><p>到此，将函数组合一下就可以实现判定是否为配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> input.files</span><br><span class="line"></span><br><span class="line">is_config &#123;</span><br><span class="line">  file := files[_]</span><br><span class="line">  x := getFileName(file.<span class="keyword">type</span>, file.path)</span><br><span class="line">  is_config_file(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 关于<code>OPA</code>的内置函数可以查看文档:<a href="https://www.openpolicyagent.org/docs/latest/policy-reference/#built-in-functions" target="_blank" rel="noopener">built-in-functions</a></p></blockquote><h2 id="虚拟文档"><a href="#虚拟文档" class="headerlink" title="虚拟文档"></a>虚拟文档</h2><p>虚拟文档是生成的文档（或者称为<strong>集合</strong>）</p><p>他的特点是：</p><ul><li>作为集合，输入和输出必须是有限的</li><li>可以遍历</li><li>可以查询</li></ul><p>举例来说，同样是获取文件名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> input.files</span><br><span class="line"></span><br><span class="line">getFileNames[x] &#123;</span><br><span class="line">  file := files[_]</span><br><span class="line">  file.<span class="keyword">type</span> = <span class="string">"posix"</span></span><br><span class="line">  file.path = trim(file.path)</span><br><span class="line">  tmp := split(file.path, <span class="string">"/"</span>)</span><br><span class="line">  x := tmp[minus(count(tmp), <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileNames[x] &#123;</span><br><span class="line">  file := files[_]</span><br><span class="line">  file.<span class="keyword">type</span> = <span class="string">"traditional-mac"</span></span><br><span class="line">  file.path = trim(file.path)</span><br><span class="line">  tmp := split(file.path, <span class="string">":"</span>)</span><br><span class="line">  x := tmp[minus(count(tmp), <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>getFileNames[x] {}</code> 等价于 <code>getFileNames[x] = x {}</code></p><p>就是<code>x</code>作为了集合的一个结果，填充到<code>getFileNames</code>这个虚拟文档中，其<code>key</code>也是<code>x</code>的值。</p><p>有点抽象是不？</p><p>别怕，他可以查询，我们查询看下他的结果就好理解了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd syntax</span><br><span class="line">opa eval -f values -i input.json -d . <span class="string">"data.example_virtual_doc.getFileNames"</span></span><br><span class="line">[</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"1.yaml"</span>,</span><br><span class="line">    <span class="string">"2.yaml"</span>,</span><br><span class="line">    <span class="string">"3.yml"</span>,</span><br><span class="line">    <span class="string">"3.json"</span></span><br><span class="line">  ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后<strong>遍历</strong>虚拟文档，结合判定<code>is_config_file</code>就可实现判定：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> data.example_func.is_config_file</span><br><span class="line"><span class="keyword">import</span> input.files</span><br><span class="line"></span><br><span class="line">is_config &#123;</span><br><span class="line">  is_config_file(getFileNames[_])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里遍历<code>getFileNames[_]</code>,随即作为每一个输入参数传给<code>is_config_file</code>进行判断，是不是很方便！</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>具体到他们的适用场景，其实比较好区分，重点只要关注两点：</p><ul><li>是否需要<strong>遍历</strong>？</li><li>输入输出是否是<strong>有限</strong>的？</li></ul><p>如果有一个答案是肯定的，那么虚拟文档就更适合。</p><p><code>OPA</code>的函数和虚拟文档很简单、很清秀是不是？</p><p>今天就到这里，下一篇我们看看他更优雅的推导式（<code>Comprehensions</code>）。</p><blockquote><p>本文代码详见:<a href="https://github.com/NewbMiao/opa-koans/tree/master/syntax" target="_blank" rel="noopener">NewbMiao/opa-koans</a></p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://mp.weixin.qq.com/mp/homepage?__biz=MzUxNzA2NzEzNw==&hid=3&sn=6ded611e164ec49132752fdbdaac552f&scene=18#wechat_redirect)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      OPA进阶-函数与虚拟文档
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="virtual-document" scheme="http://blog.newbmiao.com/tags/virtual-document/"/>
    
  </entry>
  
</feed>
