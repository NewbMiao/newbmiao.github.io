<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟Miao</title>
  <icon>https://www.gravatar.com/avatar/644a62fb3ee1c60061ebca1d0996b0ae</icon>
  <subtitle>start from a newb...(博客地址永久迁移为 https://newbmiao.github.io)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://newbmiao.github.io/"/>
  <updated>2023-11-23T23:50:57.493Z</updated>
  <id>https://newbmiao.github.io/</id>
  
  <author>
    <name>菜鸟Miao</name>
    <email>newbvirgil@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust并发控制之Condvar-两线程交替打印</title>
    <link href="https://newbmiao.github.io/2023/11/23/rust-sync-condvar-2.html"/>
    <id>https://newbmiao.github.io/2023/11/23/rust-sync-condvar-2.html</id>
    <published>2023-11-23T15:30:59.000Z</published>
    <updated>2023-11-23T23:50:57.493Z</updated>
    
    <content type="html"><![CDATA[<p>在并发控制的面试里有个很喜欢考的点：如何控制两个并发线程交替打印1和2。</p><p>实现的方式有很多，今天我们先用上篇提到的condvar试试。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><p>思路是利用条件变量来控制两个线程：</p><ul><li>线程1：当且仅当条件为false时开始打印1，并修改条件为true, 通知等待的另一个线程打印2，否则while阻塞等待</li><li>线程2：条件为false时阻塞等待notify，直到条件为true，然后重置条件为false，并打印2</li></ul><p>代码及注释如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>, sleep&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Arc::new((Mutex::new(<span class="literal">false</span>), Condvar::new()));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> pair2 = pair.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(&#123;</span><br><span class="line">        <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair2;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(<span class="keyword">mut</span> v) = lock.lock() &#123;</span><br><span class="line">                    <span class="comment">// 条件为false时开始打印1</span></span><br><span class="line">                    <span class="comment">// 并修改条件为true, 通知等待的另一个线程打印2</span></span><br><span class="line">                    <span class="keyword">if</span> !*v &#123;</span><br><span class="line">                        <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">                        *v = <span class="literal">true</span>;</span><br><span class="line">                        cvar.notify_one();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 及时释放锁，不让mutexguard被scope结束时才释放</span></span><br><span class="line">                        <span class="comment">// 如果后续没操作的话，可以不用这里drop，等离开scope时自动释放也一样</span></span><br><span class="line">                        <span class="built_in">drop</span>(v);</span><br><span class="line">                        <span class="comment">// [2]</span></span><br><span class="line">                        <span class="comment">// sleep(Duration::from_millis(1));</span></span><br><span class="line">                        <span class="comment">// [1]</span></span><br><span class="line">                        <span class="comment">// print!(" waitting... ");</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(&#123;</span><br><span class="line">        <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> v = lock.lock().unwrap();</span><br><span class="line">                <span class="comment">// 条件为false时等待notify，直到条件为true</span></span><br><span class="line">                <span class="keyword">while</span> !*v &#123;</span><br><span class="line">                    v = cvar.wait(v).unwrap();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 重置条件为false，并打印2</span></span><br><span class="line">                *v = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.join().unwrap();</span><br><span class="line">    t2.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果可以实现打印 <code>1 2 1 2 1 2</code></p><p>不过线程1用遍历阻塞其实还是消耗了不少cpu时间，恢复注释[1]的打印可以看出，又多次waitting输出</p><p>可以加一点等待sleep，如注释[2]来减少cpu的占用和频繁对锁的抢占。</p><p>其实这个题目用semaphore实现也很有意思，下一篇我们聊semaphore时再来看。</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Condvar-两线程交替打印
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="condvar" scheme="https://newbmiao.github.io/tags/condvar/"/>
    
  </entry>
  
  <entry>
    <title>博客地址已迁移到newbmiao.github.io</title>
    <link href="https://newbmiao.github.io/2023/11/20/blog-migrate-hostname.html"/>
    <id>https://newbmiao.github.io/2023/11/20/blog-migrate-hostname.html</id>
    <published>2023-11-20T04:49:22.000Z</published>
    <updated>2023-11-20T04:58:33.746Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p><strong>声明：博客地址已迁移到 <a href="https://newbmiao.github.io">https://newbmiao.github.io</a>, 原域名<del>blog.newbmiao.com</del>已不再使用。</strong></p><a id="more"></a><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      newbmiao.github.io
    
    </summary>
    
    
      <category term="blog" scheme="https://newbmiao.github.io/categories/blog/"/>
    
    
      <category term="migrate" scheme="https://newbmiao.github.io/tags/migrate/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Condvar</title>
    <link href="https://newbmiao.github.io/2023/11/18/rust-sync-condvar.html"/>
    <id>https://newbmiao.github.io/2023/11/18/rust-sync-condvar.html</id>
    <published>2023-11-18T11:44:31.000Z</published>
    <updated>2023-11-20T02:27:04.673Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>上次提到的<a href="https://mp.weixin.qq.com/s/X4hIhzggiv-nv4vAxvX6Rw" target="_blank" rel="noopener">Barrier</a>用到了Rust的condvar和mutex，今天来看下condvar的用法。</p><a id="more"></a><p>condvar即condition variable（条件变量），是一种线程同步的方式，用于线程间的通信。它可以阻塞（wait）线程，期间不消耗CPU，直到某个时间发生唤醒（notify）线程。</p><p>代码举例来说：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Arc::new((Mutex::new(<span class="literal">false</span>), Condvar::new()));</span><br><span class="line">    <span class="keyword">let</span> pair2 = Arc::clone(&amp;pair);</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> (lock, cvar) = &amp;*pair2;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> started = lock.lock().unwrap();</span><br><span class="line">        *started = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// We notify the condvar that the value has changed.</span></span><br><span class="line">        cvar.notify_one();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the thread to start up.</span></span><br><span class="line">    <span class="keyword">let</span> (lock, cvar) = &amp;*pair;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> started = lock.lock().unwrap();</span><br><span class="line">    <span class="keyword">while</span> !*started &#123;</span><br><span class="line">        started = cvar.wait(started).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，创建一个线程在修改started变量后唤醒等待的线程。main中等待的的线程会一直阻塞（wait）直到started的值被修改。</p><p>其中wait会需要一个锁的MutexGuard来配合，wait会自动释放锁，并阻塞当前线程，直到被唤醒时重新获取锁，并返回锁的MutexGuard，来获取锁当前保护的值</p><blockquote><p>Tips: MutexGuard实现了销毁时自动释放锁和可以通过解引用（deref）到它保护的值</p></blockquote><p>这里有两个有意思的点：</p><ul><li>为什么要和mutex一起使用？</li><li>为什么唤醒时要检查条件是否满足？</li></ul><p>这个要从condvar唤醒的机制说起。</p><h2 id="唤醒顺序不保证"><a href="#唤醒顺序不保证" class="headerlink" title="唤醒顺序不保证"></a>唤醒顺序不保证</h2><p>先来看下唤醒的顺序，我们起两批同样数目的线程，一批线程每个线程会修改一次变量并唤醒一个另一批等待的线程，为了观测唤醒顺序，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SharedData</span></span> &#123;</span><br><span class="line">    counter: Mutex&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">    condvar: Condvar,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> shared_data = Arc::new(SharedData &#123;</span><br><span class="line">        counter: Mutex::new(<span class="number">0</span>),</span><br><span class="line">        condvar: Condvar::new(),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> thread_num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> workers = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> waits = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..thread_num &#123;</span><br><span class="line">        do_wait(i, Arc::clone(&amp;shared_data), &amp;<span class="keyword">mut</span> waits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..thread_num &#123;</span><br><span class="line">        do_work(i, Arc::clone(&amp;shared_data), &amp;<span class="keyword">mut</span> workers)</span><br><span class="line">    &#125;</span><br><span class="line">    waits.into_iter().for_each(|w| w.join().unwrap());</span><br><span class="line">    workers.into_iter().for_each(|w| w.join().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_work</span></span>(i: <span class="built_in">i32</span>, data: Arc&lt;SharedData&gt;, workers: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;) &#123;</span><br><span class="line">    workers.push(thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> SharedData &#123; counter, condvar &#125; = &amp;*data;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> data = counter.lock().unwrap();</span><br><span class="line">        *data += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Woker thread &#123;&#125; before notify: Counter &#123;&#125;"</span>, i, data);</span><br><span class="line">        condvar.notify_one();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_wait</span></span>(i: <span class="built_in">i32</span>, data: Arc&lt;SharedData&gt;, waits: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;) &#123;</span><br><span class="line">    waits.push(thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> SharedData &#123; counter, condvar &#125; = &amp;*data;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> data = counter.lock().unwrap();</span><br><span class="line">        data = condvar.wait(data).unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"   Wait thread &#123;&#125; after wake up: Counter &#123;&#125;"</span>, i, data);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果不唯一，比如如下结果，五次修改触发了五次唤醒，但是wait唤醒顺序不一定是按照worker修改顺序（而修改顺序是符合预期的，因为是加锁保证的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Woker thread 0 before notify: Counter 1</span><br><span class="line">Woker thread 4 before notify: Counter 2</span><br><span class="line">Woker thread 2 before notify: Counter 3</span><br><span class="line">   Wait thread 1 after wake up: Counter 3</span><br><span class="line">   Wait thread 3 after wake up: Counter 3</span><br><span class="line">Woker thread 3 before notify: Counter 4</span><br><span class="line">   Wait thread 0 after wake up: Counter 4</span><br><span class="line">Woker thread 1 before notify: Counter 5</span><br><span class="line">   Wait thread 4 after wake up: Counter 5</span><br><span class="line">   Wait thread 2 after wake up: Counter 5</span><br></pre></td></tr></table></figure><p>甚至有可能是唤醒次数少于五次，导致有些线程一直阻塞，比如如下结果，只有四次唤醒，导致有1个线程一直阻塞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Woker thread 1 before notify: Counter 1</span><br><span class="line">   Wait thread 2 after wake up: Counter 1</span><br><span class="line">Woker thread 3 before notify: Counter 2</span><br><span class="line">Woker thread 0 before notify: Counter 3</span><br><span class="line">   Wait thread 4 after wake up: Counter 3</span><br><span class="line">Woker thread 4 before notify: Counter 4</span><br><span class="line">   Wait thread 3 after wake up: Counter 4</span><br><span class="line">   Wait thread 1 after wake up: Counter 4</span><br><span class="line">Woker thread 2 before notify: Counter 5</span><br><span class="line"><span class="comment"># 有一个线程一直阻塞在这里</span></span><br></pre></td></tr></table></figure><p>为什么顺序不保证呢？condvar实现是基于操作系统的条件变量实现，顺序取决于操作系统调度时当前可唤醒的线程是哪个，要保证唤醒顺序需要额外的开销，而这个开销是不必要的，因为唤醒顺序对于线程间的通信是没有意义的，所以底层实现并不保证唤醒顺序。<a href="https://www.reddit.com/r/C_Programming/comments/12itrvd/condition_variables_wakeup_ordering/" target="_blank" rel="noopener">这里</a>有相关讨论</p><p>所以多个线程等待同一条件变量时，notify_one唤醒和等待也不是一定是一对一的调用，每次唤醒也不能保证都是不同的等待线程。</p><p>至于为什么会有线程一直阻塞的情况，是因为唤醒次数少于等待次数，导致有些线程一直阻塞。<br>因为是多线程并发构建的notify_one和wait，存在调用notify_one时没有线程在等待的可能，导致唤醒次数少于等待次数的情况。</p><h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><p>还有就是虚假唤醒，即wait返回时，条件由于并发原因已经不满足，还可能因为唤醒并不是由于显示的notify调用，这个听起来很奇怪，但不是一个bug，是底层操作系统实现导致的，具体看看<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">wiki</a>上的说明吧。</p><p>综上这两点，condvar唤醒时是需要重新检查条件是否依旧满足，而且需要和mutex一起使用，来确保条件值获取的并发安全。</p><p>除此condvar还有一些方便的方法，比如提供了</p><ul><li>notify_all来广播唤醒所有等待的线程；</li><li>wait_while可以根据条件等待条件直到满足；</li><li>wait_timeout只等待一段时间如果不能及时被唤醒。</li></ul><p>官方文档都有例子，就不展开了。</p><p>关于condvar比较实际的例子有WaitGroup，不需要像Barrier一样初始化时指定线程数量，而是在运行时动态增加线程数量，在<a href="https://github.com/crossbeam-rs/crossbeam/blob/master/crossbeam-utils/src/sync/wait_group.rs" target="_blank" rel="noopener">crossbeam-utils</a>中有实现，代码很精炼，感兴趣可以看下</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Condvar
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="condvar" scheme="https://newbmiao.github.io/tags/condvar/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Barrier</title>
    <link href="https://newbmiao.github.io/2023/11/12/rust-sync-barrier.html"/>
    <id>https://newbmiao.github.io/2023/11/12/rust-sync-barrier.html</id>
    <published>2023-11-12T11:44:31.000Z</published>
    <updated>2023-11-20T02:27:04.673Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>Rust有很多种控制并发的方式，Barrier（屏障）是其中一种用来同步多线程计算的方式。</p><p>今天拿代码来简单看下。</p><a id="more"></a><p>比如我们要多线程计算，期望所有线程都计算完毕再输出最终结果。常规多线程代码示例可以用线程join来等待</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numthreads = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> my_mutex = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handlers = <span class="built_in">Vec</span>::with_capacity(numthreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..numthreads &#123;</span><br><span class="line">        <span class="keyword">let</span> my_lock = my_mutex.clone();</span><br><span class="line">        handlers.push(std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> guard = my_lock.lock().unwrap();</span><br><span class="line">            *guard += <span class="number">1</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> handler <span class="keyword">in</span> handlers &#123;</span><br><span class="line">        handler.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> answer = &#123; *my_mutex.lock().unwrap() &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(answer, numthreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果用Barrier，我们可以这么写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Barrier, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numthreads = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> my_mutex = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We use a barrier to ensure the readout happens after all writing</span></span><br><span class="line">    <span class="keyword">let</span> barrier = Arc::new(Barrier::new(numthreads + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..numthreads &#123;</span><br><span class="line">        <span class="keyword">let</span> my_barrier = barrier.clone();</span><br><span class="line">        <span class="keyword">let</span> my_lock = my_mutex.clone();</span><br><span class="line">        std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> guard = my_lock.lock().unwrap();</span><br><span class="line">            *guard += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Release the lock to prevent a deadlock</span></span><br><span class="line">            <span class="built_in">drop</span>(guard);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"thread &#123;&#125; is ready"</span>, i);</span><br><span class="line">            <span class="comment">// Blocks the current thread until all threads have rendezvoused here.</span></span><br><span class="line">            my_barrier.wait();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"thread &#123;&#125; is done"</span>, i)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A barrier will block `n`-1 threads which call [`wait()`] and then wake</span></span><br><span class="line">    <span class="comment">// up all threads at once when the `n`th thread calls [`wait()`].</span></span><br><span class="line">    barrier.wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> answer = &#123; *my_mutex.lock().unwrap() &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(answer, numthreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Barrier可以用wait来控制n个线程的同步，数量需要提前指明。<br>当调用wait时，如果不是第n个，就会一直阻塞当前线程，直到第n个wait调用，才能进行后续操作。</p><p>这种机制就像在多个线程中插入了一道屏障，当所有线程都执行到这里时，才能解除屏障继续向后执行。</p><p>当然这样实现相较于第一种，在线程数量大的时候也是会有比较明显的性能开销的，底层是使用condvar+mutex来实现的。这种组合也是一种有意思的并发控制方式，下次我们再聊聊它们。</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Barrier
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="barrier" scheme="https://newbmiao.github.io/tags/barrier/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Rust的并发约束：Send和Sync</title>
    <link href="https://newbmiao.github.io/2023/10/11/rust-send-and-sync-trait.html"/>
    <id>https://newbmiao.github.io/2023/10/11/rust-send-and-sync-trait.html</id>
    <published>2023-10-11T09:17:22.000Z</published>
    <updated>2023-11-12T12:12:32.287Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>不知道你有没有好奇过，<code>Rust</code>是怎么控制并发安全的。为什么编译器在编译时就能发现一些并发安全的问题。</p><p>今天拿例子聊聊这背后<code>Rust</code>的两个并发约束<code>trait</code>：<code>Sync</code>和<code>Send</code>，看看它们是怎么控制并发安全的。</p><a id="more"></a><h2 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h2><p>先来看看下边代码，尝试将<code>String</code>类型的引用计数<code>a</code>（<code>Rc&lt;String&gt;</code>）移动到另一个线程中去，会发现编译器报错了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, thread&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    <span class="comment">// 注意！这里move让闭包获取了a的所有权（Rc&lt;String&gt;）</span></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> b = a.clone();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// got error:</span></span><br><span class="line">    <span class="comment">// `Rc&lt;String&gt;` cannot be sent between threads safely</span></span><br><span class="line">    <span class="comment">// the trait `Send` is not implemented for `Rc&lt;String&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察编译器的报错和下边相关代码<code>trait</code>实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> Rc&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="built_in">FnOnce</span>() -&gt; T,</span><br><span class="line">    F: <span class="built_in">Send</span> + <span class="symbol">'static</span>,</span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="symbol">'static</span>,</span><br></pre></td></tr></table></figure><p>你会发现<code>thread::spawn</code>要求传入的闭包<code>F</code>必须实现<code>Send</code>，而<code>Rc</code>类型的<code>a</code>没有实现<code>Send</code>，所以编译器报错了。</p><p>我们知道<code>Rc</code>是引用计数，它为了性能没有实现原子操作的引用计数，如果在多个线程中共享，那么引用计数可能会出现计数错误，所以不能安全的跨线程共享。</p><p>那<code>Send</code>是干什么的呢？</p><p><code>Send</code>是一个<code>trait</code>，它标记了实现它的类型可以安全的在线程间<strong>传递</strong>所有权。也就是可以安全的<strong>移动</strong>（<code>move</code>）其所有权。</p><p><code>Send trait</code>是一个<strong>标记型（marker）</strong>的<code>trait</code>, 它没有实际方法，也不需要用户主动去实现，一般基本类型都实现了<code>Send</code>。而复合类型如果包含的所有成员都实现了<code>Send</code>，那么它也<strong>自动</strong>实现了<code>Send</code>。（后面的<code>Sync</code>也是这样的自动<code>trait</code>）</p><p>也就是说，需要并发中需要安全传递<strong>值</strong>都需要被标记实现<code>Send</code>，否则编译器会报错。</p><p>并发安全检查变成了<code>trait bound</code>检查，这样就能在编译时发现问题，而不是在运行时，是不是很巧妙！</p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>再来看看下边代码，尝试将<code>String</code>类型的引用计数<code>a</code>（<code>&amp;Rc&lt;String&gt;</code>）共享到一个线程中去，会发现编译器报错了。（注意没有移动，是共享）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, thread&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    <span class="comment">// 注意！这里没有用move，闭包获取的是a的引用（&amp;Rc&lt;String&gt;）</span></span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> b = a.clone();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// `Rc&lt;String&gt;` cannot be shared between threads safely</span></span><br><span class="line">    <span class="comment">// the trait `Sync` is not implemented for `Rc&lt;String&gt;`</span></span><br><span class="line">    <span class="comment">// required for `&amp;Rc&lt;String&gt;` to implement `Send`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然，<code>Rc</code>没有实现<code>Sync</code>，所有编译器报错了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> Rc&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Sync</code>也是一个标记型<code>trait</code>，它标记了实现它的类型可以安全的在线程间共享访问。</p><p>所谓共享，其实就是可以安全的引用。而如果<code>&amp;T</code>实现了<code>Send</code>（可安全移动），那么<code>T</code>就实现了<code>Sync</code>（可安全共享其的引用）。</p><p>也就是说，需要并发中需要安全<strong>引用</strong>（<code>&amp;T</code>）都需要<code>T</code>被标记实现了<code>Sync</code>，否则编译器会报错。</p><p>又是一个巧妙的设计，通过<code>trait bound</code>检查了引用是否满足并发安全。</p><p>总结一下：</p><ul><li><code>Send</code>标记了实现它的类型可以安全的在线程间传递所有权（<code>move</code>）。</li><li><code>Sync</code>标记了实现它的类型可以安全的在线程间共享引用（<code>&amp;T</code>）。</li></ul><p>最后推荐看看官方的这两篇文档来加深理解</p><ul><li><a href="https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html" target="_blank" rel="noopener">Extensible Concurrency with the Sync and Send Traits</a></li><li><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html" target="_blank" rel="noopener">Send and Sync</a></li></ul><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊Rust的并发约束：Send和Sync
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="send" scheme="https://newbmiao.github.io/tags/send/"/>
    
      <category term="sync" scheme="https://newbmiao.github.io/tags/sync/"/>
    
  </entry>
  
  <entry>
    <title>聊聊共享所有权之Rc和Arc</title>
    <link href="https://newbmiao.github.io/2023/10/07/ownership-of-rc-and-arc.html"/>
    <id>https://newbmiao.github.io/2023/10/07/ownership-of-rc-and-arc.html</id>
    <published>2023-10-07T11:44:05.000Z</published>
    <updated>2023-10-11T08:59:17.704Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><h2 id="1v1-所有权"><a href="#1v1-所有权" class="headerlink" title="1v1 所有权"></a>1v1 所有权</h2><p><code>Rust</code>中所有权约束了值只能有一个所有者，当值离开作用域时，它将被销毁。</p><p>像如下代码，字符串<code>a</code>如果直接移动给<code>b</code>后就没法后边再去打印，因为它的所有权已经转移给了<code>b</code>。</p><a id="more"></a><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"a = &#123;&#125;, b = &#123;&#125;"</span>, a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// got error:</span></span><br><span class="line"><span class="comment">// error[E0382]: borrow of moved value: `a`</span></span><br><span class="line"><span class="comment">// 3 |     let a = String::from("hello");</span></span><br><span class="line"><span class="comment">//   |         - move occurs because `a` has type `String`, which does not implement the `Copy` trait</span></span><br><span class="line"><span class="comment">// 4 |     let b = a;</span></span><br><span class="line"><span class="comment">//   |             - value moved here</span></span><br><span class="line"><span class="comment">// 5 |     println!("a = &#123;&#125;, b = &#123;&#125;", a, b);</span></span><br><span class="line"><span class="comment">//   |                                ^ value borrowed here after move</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝（clone）"><a href="#深拷贝（clone）" class="headerlink" title="深拷贝（clone）"></a>深拷贝（clone）</h2><p>如果<code>clone</code>的话可以复制一份，但是这样的话就需要开辟一块新的内存，不是很高效。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// let b = a;</span></span><br><span class="line"><span class="keyword">let</span> b = a.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"a = &#123;&#125;, b = &#123;&#125;"</span>, a, b);</span><br><span class="line"><span class="comment">// output: a = hello, b = hello</span></span><br></pre></td></tr></table></figure><h2 id="引用计数-（reference-count）"><a href="#引用计数-（reference-count）" class="headerlink" title="引用计数 （reference count）"></a>引用计数 （reference count）</h2><p>想要实现多个所有者，又开销小，可以用引用计数，对应的类型是<code>Rc</code>。</p><p><code>Rc</code>只会在复制时增加引用计数，当引用计数为0时，会自动调用<code>drop</code>方法，释放内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line"><span class="keyword">let</span> _b = Rc::clone(&amp;a);</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">let</span> _b = Rc::clone(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"reference count &#123;&#125;"</span>, Rc::strong_count(&amp;a)); </span><br><span class="line">    <span class="comment">// 3, will be 2 after this block out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"reference count &#123;&#125;"</span>, Rc::strong_count(&amp;a)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="写时复制（copy-on-write）"><a href="#写时复制（copy-on-write）" class="headerlink" title="写时复制（copy on write）"></a>写时复制（copy on write）</h2><p><code>Rc</code>引用的值是不可变的，如果想要修改，可以使用<code>Rc::make_mut</code>方法，它会检查引用计数，在有别的有效引用（<code>strong</code>）时，会复制一份，然后修改。否则就直接修改原来的值。这也是写时复制，只有在需要修改时才会复制。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line"><span class="keyword">let</span> b = Rc::clone(&amp;a);</span><br><span class="line"><span class="comment">//  allocate a new string (copy on write)</span></span><br><span class="line">(*Rc::make_mut(&amp;<span class="keyword">mut</span> a)).push_str( <span class="string">" world"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>,  a, b); </span><br><span class="line"><span class="comment">// hello world hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = Rc::clone(&amp;a);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125; &#123;&#125;"</span>,  a, b, c); </span><br><span class="line"><span class="comment">// hello world hello hello world</span></span><br></pre></td></tr></table></figure><p>所以这么用有一个好处，如果有修改，修改是独立于之前的引用的，不用担心修改会影响之前引用的值。</p><blockquote><p>当然，如果想保持值修改的同步，可以使用之前提到的<code>Cell</code>和<code>RefCell</code>，这两个类型可以实现内部可变性，可以在不可变引用的情况下修改值。</p></blockquote><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p><code>Rc</code>是不允许循环引用的，因为它的引用计数是在编译时就确定的，如果有循环引用，那么引用计数永远不会为0，也就永远不会调用<code>drop</code>方法，导致内存泄漏。</p><p>这里用官方的一个例子说明：下边代码用来描述工具（gadget）和工具所有者（owner）的关系，一个工具可以有一个个所有者，一个所有者可以有多个工具。</p><p>如果用<code>Rc</code>来实现的话，会出现循环引用，工具和工具所有者互相引用，导致谁都无法对引用计数减一，也就无法释放对应的内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    gadgets: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Gadget&gt;&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gadget</span></span> &#123;</span><br><span class="line">    id: <span class="built_in">i32</span>,</span><br><span class="line">    owner: Rc&lt;Owner&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> gadget_owner : Rc&lt;Owner&gt; = Rc::new(</span><br><span class="line">            Owner &#123; name: <span class="built_in">String</span>::from(<span class="string">"Gadget Man"</span>), gadgets: RefCell::new(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 两个工具，都有同一个所有者</span></span><br><span class="line">    <span class="keyword">let</span> gadget1 = Rc::new(Gadget &#123; id: <span class="number">1</span>, owner: gadget_owner.clone() &#125;);</span><br><span class="line">    <span class="keyword">let</span> gadget2 =Rc::new(Gadget &#123; id: <span class="number">2</span>, owner: gadget_owner.clone() &#125;);</span><br><span class="line"></span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(gadget1.clone());</span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(gadget2.clone());</span><br><span class="line">    <span class="comment">// 释放gadget_owner的引用计数，保留工具的owner引用计数</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget_owner);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1));</span><br><span class="line">    <span class="comment">// strong count of gadget1: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget1.owner: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放gadget1的引用计数，正常没有引用循环的话，owner对应的引用计数也需要释放</span></span><br><span class="line">    <span class="comment">// 但是gadget1的owner的引用计数不会减一，导致内存泄漏</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget2.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget2.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget2.owner: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环引用如下图所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gadgets和owner的引用形成了一个环，谁也没法释放，对应的引用计数无法减到0，也就没法释放</span><br><span class="line"></span><br><span class="line">+-----------+       +-----------+</span><br><span class="line">|   Owner   |&lt;------|  Gadget   |</span><br><span class="line">|           |       |           |</span><br><span class="line">|   Rc      |       |   Rc      |</span><br><span class="line">|           |       |           |</span><br><span class="line">| gadgets --|------&gt;| owner ----+</span><br><span class="line">+-----------+       +-----------+</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>这个时候就是弱引用的用武之地了，弱引用不会增加引用计数，所以不会导致循环引用。</p><p>但是它也不能保证引用的值一定存在，因为它的引用计数可能为0，所以用时，需要用<code>upgrade</code>方法来获取<code>Option</code>类型的引用。</p><p>也就是说引用的值释放与否只取决于强引用的引用计数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::rc::Weak;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    gadgets: RefCell&lt;<span class="built_in">Vec</span>&lt;Weak&lt;Gadget&gt;&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gadget</span></span> &#123;</span><br><span class="line">    id: <span class="built_in">i32</span>,</span><br><span class="line">    owner: Rc&lt;Owner&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> gadget_owner : Rc&lt;Owner&gt; = Rc::new(</span><br><span class="line">            Owner &#123;</span><br><span class="line">                name: <span class="string">"Gadget Man"</span>.to_string(),</span><br><span class="line">                gadgets: RefCell::new(<span class="built_in">Vec</span>::new())</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> gadget1 = Rc::new(Gadget&#123;id: <span class="number">1</span>, owner: gadget_owner.clone()&#125;);</span><br><span class="line">    <span class="keyword">let</span> gadget2 = Rc::new(Gadget&#123;id: <span class="number">2</span>, owner: gadget_owner.clone()&#125;);</span><br><span class="line"></span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget1.clone()));</span><br><span class="line">    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget2.clone()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gadget_opt <span class="keyword">in</span> gadget_owner.gadgets.borrow().iter() &#123;</span><br><span class="line">        <span class="keyword">let</span> gadget = gadget_opt.upgrade().unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Gadget &#123;&#125; owned by &#123;&#125;"</span>, gadget.id, gadget.owner.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">drop</span>(gadget_owner);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1));</span><br><span class="line">    <span class="comment">// strong count of gadget1: 1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget1.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget1.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget1.owner: 2</span></span><br><span class="line">    <span class="built_in">drop</span>(gadget1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"strong count of gadget2.owner: &#123;&#125;"</span>, Rc::strong_count(&amp;gadget2.owner));</span><br><span class="line">    <span class="comment">// strong count of gadget2.owner: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><code>Rc</code>是线程不安全的，如果想要在多线程中使用，可以使用<code>Arc</code>，它是<code>Rc</code>的线程安全版本。 （<code>A</code>代表<code>atomic</code>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> val = Arc::new(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val = Arc::clone(&amp;val);</span><br><span class="line">        thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> v = *val.as_ref() + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;v:?&#125;"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    thread::sleep(std::time::Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果想要在多线程中修改值，可以使用<code>Mutex</code>和<code>RwLock</code>，它们都是线程安全的。 如<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。</p><hr><p>最后还有一点想提下，<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>都实现了自动解引用<code>Deref</code>到<code>T</code>，所以可以直接在<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>上调用<code>T</code>的方法。而为了防止方法名冲突，一般习惯用全限定语法调用方法来调用<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>的方法，如<code>Rc::clone</code>。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊所有权之Rc和Arc
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="ownership" scheme="https://newbmiao.github.io/tags/ownership/"/>
    
      <category term="rc" scheme="https://newbmiao.github.io/tags/rc/"/>
    
      <category term="arc" scheme="https://newbmiao.github.io/tags/arc/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Rust的Cell和RefCell</title>
    <link href="https://newbmiao.github.io/2023/10/03/rust-cell-and-refcell.html"/>
    <id>https://newbmiao.github.io/2023/10/03/rust-cell-and-refcell.html</id>
    <published>2023-10-03T08:53:52.000Z</published>
    <updated>2023-10-03T09:01:13.724Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>内部可变性（<code>interior mutability</code>）是<code>Rust</code>用来表示在一个值的外部看起来是不可变的，但是在内部是可变的。这种模式通常用于在拥有不可变引用的同时修改目标数据。</p><p><code>Cell</code>和<code>RefCell</code>是<code>Rust</code>提供的两种内部可变性的实现。<code>Cell</code>是用于<code>Copy</code>类型的，而<code>RefCell</code>是用于非<code>Copy</code>类型的。</p><p>不知道你有没有好奇过具体内部可变性应用在什么场景，为啥要分两种实现。</p><p>今天我们针对一些场景来聊聊这两个类型的应用。</p><a id="more"></a><h2 id="Why-interior-mutability"><a href="#Why-interior-mutability" class="headerlink" title="Why interior mutability?"></a>Why interior mutability?</h2><p>如下代码所示，当需要多个可变引用时，会违反<code>Rust</code>的所有权要求：同一时间只能有一个可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"><span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line">*z = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line"># will get error:</span><br><span class="line"># error[E0499]: cannot borrow `x` <span class="keyword">as</span> mutable more than once at a time</span><br><span class="line">#  --&gt; src/main.rs:<span class="number">5</span>:<span class="number">9</span></span><br><span class="line">#   |</span><br><span class="line"># <span class="number">4</span> | <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ------ first mutable borrow occurs here</span><br><span class="line"># <span class="number">5</span> | <span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ^^^^^^ second mutable borrow occurs here</span><br><span class="line"># <span class="number">6</span> | x = <span class="number">2</span>;</span><br><span class="line"># <span class="number">7</span> | *y = <span class="number">3</span>;</span><br><span class="line">#   | ------ first borrow later used here</span><br><span class="line"></span><br><span class="line"># error[E0506]: cannot assign to `x` because it is borrowed</span><br><span class="line">#  --&gt; src/main.rs:<span class="number">6</span>:<span class="number">1</span></span><br><span class="line">#   |</span><br><span class="line"># <span class="number">4</span> | <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">#   |         ------ `x` is borrowed here</span><br><span class="line"># <span class="number">5</span> | <span class="keyword">let</span> z = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"># <span class="number">6</span> | x = <span class="number">2</span>;</span><br><span class="line">#   | ^^^^^ `x` is assigned to here but it was already borrowed</span><br><span class="line"># <span class="number">7</span> | *y = <span class="number">3</span>;</span><br><span class="line">#   | ------ borrow later used here</span><br></pre></td></tr></table></figure><p>这个时候就是内部可变性发挥作用的时候了。拿<code>Cell</code>来举例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = Cell::new(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> y = &amp;x;</span><br><span class="line"><span class="keyword">let</span> z = &amp;x;</span><br><span class="line">x.set(<span class="number">2</span>);</span><br><span class="line">y.set(<span class="number">3</span>);</span><br><span class="line">z.set(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x.get());</span><br></pre></td></tr></table></figure><p>通过<code>Cell</code>，其封装了<code>get</code>和<code>set</code>,可以在不需要显示声明为可变的情况下修改值。</p><h3 id="修改结构体的字段"><a href="#修改结构体的字段" class="headerlink" title="修改结构体的字段"></a>修改结构体的字段</h3><p>一般我们要修改一个结构体的值，需要将其声明为<code>mut</code>, 而对应的方法也需要接收<code>&amp;mut self</code> 举例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    age: <span class="built_in">u32</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">celebrate_birthday</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> current_age = <span class="keyword">self</span>.age;</span><br><span class="line">        <span class="keyword">self</span>.age = current_age + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> Person = Person::default();</span><br><span class="line">Person.celebrate_birthday();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Age after birthday: &#123;&#125;"</span>, Person.age);</span><br></pre></td></tr></table></figure><p>但是有时候我们并不想这么做，因为我们只是想<strong>修改其中的某个字段</strong>，而不是整个结构体，亦或者<strong>接口并不想暴露一个<code>&amp;mut self</code>的方法</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    age: Cell&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="comment">// 方法receiver无需声明为`mut`</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">celebrate_birthday</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> current_age = <span class="keyword">self</span>.age.get();</span><br><span class="line">        <span class="keyword">self</span>.age.set(current_age + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.celebrate_birthday();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Age after birthday: &#123;&#125;"</span>, person.age.get());</span><br></pre></td></tr></table></figure><h2 id="Cell-只适合-Copy-类型"><a href="#Cell-只适合-Copy-类型" class="headerlink" title="Cell 只适合 Copy 类型"></a>Cell 只适合 Copy 类型</h2><p>对于非<code>Copy</code>类型，<code>Cell</code>并不适用, 因为其约束了<code>get</code>方法的返回值必须是<code>Copy</code>类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>&gt; Cell&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(&amp;<span class="keyword">self</span>) -&gt; T &#123;</span><br></pre></td></tr></table></figure><p>那是不是不能往<code>Cell</code>里面放非<code>Copy</code>类型的值呢？当然不是，只是失去了意义，代码如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = Cell::new(<span class="built_in">String</span>::from(<span class="string">"value"</span>));</span><br><span class="line"><span class="comment">// 没有 `s.get()`，因为 `String` 不是 `Copy` 类型</span></span><br><span class="line"><span class="comment">// 而`get_mut()`返回的是 要求自身是可变的，就失去了用`Cell`的意义</span></span><br><span class="line">*s.get_mut() = <span class="built_in">String</span>::from(<span class="string">"value2"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s.into_inner());</span><br></pre></td></tr></table></figure><h2 id="RefCell-提供引用"><a href="#RefCell-提供引用" class="headerlink" title="RefCell 提供引用"></a>RefCell 提供引用</h2><p><code>RefCell</code>主要的不同是支持非<code>Copy</code>类型，且返回的是引用，而不是值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="string">"hello"</span>.to_owned());</span><br><span class="line">*c.borrow_mut() = <span class="string">"bonjour"</span>.to_owned();</span><br><span class="line"><span class="keyword">let</span> val = c.borrow();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;*val, <span class="string">"bonjour"</span>);</span><br></pre></td></tr></table></figure><h2 id="运行时检查"><a href="#运行时检查" class="headerlink" title="运行时检查"></a>运行时检查</h2><p>如果把上边代码换成如下先借用，编译能通过，但是运行时会报错。</p><p><code>RefCell</code> 依旧要遵守借用规则，只是推迟检查从编译期到运行时，如果违反了借用规则，会 <code>panic</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```rust</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="string">"hello"</span>.to_owned());</span><br><span class="line"><span class="keyword">let</span> val = c.borrow(); <span class="comment">// 先借用再修改，最后读取借用的值</span></span><br><span class="line">*c.borrow_mut() = <span class="string">"bonjour"</span>.to_owned();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(&amp;*val, <span class="string">"bonjour"</span>);</span><br><span class="line"></span><br><span class="line"># will panic:</span><br><span class="line"># thread <span class="symbol">'main</span>' panicked at <span class="symbol">'already</span> borrowed: BorrowMutError', src/main.rs:<span class="number">7</span>:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>综上可以看出，<code>Cell</code>和<code>RefCell</code>是不同粒度的内部可变性实现，简单的<code>Copy</code>类型可以考虑开销小的<code>Cell</code>来获取有内部可变性的<strong>值</strong>， 需要更灵活的内部可变<strong>借用</strong>就要用<code>RefCell</code>。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊Rust的Cell和RefCell
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="cell" scheme="https://newbmiao.github.io/tags/cell/"/>
    
      <category term="refcell" scheme="https://newbmiao.github.io/tags/refcell/"/>
    
  </entry>
  
  <entry>
    <title>掌握Rust：从零开始的所有权之旅</title>
    <link href="https://newbmiao.github.io/2023/08/13/master-rust-ownership-from-scratch.html"/>
    <id>https://newbmiao.github.io/2023/08/13/master-rust-ownership-from-scratch.html</id>
    <published>2023-08-13T14:25:08.000Z</published>
    <updated>2023-08-22T02:55:23.061Z</updated>
    
    <content type="html"><![CDATA[<p>所有权是 <code>Rust</code> 很有意思的一个语言特性，但对于初学者却是一个比较有挑战的内容。</p><p>今天尝试用代码示例来聊聊 <code>Rust</code> 的所有权是什么，以及为什么要有所有权。希望能给初学的朋友一点帮助。</p><blockquote><p>Tips：文中代码有相应注释，建议可以先不用纠结细节，关注整体。后边可以再挨个去研究具体代码细节</p></blockquote><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="移动？拷贝？"><a href="#移动？拷贝？" class="headerlink" title="移动？拷贝？"></a>移动？拷贝？</h2><p>先来试试常规的赋值语句在<code>Rust</code>有什么样的表现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"start"</span>);</span><br><span class="line"><span class="comment">// code 1:</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> _b = a;</span><br><span class="line"><span class="keyword">let</span> _c = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code 2:</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> _e = d;</span><br><span class="line"><span class="keyword">let</span> _f = d;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `d`</span><br><span class="line">  --&gt; src/main.rs:<span class="number">12</span>:<span class="number">10</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> | <span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |     - move occurs because `d` has type `String`, which does not implement the `Copy` trait</span><br><span class="line"><span class="number">11</span> | <span class="keyword">let</span> _e = d;</span><br><span class="line">   |          - value moved here</span><br><span class="line"><span class="number">12</span> | <span class="keyword">let</span> _f = d;</span><br><span class="line">   |          ^ value used here after <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">help: consider cloning the value <span class="keyword">if</span> the performance cost is acceptable</span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> | <span class="keyword">let</span> _e = d.clone();</span><br><span class="line">   |           ++++++++</span><br></pre></td></tr></table></figure><p>为什么 <code>code 2</code> 出错了？ <code>code 1</code> 没有？</p><p>看起来都是初始化赋值操作，分别将数字 <code>a</code> 和字符串 <code>d</code> <strong>多次赋值</strong>给别的变量<br>为什么字符串的赋值失败了。</p><p>这里要引出 <code>Rust</code> 世界里对<strong>值拷贝</strong>和<strong>所有</strong>的区分</p><p>对于一切变量，当把他传递给别的变量或函数，如果他可以拷贝（<code>Copy</code>）就复制一份；否则就将值的所有权移动（<code>Move</code>）过去。</p><p>这里<code>a</code>是数字，数字是可以拷贝的，所以 <code>code 1</code> 是可以编译通过的。<br>而<code>d</code>是字符串，字符串是不可以拷贝的，第一次赋值就将所有权move给了<code>_e</code>，只能<code>move</code>一次，所以 <code>code 2</code> 编译不通过。</p><p>为什么要拷贝或移动？先剧透下 <code>Rust</code> 没有内存垃圾回收器（<code>GC</code>），它对内存的管理就是依赖所有权，谁持有（<code>Own</code>）变量，谁可以在变量需要销毁时释放内存。</p><p>我们拿代码看看它如何销毁变量</p><h2 id="作用域和销毁"><a href="#作用域和销毁" class="headerlink" title="作用域和销毁"></a>作用域和销毁</h2><p>这里我们关注在何时销毁的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为孤儿原则，包装原生string类型，来支持添加drop trait实现，来观察销毁</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyString</span></span>(<span class="built_in">String</span>);</span><br><span class="line"><span class="keyword">impl</span> MyString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        MyString(<span class="built_in">String</span>::from(name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyData</span></span> &#123;</span><br><span class="line">    data: MyString,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁时打印字符串</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyString with value: &#123;:?&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁时打印包含字符串的结构体</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyData &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyData with value: &#123;:?&#125;"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"not used"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> _wrapper = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as variable"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dropping MyData with value: MyString(<span class="string">"not used"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"not used"</span></span><br><span class="line">End of the scope inside main.</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as variable"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as variable"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>代码分了两个作用域（<code>Scope</code>）</p><blockquote><p>Tips: 其实有多个，每个<code>let</code>也可以看做是一个作用域，这里为了方便理解，只分了两个</p></blockquote><ul><li><p>main函数自身的<code>scope</code></p></li><li><p>main函数内的<code>scope</code></p><p>  在此作用域内<code>_</code>变量的结构体及包含的字符串就销毁了。<br>  这里<code>let _</code>代表这个变量被忽略，也无法再被别人使用，所以当即销毁</p><p>  离开此作用域时，局部变量<code>_wrapper</code>也被销毁</p></li></ul><p>结合之前字符串不能多次移动，这里就展示<code>Rust</code>对内存管理的两个原则：</p><ul><li><strong>值只能有一个所有者，当离开作用域，值将被丢弃</strong>。</li><li><strong>所有权可以转移</strong></li></ul><p>嗯，这么搞确实很利于内存管理。</p><p>那要只是想引用一个变量，不想移动怎么办？（毕竟移动只能一次）</p><h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>先来看看常规的“引用”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"start"</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> d = &amp;a;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="comment">// let ref d = a;</span></span><br><span class="line"><span class="keyword">let</span> _e = d;</span><br><span class="line"><span class="keyword">let</span> _f = d;</span><br></pre></td></tr></table></figure><p>这段代码是可以编译通过的</p><blockquote><p>Tips，<code>Rust</code>在编译阶段就能分析出很多代码问题，这也是为什么前边的错误里没有打印“start”，因为编译就失败了</p></blockquote><p><code>Rust</code>里对“引用”有细分，这里叫借用（<code>Borrow</code>），至于为什么，我们后边讲</p><p>从目前的代码看，如果一个变量借用了字符串变量，这个借用是可以赋值给多个变量的。</p><p>这样对于不需要<code>Move</code>整个字符串，只是要借用值来说，使用确实方便多了，那借用什么时候回收呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个借用结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDataRef</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    reference: &amp;<span class="symbol">'a</span> MyData,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的drop trait实现</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> MyDataRef&lt;<span class="symbol">'_</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping MyDataRef"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as variable"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> b = MyDataRef &#123; reference: &amp;a &#125;;</span><br><span class="line">        <span class="keyword">let</span> c = MyDataRef &#123; reference: &amp;a &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">End of the scope inside main.</span><br><span class="line">Dropping MyDataRef</span><br><span class="line">Dropping MyDataRef</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as variable"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as variable"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>在销毁借用的变量前，先销毁了所有的借用。哈哈，你可以有多个借用（准确说是<strong>不可变借用</strong>（<code>immutable borrow</code>），后边在展开），但销毁变量时，所有借用都会被一起销毁，这样保证你不是借用一个已经销毁的变量（<code>use after free</code>）</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>到这里我们都没有修改过一个变量</p><p><code>Rust</code>能像别的语言这样赋值修改么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>结果是不行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0384]: cannot assign twice to immutable variable `d`</span><br><span class="line">  --&gt; src/main.rs:<span class="number">33</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">32</span> |     <span class="keyword">let</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |         -</span><br><span class="line">   |         |</span><br><span class="line">   |         first assignment to `d`</span><br><span class="line">   |         help: consider making this binding mutable: `<span class="keyword">mut</span> d`</span><br><span class="line"><span class="number">33</span> |     d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br><span class="line">   |     ^ cannot assign twice to immutable variable</span><br></pre></td></tr></table></figure><p><code>Rust</code>对读取和修改是有区分的，像错误提示那样</p><p>需要<code>mut</code>关键字来声明变量可修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">d = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>那对应的销毁时什么样的呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> wrapper = MyData &#123;</span><br><span class="line">            data: MyString::from(<span class="string">"used as mut variable1"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        wrapper.data = MyString::from(<span class="string">"used as mut variable2"</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"[Mutable] End of the scope inside main."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"End of the scope."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dropping MyString with value: <span class="string">"used as mut variable1"</span></span><br><span class="line">[Mutable] End of the scope inside main.</span><br><span class="line">Dropping MyData with value: MyString(<span class="string">"used as mut variable2"</span>)</span><br><span class="line">Dropping MyString with value: <span class="string">"used as mut variable2"</span></span><br><span class="line">End of the scope.</span><br></pre></td></tr></table></figure><p>基本和之前不可变（<code>immutable</code>）变量销毁类似，唯一不同是赋值后，赋值前的值要被销毁，内存的管理很是细致啊。</p><p>现在说了借用，说了可变，我们可以来看看前边提到借用是有区分的：还有一个可变借用（<code>mutable borrow</code>）</p><h2 id="可变借用"><a href="#可变借用" class="headerlink" title="可变借用"></a>可变借用</h2><p>对于可变变量，是可以有对应的可变借用的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">*g = <span class="string">"world"</span>.to_string();</span><br></pre></td></tr></table></figure><p>那如果同时有可变借用和不可变借用，下边的代码可以么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> d = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> e = &amp;d;</span><br><span class="line">    <span class="keyword">let</span> f = &amp;d;</span><br><span class="line">    <span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">    *g = <span class="string">"world"</span>.to_string();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;f&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不可以</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `d` <span class="keyword">as</span> mutable because it is also borrowed <span class="keyword">as</span> immutable</span><br><span class="line"> --&gt; src/main.rs:<span class="number">5</span>:<span class="number">13</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> f = &amp;d;</span><br><span class="line">  |             -- immutable borrow occurs here</span><br><span class="line"><span class="number">5</span> |     <span class="keyword">let</span> g = &amp;<span class="keyword">mut</span> d;</span><br><span class="line">  |             ^^^^^^ mutable borrow occurs here</span><br><span class="line"><span class="number">6</span> |     *g = <span class="string">"world"</span>.to_string();</span><br><span class="line"><span class="number">7</span> |     <span class="built_in">println!</span>(<span class="string">"&#123;f&#125;"</span>);</span><br><span class="line">  |               --- immutable borrow later used here</span><br></pre></td></tr></table></figure><p>编译器明确告诉我们，可变借用的时候不能同时有不可变借用。</p><p>为什么，如果拿<strong>读写互斥锁</strong>来类比，就很好理解了，我有可变借用，就像拿到写锁，这个时候是不允许有读锁的，不然我修改和你读取不一致怎么办。</p><p>这是就得出了所有权里借用的规则：</p><ul><li><strong>不可变借用可以有多个</strong></li><li><strong>可变借用同一时间只能有一个，且和不可变借用互斥</strong></li></ul><h2 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h2><p>到此，所有权的三条原则就全部出来了</p><ul><li>值有且只有一个所有者, 且所有者离开作用域时, 值将被丢弃</li><li>所有权可转移</li><li>借用<ul><li>不可变借用可以有多个</li><li>可变借用同一时间只能有一个</li></ul></li></ul><p>这些规则，规范了对于一个变量谁持有，离开作用域是否可以释放，变量的修改和借用有什么样要求，避免释放后的内存被借用，也防止修改和读取的内容不一致有<code>race condition</code>的问题。</p><p>最厉害的是这些都是编译阶段就分析保证了的，提前暴露了问题，不然等到代码上线了遇到问题再crash，追查起来就滞后太久了。</p><p>到这所有权就结束了么？还没有，快了，再耐着性子往下看</p><h2 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h2><p>目前为止，一个借用要么是只读的要么是可写的，限制都很严格，万一我想需要写的时候再可写，平时只要一个只读的借用就可以，能搞定么？</p><p>能！</p><p>Rust提供了<code>Cell</code>（针对实现<code>Copy</code>的简单类型）<br>和<code>RefCell</code>(针对任何类型，运行时做借用检查)<br><code>Arc</code>（多线程安全的引用计数类型）等类型，来支持内部可变性。<br><code>Mutex</code>和<code>RwLock</code>也是内部可变性的一种实现，只不过是在多线程场景下的。</p><blockquote><p>Tips: 本质上可以理解为对读写互斥的不同粒度下的封装，不需要显式声明可变借用，但内部有可变的能力</p></blockquote><p>以<code>RefCell</code>为例，来看看内部可变性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">let</span> value = RefCell::new(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Mutate the value using an immutable reference</span></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">let</span> borrowed = value.borrow();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Before mutation: &#123;&#125;"</span>, *borrowed);</span><br><span class="line"><span class="built_in">drop</span>(borrowed);</span><br><span class="line"><span class="comment">// Interior mutation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> borrowed_mut = value.borrow_mut();</span><br><span class="line">    *borrowed_mut += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">let</span> borrowed = value.borrow();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"After mutation: &#123;&#125;"</span>, *borrowed);</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>终于到了最后一个话题，生命周期</p><p>下边一段简单的字符串切片的长度比较函数</p><p>你能想到它为什么编译不通过么？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(str1:  &amp;<span class="built_in">str</span>, str2: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str1.len() &gt; str2.len() &#123;</span><br><span class="line">        str1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">let</span> str2 = <span class="string">"world！"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest(str1, str2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:<span class="number">1</span>:<span class="number">39</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> | <span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(str1: &amp;<span class="built_in">str</span>, str2: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  |                  ----        ----     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function<span class="symbol">'s</span> <span class="keyword">return</span> <span class="class"><span class="keyword">type</span> <span class="title">contains</span></span> a borrowed value, but the signature does not say whether it is borrowed from `str1` or `str2`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> | <span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(str1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, str2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">  |           ++++        ++             ++          ++</span><br></pre></td></tr></table></figure><p>编译器再一次友好的提示我们，函数入参两个借用，返回值一个借用，无法确定返回值是用了哪个入参的生命周期。</p><p>一个新的概念出现了：<strong>生命周期</strong></p><p>生命周期是<code>Rust</code>用来标注引用存活周期，借此标识变量的借用与作用域是否合法，即借用是否在作用域内还有效，毕竟不能悬空指针（<code>dangling pointer</code>， 借用一个失效的内存地址）啊。</p><p>就像这里，函数返回一个借用，那返回的借用是否在作用域内合法，和入参的两个引用的关系是什么，靠的就是生命周期标注。如果入参和出参都是一个生命周期，即出参的借用在入参的借用作用域内，只要入参的生命周期合法，那出参的就是合法的。不然如果出参用了只是借用函数内部变量的生命周期，那函数返回后，函数内部变量就被销毁了，出参就是悬空指针了。</p><p>你可以简单理解为给借用多增加了一个参数，用来标识其借用在一个<code>scope</code>内使用是否合法。</p><blockquote><p>题外话，其实你如果了解<code>Golang</code>的逃逸分析，比如当函数内部变量需要返回给函数外部继续使用，其实是要扩大内部变量的作用域（即内部变量的生命周期），不能只依靠当前函数栈来保存变量，就会把它逃逸到堆上。 它做的其实也是变量的生命周期分析，用增加堆的内存开销来避免悬空指针。<br>只不过那是在gc基础上一种优化，而<code>Rust</code>则是在编译期就能通过生命周期标注就能确定借用是否合法。<br>对于想把内部变量返回给外部使用的情况，<code>Rust</code>也提供了<code>Box</code>来支持，这里就不展开了。</p></blockquote><p><strong>那是不是每个借用都要标注?</strong></p><p>也不是，rust默认会对所有借用自动标注，只有出现冲突无法自动标注的时候才需要程序员手动标注。如果感兴趣的话，可以深入看下<a href="https://doc.rust-lang.org/nomicon/subtyping.html" target="_blank" rel="noopener">Subtyping and Variance</a>，了解下生命周期的一些约束。</p><p>最后我们看下下边编译不通过的代码，从编译期的报错你就应该能明白，为什么要生命周期标注了，它对于让编译期做借用的作用域合法性检查很有用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_longest</span></span>&lt;<span class="symbol">'a</span>&gt;(str1: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, str2: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str1.len() &gt; str2.len() &#123;</span><br><span class="line">        str1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> str1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">let</span> str2 = <span class="string">"world!"</span>;</span><br><span class="line">        result = get_longest(str1.as_str(), str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `str1` does not live long enough</span><br><span class="line">  --&gt; src/main.rs:<span class="number">15</span>:<span class="number">30</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |         <span class="keyword">let</span> str1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">   |             ---- binding `str1` declared here</span><br><span class="line"><span class="number">14</span> |         <span class="keyword">let</span> str2 = <span class="string">"world!"</span>;</span><br><span class="line"><span class="number">15</span> |         result = get_longest(str1.as_str(), str2);</span><br><span class="line">   |                              ^^^^^^^^^^^^^ borrowed value does not live long enough</span><br><span class="line"><span class="number">16</span> |     &#125;</span><br><span class="line">   |     - `str1` dropped here <span class="keyword">while</span> still borrowed</span><br><span class="line"><span class="number">17</span> |</span><br><span class="line"><span class="number">18</span> |     <span class="built_in">println!</span>(<span class="string">"The longest string is: &#123;&#125;"</span>, result);</span><br><span class="line">   |                                           ------ borrow later used here</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，收个尾吧：</p><ul><li>所有权关注的是值的拥有和管理</li><li>借用检查器在编译时保证借用的有效性和安全性</li><li>生命周期关注的是借用的有效范围和引用的合法性</li></ul><p>他们配合在一起，构建起了<code>Rust</code>强大的内存管理能力。避免了内存泄漏和悬空指针的问题，也避免了<code>GC</code>带来的性能问题。</p><p>怎么样？是不是感觉<code>Rust</code>的所有权设计还挺有意思的？一个所有权把内存管理的清晰又明了！</p><p>欢迎有问题的朋友留言讨论。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      掌握Rust：从零开始的所有权之旅
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="ownership" scheme="https://newbmiao.github.io/tags/ownership/"/>
    
      <category term="borrow" scheme="https://newbmiao.github.io/tags/borrow/"/>
    
      <category term="lifetime" scheme="https://newbmiao.github.io/tags/lifetime/"/>
    
  </entry>
  
  <entry>
    <title>代码是负债，而不是资产</title>
    <link href="https://newbmiao.github.io/2023/08/12/seeing-code-as-debt-not-value.html"/>
    <id>https://newbmiao.github.io/2023/08/12/seeing-code-as-debt-not-value.html</id>
    <published>2023-08-12T10:19:54.000Z</published>
    <updated>2023-08-22T02:55:23.062Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《Google软件工程》，其中有一句话让我印象深刻：<br>代码是负债，而不是资产。</p><p>然而作为程序员，相信很多人都认为自己的代码就是资产，是自己智慧的结晶，怎么会是负债呢？</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><p>首先这个当然是要限定在软件工程领域来讨论。</p><p>在软件工程领域，代码的构建是要花费时间和人力成本的，但代码并不因此就能算作资产，真正有价值的是代码所要解决的产品问题，给用户和公司带来的价值。</p><p>而且写好的代码也是需要长期维护，长期运行的，而不是一次性的。<br>虽然维护的时间或长或短，决定于其服务的产品的生命。</p><p>所以代码是有维护成本的，就像负债，在没还清前，是需要源源不断的投入的。</p><p>我觉得这其实才道出了代码的本质。</p><p>为什么软件工程领域围绕代码有那么多方法论？</p><p>结对编程，代码评审，代码风格指南，测试驱动开发，设计文档评审，流水线集成和发布，清理技术负债，等等。</p><p>身处其中的程序员当然知道这是为了保证代码质量，但仅仅就是这样么？</p><p>要是从一开始就明白代码是负债，这一切就好理解了。</p><p>因为代码是需要维护的，不合理维护的代码就会像逐渐发霉的苹果，早晚有一天变成人人厌恶的坏代码，那些你眼里讨厌的legacy。</p><p>所以从一开始，代码就应该结合产品生命周期的规划，明白构建的代码将会存活大概多长时间。基于此再去设计，去实现，去计划相应的代码维护方案。</p><p>前期合适的流程能构建出当下场景合理的代码，避免代码一开始就腐烂。</p><p>但重要的是，团队能一开始就意识到代码需要长期合理的维护。</p><p>不会因为新需求的交付，而忽视那些将要后已经有问题但没人问津的技术负债。毕竟负债分散到日常去处理成本远远要小于最后一次偿还。</p><p>而且，当代码不能很好的服务产品的时候，要考虑何时弃用，将负债彻底清理。这反而是很多团队会忽略的东西。</p><p>不过有人就说，代码不用了不清理可以么？好像也没什么问题是不。</p><p>等遗留的旧代码依旧被别的代码引用，新老服务代码还有一些纠缠剪不断，代码仓库变得越来越臃肿，代码缺陷检查通不过，到时候开始抱怨的你猜会是谁？</p><p>到这里，你有没有发现，代码永远是程序员的负债，如果你自己还混不自知的话，最后很容易把自己搅入泥潭。</p><p>那个时候你能怪PM或者EM没有给你规划技术负债的清理维护么？</p><p>可能他们也知道，但是他们的屁股更关心的是需求的交付，产品的迭代。</p><p>而你有没有提前识别出代码负债的问题，有没有把技术负债也加入到日常交付中，是你要关心和负责的事情。</p><p>以前觉得软件工程都是些虚头巴脑的东西，不如写代码实在。</p><p>现在慢慢觉得写代码确实实在，但那些“虚头巴脑”的东西反而更考验一个程序员的能力。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      代码是负债，而不是资产
    
    </summary>
    
    
      <category term="thoughts" scheme="https://newbmiao.github.io/categories/thoughts/"/>
    
      <category term="software-engineering" scheme="https://newbmiao.github.io/categories/thoughts/software-engineering/"/>
    
    
      <category term="thoughts" scheme="https://newbmiao.github.io/tags/thoughts/"/>
    
      <category term="software-engineering" scheme="https://newbmiao.github.io/tags/software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>深入解读-如何用keycloak管理external auth</title>
    <link href="https://newbmiao.github.io/2023/06/18/auth-manage-via-keycloak.html"/>
    <id>https://newbmiao.github.io/2023/06/18/auth-manage-via-keycloak.html</id>
    <published>2023-06-18T14:10:20.000Z</published>
    <updated>2023-08-22T02:56:08.831Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>提到<code>OAuth2</code>，大家多少都有些了解。</p><blockquote><p>不了解的话可以先看下之前的<a href="http://blog.newbmiao.com/2021/09/19/tech-behind-authentication.html">简单聊聊鉴权背后的那些技术</a>先回顾一下基本概念和流程。</p></blockquote><p>简单来说，以<code>google</code>授权为例，一般就是通过用户授权页面登录<code>google</code>账号，再跳转用<code>code</code>换取到相应权限的<code>token</code>，就可以代表用户去发起一些<code>google api</code>的请求。</p><p>直接代码实现这套授权逻辑并不复杂，不过如果还需要接入<code>facebook</code>授权，<code>instagram</code>授权呢，总不能挨个去实现一遍吧。</p><p>最好能有一套通用的解决方案来解放双手， 今天我们就聊聊如何用<code>keycloak</code>实现一套通用的身份验证和授权管理方案。</p><blockquote><p>提前说明，无法本地复刻的技术方案不利于理解，也不利于方案探讨。虽然本文章所用代码是使用了<code>rust</code>的<code>axum</code>框架（为啥？因为<code>rust</code> is future！）+<code>keycloak</code>，但从服务启动到<code>keycloak</code>服务及相关配置，都用<code>docker-compose+terraform+shell</code> 脚本化管理，可100%本地复刻，欢迎本地尝试。（当然我说的是<code>Mac</code>下）代码地址： <a href="https://github.com/NewbMiao/axum-koans" target="_blank" rel="noopener">https://github.com/NewbMiao/axum-koans</a></p></blockquote><a id="more"></a><h2 id="初探OAuth"><a href="#初探OAuth" class="headerlink" title="初探OAuth"></a>初探<code>OAuth</code></h2><p>在引入<code>keycloak</code>之前我们以<code>google</code>为例先看下常规<code>OAuth</code>怎么接入，方便后边和<code>keycloak</code>接入对比。</p><blockquote><p>前置工作： 获取<code>google OAuth application</code>的<code>clientId</code>和<code>clientSecret</code>，不清楚的话，可以参考 <strong>Create a Google Application</strong> in <a href="https://keycloakthemes.com/blog/how-to-setup-sign-in-with-google-using-keycloak" target="_blank" rel="noopener">How to setup Sign in with Google using Keycloak</a></p></blockquote><p>如下图，一般授权流程（<code>standard flow</code>）中客户端和<code>auth server</code>主要是两个阶段</p><ul><li>生成<code>auth url</code>跳转登录后请求换取授权令牌的<code>code</code></li><li>在<code>auth callback</code>中用<code>code</code>换取<code>token</code>，得到能代表用户的<code>credentials</code>，一般是<code>accessToken</code></li></ul><p><img src="https://blog.postman.com/wp-content/uploads/2020/06/image5.png" alt="Authorization Code flow for OAuth"></p><p>这个流程自己也可以实现，但一般都用<code>oidc client</code>（其实现了<code>OpenID connect</code>协议，是建立在<code>OAuth2.0</code>上的身份验证协议，用来为应用提供用户身份信息）来实现。</p><p>编程语言实现上大同小异，下边代码以<code>rust</code>的<code>oauth2</code>库为例讲解</p><p>如果不熟悉<code>rust</code>，可以重点看<strong>代码注释</strong>，也不影响理解</p><h3 id="初始化oidc-client"><a href="#初始化oidc-client" class="headerlink" title="初始化oidc client"></a>初始化<code>oidc client</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::new</span></span><br><span class="line"><span class="comment">// 注册auth server 的授权登录地址，授权时会生成带有相应参数的 auth url</span></span><br><span class="line"><span class="keyword">let</span> auth_url =</span><br><span class="line">    AuthUrl::new(<span class="string">"https://accounts.google.com/o/oauth2/v2/auth"</span>.to_string()).unwrap();</span><br><span class="line"><span class="comment">// 注册auth server 的授权登录成功后要跳转到的客户端地址（auth callback url），会携带code</span></span><br><span class="line"><span class="keyword">let</span> redirect_url = RedirectUrl::new(config.redirect_url).unwrap();</span><br><span class="line"><span class="comment">// 注册auth server 的code换取token的地址</span></span><br><span class="line"><span class="keyword">let</span> token_url =</span><br><span class="line">    TokenUrl::new(<span class="string">"https://www.googleapis.com/oauth2/v3/token"</span>.to_string()).unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = BasicClient::new(</span><br><span class="line">    <span class="comment">// 注册google application client credentials, 会有相应权限和客户端限制，如web application类型会有访问地址origin及callback地址的白名单限制</span></span><br><span class="line">    ClientId::new(config.client_id),</span><br><span class="line">    <span class="literal">Some</span>(ClientSecret::new(config.client_secret)),</span><br><span class="line">    auth_url,</span><br><span class="line">    <span class="literal">Some</span>(token_url),</span><br><span class="line">)</span><br><span class="line">.set_redirect_uri(redirect_url);</span><br></pre></td></tr></table></figure><h3 id="生成auth-url"><a href="#生成auth-url" class="headerlink" title="生成auth url"></a>生成auth url</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::auth_url</span></span><br><span class="line"><span class="keyword">let</span> (url, csrf_token) = client</span><br><span class="line">    <span class="comment">// 参数是用于生成state的函数，这里用csrftoken,可以在auth callback中校验state参数是否合法</span></span><br><span class="line">    .authorize_url(CsrfToken::new_random)</span><br><span class="line">    <span class="comment">// auth请求需要的权限（scope）,一般获取用户信息的话，profile和email就好了</span></span><br><span class="line">    .add_scope(Scope::new(</span><br><span class="line">        <span class="string">"https://www.googleapis.com/auth/userinfo.profile"</span>.to_string(),</span><br><span class="line">    ))</span><br><span class="line">    .add_scope(Scope::new(</span><br><span class="line">        <span class="string">"https://www.googleapis.com/auth/userinfo.email"</span>.to_string(),</span><br><span class="line">    ))</span><br><span class="line">    <span class="comment">// 需要显示OAuth需要授权的内容给用户来确认是否同意，就是我们常见的google授权确认页面</span></span><br><span class="line">    .add_extra_param(<span class="string">"prompt"</span>, <span class="string">"consent"</span>)</span><br><span class="line">    <span class="comment">// 允许应用程序获得长期有效的访问令牌（accessToken）和刷新令牌(refreshToken)</span></span><br><span class="line">    .add_extra_param(<span class="string">"access_type"</span>, <span class="string">"offline"</span>)</span><br><span class="line">    .url();</span><br></pre></td></tr></table></figure><p>这里参数<code>access_type=offline</code>对于应用需要长期<code>accessToken</code>是很关键的。一般<code>accessToken</code>都有过期时间，如果没有有效的<code>refreshToken</code>来刷新<code>accessToken</code>，就会有<code>accessToken</code>失效后还要用户再登录的尴尬局面-_-!</p><p>另外为安全考虑除了可以用<code>state</code>做请求合法校验，还可以用<a href="https://blog.postman.com/pkce-oauth-how-to" target="_blank" rel="noopener"><code>PKCE(Proof Key for Code Exchange)</code></a>来加强, 实际用到的代码有实现，感兴趣可以看下</p><h3 id="auth-callback换取token"><a href="#auth-callback换取token" class="headerlink" title="auth callback换取token"></a>auth callback换取token</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::get_tokens</span></span><br><span class="line"><span class="comment">// 校验请求，state及pkce, 这里省略展示</span></span><br><span class="line"><span class="comment">// code 换取token</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> res = client.exchange_code(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求发送，axum中不能使用block请求，防止阻塞框架的异步事件循环</span></span><br><span class="line"><span class="keyword">let</span> res = res.request_async(async_http_client).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line"><span class="literal">Ok</span>(TokenInfo &#123;</span><br><span class="line">    refresh_token: res.refresh_token().unwrap().secret().to_string(),</span><br><span class="line">    access_token: res.access_token().secret().to_string(),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这部分不复杂，按文档配好本地，可以访问<code>http://localhost:8000/google/auth</code>来尝试上述<code>flow</code></p><h2 id="使用keycloak-IDP"><a href="#使用keycloak-IDP" class="headerlink" title="使用keycloak IDP"></a>使用keycloak IDP</h2><h3 id="keycloak-配置"><a href="#keycloak-配置" class="headerlink" title="keycloak 配置"></a>keycloak 配置</h3><p>上边流程怎么让keycloak这个身份和访问管理系统接管呢，答案是使用<code>keycloak IDP</code> (<code>Identity provider</code>)</p><p>我们先看下需要如何配置相应配置，这里先用<a href="https://registry.terraform.io/providers/mrparkers/keycloak/latest/docs" target="_blank" rel="noopener"><code>terraform - keycloak provider</code></a> 展示下配置。</p><blockquote><p>等效的页面配置可以后边参考之前的链接 <a href="https://keycloakthemes.com/blog/how-to-setup-sign-in-with-google-using-keycloak" target="_blank" rel="noopener">How to setup Sign in with Google using Keycloak</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 这里使用默认的admin-cli配置keycloak</span><br><span class="line"># 也可生成一个专门的client，用clientId+clientSecret的方式</span><br><span class="line">provider &quot;keycloak&quot; &#123;</span><br><span class="line">  client_id &#x3D; &quot;admin-cli&quot;</span><br><span class="line">  url       &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&quot;</span><br><span class="line">  username  &#x3D; &quot;***&quot;</span><br><span class="line">  password  &#x3D; &quot;***&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 1. 创建一个realm（领域），并启用, 类似命名空间，代表一个安全的独立区域</span><br><span class="line">resource &quot;keycloak_realm&quot; &quot;realm_axum_koans&quot; &#123;</span><br><span class="line">  realm   &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  enabled &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 2. 添加google idp， 这里需要google client credentials</span><br><span class="line"></span><br><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  realm         &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  # client_id和secret通过环境变量获取</span><br><span class="line">  client_id     &#x3D; var.google_client_id</span><br><span class="line">  client_secret &#x3D; var.google_client_secret</span><br><span class="line">  trust_email   &#x3D; true</span><br><span class="line">  # &quot;*&quot; 则不约束使用此idp的domain</span><br><span class="line">  hosted_domain &#x3D; &quot;*&quot;</span><br><span class="line">  sync_mode     &#x3D; &quot;IMPORT&quot;</span><br><span class="line">  provider_id   &#x3D; &quot;google&quot;</span><br><span class="line"></span><br><span class="line">  default_scopes &#x3D; &quot;openid profile email&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 3. 添加将要用来google auth打交道的client</span><br><span class="line">resource &quot;keycloak_openid_client&quot; &quot;client_axum_koans&quot; &#123;</span><br><span class="line">  realm_id &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  name     &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  enabled  &#x3D; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  client_id             &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  client_secret         &#x3D; &quot;***&quot;</span><br><span class="line">  standard_flow_enabled &#x3D; true</span><br><span class="line"></span><br><span class="line">  access_type &#x3D; &quot;CONFIDENTIAL&quot;</span><br><span class="line">  # 配置auth callback url</span><br><span class="line">  valid_redirect_uris &#x3D; [</span><br><span class="line">    &quot;http:&#x2F;&#x2F;localhost:8000&#x2F;keycloak&#x2F;login-callback&quot;</span><br><span class="line">  ]</span><br><span class="line">  web_origins        &#x3D; [&quot;*&quot;]</span><br><span class="line">  use_refresh_tokens &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看代码版的配置稍微有点多，主要配置其实就只有注释里的三处，然后google OAuth的代理设置就完成了，不信我们继续往下看怎么代码接入</p><h3 id="keycloak-auth接入"><a href="#keycloak-auth接入" class="headerlink" title="keycloak auth接入"></a>keycloak auth接入</h3><p>上边<code>keycloak</code>配置了<code>realm</code>，后边授权和<code>token</code>获取都会和这个<code>realm</code>下的<code>issueUrl</code>打交道，这里<code>issueUrl</code>就类似<code>google</code>的<code>auth server</code> 地址。 </p><ol><li>初始化<code>keycloak oidc client</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::new</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们配置生成的issue_url将会是： http://localhost:8080/realms/axum-koans</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置token url, auth url 和auth callback url(redirect url)</span></span><br><span class="line"><span class="keyword">let</span> token_url = TokenUrl::new(get_url_with_issuer(</span><br><span class="line">    &amp;config.issuer_url,</span><br><span class="line">    <span class="string">"/protocol/openid-connect/token"</span>,</span><br><span class="line">))</span><br><span class="line">.unwrap();</span><br><span class="line"><span class="keyword">let</span> auth_url = AuthUrl::new(get_url_with_issuer(</span><br><span class="line">    &amp;config.issuer_url,</span><br><span class="line">    <span class="string">"/protocol/openid-connect/auth"</span>,</span><br><span class="line">))</span><br><span class="line">.unwrap();</span><br><span class="line"><span class="keyword">let</span> redirect_url = RedirectUrl::new(config.redirect_url).unwrap();</span><br><span class="line"><span class="keyword">let</span> client = BasicClient::new(client_id, <span class="literal">Some</span>(client_secret), auth_url, <span class="literal">Some</span>(token_url))</span><br><span class="line">    .set_redirect_uri(redirect_url);</span><br></pre></td></tr></table></figure><ol start="2"><li>生成<code>auth_url</code></li></ol><p>方法基本和之前<code>google</code>配置一模一样。</p><p>这里也能看出为啥需要<code>oidc</code>协议，其实就是抽象化，提供了一种安全、标准化和可扩展的身份验证和授权协议。它简化了应用程序中的身份管理和访问控制，提供了一致的用户登录体验，并提高了应用程序的安全性。</p><p>这里<code>auth url</code>默认跳转的是<code>keycloak</code>登录页面，然后<code>google idp</code>是作为一种登录选项让用户选择。但如果就打算让用户直接<code>google</code>登录，可以跳过<code>keycloak</code>登录页。</p><p>方法是使用客户端建议的<code>idp（kc_idp_hint）</code>:<a href="https://www.keycloak.org/docs/latest/server_admin/#_client_suggested_idp" target="_blank" rel="noopener"><code>Client-suggested Identity Provider</code></a></p><p>这样就可以直接使用指定的<code>idp</code>进行授权登录</p><p>代码如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::auth_url</span></span><br><span class="line">client.add_extra_param(<span class="string">"kc_idp_hint"</span>, <span class="string">"google"</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li><code>auth callback</code>换取<code>token</code></li></ol><p>方法也同 <code>google auth callback</code>, 这里不赘述了。</p><p>不过这里拿到的是<code>keycloak</code>的<code>token</code>。要是需要<code>google</code>的<code>token</code>怎么办？</p><p>别急，有两种办法。</p><h2 id="方法一：-token-exchange"><a href="#方法一：-token-exchange" class="headerlink" title="方法一： token-exchange"></a>方法一： token-exchange</h2><p><a href="https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange" target="_blank" rel="noopener"><code>token-exchange</code></a> 是用于<code>token</code>交换场景，我们这里是用<code>keycloak token</code>换取外部<code>google token</code>（<code>external token</code>）</p><h3 id="相应keycloak配置"><a href="#相应keycloak配置" class="headerlink" title="相应keycloak配置"></a>相应<code>keycloak</code>配置</h3><blockquote><p><code>token-exchange</code>目前还是<code>keycloak</code>预览（<code>preview</code>）功能，需要至少在<code>features</code>中启用<code>admin-fine-grained-authz,token-exchange</code>才可使用(详见<code>keycloak docker-composer</code>配置 )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启用idp获取refresh token</span><br><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">  # for token exchange to get google access token</span><br><span class="line">  request_refresh_token &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启用 idp token exchange permission, 并用policy关联对应的client</span><br><span class="line">resource &quot;keycloak_identity_provider_token_exchange_scope_permission&quot; &quot;oidc_idp_permission&quot; &#123;</span><br><span class="line">  realm_id       &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  provider_alias &#x3D; keycloak_oidc_google_identity_provider.google.alias</span><br><span class="line">  policy_type    &#x3D; &quot;client&quot;</span><br><span class="line">  clients &#x3D; [</span><br><span class="line">    keycloak_openid_client.client_axum_koans.id</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> token_url =</span><br><span class="line">   <span class="built_in">format!</span>( <span class="string">"&#123;&#125;/protocol/openid-connect/token"</span>,&amp;<span class="keyword">self</span>.config.issuer_url);</span><br><span class="line"><span class="keyword">let</span> response = Client::new()</span><br><span class="line">    .post(token_url)</span><br><span class="line">    .form(&amp;[</span><br><span class="line">        <span class="comment">// token exchange type</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"grant_type"</span>,</span><br><span class="line">            <span class="string">"urn:ietf:params:oauth:grant-type:token-exchange"</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 传入keycloak access token</span></span><br><span class="line">        (<span class="string">"subject_token"</span>, &amp;access_token),</span><br><span class="line">        (<span class="string">"client_id"</span>, &amp;<span class="keyword">self</span>.config.client_id),</span><br><span class="line">        (<span class="string">"client_secret"</span>, &amp;<span class="keyword">self</span>.config.client_secret),</span><br><span class="line">        <span class="comment">// 请求换取google access token</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"requested_token_type"</span>,</span><br><span class="line">            <span class="string">"urn:ietf:params:oauth:token-type:access_token"</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 要换取的external idp: google</span></span><br><span class="line">        (<span class="string">"requested_issuer"</span>, <span class="string">"google"</span>),</span><br><span class="line">    ])</span><br><span class="line">    .send()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"><span class="comment">// json deserialized as access token</span></span><br><span class="line"><span class="literal">Ok</span>(from_str(&amp;response.text().<span class="keyword">await</span>?)?)</span><br></pre></td></tr></table></figure><p>这样就获取到了可用的<code>google access token</code>， 实际上内部是通过<code>google refresh token</code>换取到的。</p><p>这样常规请求没问题了，只要你有<code>keycloak access token</code>, 就能换取到<code>google access token</code>来请求<code>google api</code>。so easy?!</p><h2 id="方法二：broker-读取-stored-token"><a href="#方法二：broker-读取-stored-token" class="headerlink" title="方法二：broker 读取 stored token"></a>方法二：broker 读取 stored token</h2><p>然而，要是需要<code>google refresh token</code>怎么办？</p><p>有些场景是客户端需要自己通过<code>google refresh token</code>换取<code>access token</code>来发起请求的，难道这个时候客户端先去拿个<code>keycloak access token</code>么。。。？</p><p>这就可以用<a href="https://www.keycloak.org/docs/latest/server_admin/#retrieving-external-idp-tokens" target="_blank" rel="noopener">Retrieving external IDP tokens</a></p><p>底层实现是授权时存储了<code>external token</code>,再配合添加<code>broker read token</code>权限给生成的用户，就可以用<code>keycloak access token</code>换取存储的<code>external access token + refresh token</code>.</p><h3 id="相应keycloak配置-1"><a href="#相应keycloak配置-1" class="headerlink" title="相应keycloak配置"></a>相应keycloak配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">  # for retrieve idp token (with refresh token)</span><br><span class="line">  &#x2F;&#x2F; 存储idp token</span><br><span class="line">  store_token                   &#x3D; true</span><br><span class="line">  &#x2F;&#x2F; 用户生成是添加broker read token 权限</span><br><span class="line">  add_read_token_role_on_create &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题外话：这里<code>add_read_token_role_on_create</code>对应的配置在21.1.1版<code>keycloak admin</code>页面没有，但<code>admin api</code>确可以设置，也是很tricky</p></blockquote><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>就是直接换取<code>refresh_token</code>, 请求地址指明对应的<code>idp</code>即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::get_idp_token</span></span><br><span class="line"><span class="keyword">let</span> token_url = <span class="built_in">format!</span>( <span class="string">"&#123;&#125;/broker/google/token"</span>,&amp;<span class="keyword">self</span>.config.issuer_url);</span><br><span class="line"><span class="keyword">let</span> response = Client::new()</span><br><span class="line">    .get(token_url)</span><br><span class="line">    .bearer_auth(access_token)</span><br><span class="line">    .header(CONTENT_TYPE, HeaderValue::from_static(<span class="string">"application/json"</span>))</span><br><span class="line">    .send()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> res = response.text().<span class="keyword">await</span>?;</span><br><span class="line"><span class="literal">Ok</span>(from_str(&amp;res)?)</span><br></pre></td></tr></table></figure><blockquote><p>题外话：当然直接给用户这么获取<code>refresh token</code>的能力并不安全，还需要考虑对<code>broker read token</code>接口的访问约束等来更好的保证安全<code>token</code>换取。</p></blockquote><p>上边<code>keycloak</code>授权方案可以本地配好环境后，用<a href="http://localhost:8000/keycloak/login" target="_blank" rel="noopener">http://localhost:8000/keycloak/login</a> 来尝试。</p><hr><p>好了，<code>keycloak</code>如何管理<code>external auth</code>到这里就结束了。以上是我在使用<code>keycloak</code>的一些摸索和思考，欢迎大家一起探讨。</p><p>再次附上本文的代码地址以供验证：<a href="https://github.com/NewbMiao/axum-koans" target="_blank" rel="noopener">https://github.com/NewbMiao/axum-koans</a></p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      深入解读-如何用keycloak管理external auth
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
      <category term="OIDC" scheme="https://newbmiao.github.io/categories/rust/OIDC/"/>
    
      <category term="oauth2" scheme="https://newbmiao.github.io/categories/rust/OIDC/oauth2/"/>
    
    
      <category term="terraform" scheme="https://newbmiao.github.io/tags/terraform/"/>
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="oauth2" scheme="https://newbmiao.github.io/tags/oauth2/"/>
    
      <category term="OIDC" scheme="https://newbmiao.github.io/tags/OIDC/"/>
    
      <category term="axum" scheme="https://newbmiao.github.io/tags/axum/"/>
    
      <category term="keycloak" scheme="https://newbmiao.github.io/tags/keycloak/"/>
    
      <category term="token-exchange" scheme="https://newbmiao.github.io/tags/token-exchange/"/>
    
      <category term="google-idp" scheme="https://newbmiao.github.io/tags/google-idp/"/>
    
  </entry>
  
  <entry>
    <title>如何在docker中缓存加速Rust依赖构建</title>
    <link href="https://newbmiao.github.io/2021/11/21/cache-rust-dependencies-with-docker-build.html"/>
    <id>https://newbmiao.github.io/2021/11/21/cache-rust-dependencies-with-docker-build.html</id>
    <published>2021-11-21T09:14:23.000Z</published>
    <updated>2023-06-18T00:52:29.957Z</updated>
    
    <content type="html"><![CDATA[<!-- [TOC] --><p>最近开始学习《陈天 · Rust 编程第一课》，在用<code>docker</code>镜像打包构建代码示例时，每次都会在更新<code>crate.io</code>索引上等上一会，即便在没有修改<code>Cargo.tomal</code>依赖的前提下。</p><p>想着难道没有办法缓存下更新么，于是就有了这篇新手踩坑指南。</p><a id="more"></a><h2 id="本地缓存-失败"><a href="#本地缓存-失败" class="headerlink" title="本地缓存 - 失败"></a>本地缓存 - 失败</h2><p>查阅有在<code>docker</code>中指定<code>CARGO_HOME</code>到宿主机来缓存<code>crate.io</code>索引</p><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --user "$(id -u)":"$(id -g)" -v "$PWD":/usr/src/myapp -w /usr/src/myapp -e CARGO_HOME=".cargo" rust cargo run</span><br></pre></td></tr></table></figure><p>结果，镜像run失败了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   Compiling libc v0.2.107</span><br><span class="line">   Compiling autocfg v1.0.1</span><br><span class="line">   Compiling siphasher v0.3.7</span><br><span class="line">   Compiling unicode-xid v0.2.2</span><br><span class="line">   Compiling memchr v2.4.1</span><br><span class="line">   Compiling lazy_static v1.4.0</span><br><span class="line">   Compiling ppv-lite86 v0.2.15</span><br><span class="line">   Compiling pin-project-lite v0.2.7</span><br><span class="line">   Compiling pkg-config v0.3.22</span><br><span class="line">error: failed to build archive: Input/output error</span><br><span class="line"></span><br><span class="line">error: error writing dependencies to `/usr/src/myapp/.target/debug/deps/pkg_config-8dafe7024c916ac6.d`: Input/output error (os error 5)</span><br></pre></td></tr></table></figure><p>一番查阅，应该是环境不一致时<code>pkg-config</code>编译时链接库有问题，详见 <a href="https://ttys3.dev/post/rust-cross-compile-darwin-target-troubleshooting/" target="_blank" rel="noopener">Rust 交叉编译 OSX 二进制失败原因分析</a> 和 <a href="https://stackoverflow.com/a/49173699/4431337" target="_blank" rel="noopener">Unable to run a Docker image with a Rust executable</a></p><h2 id="镜像缓存-成功"><a href="#镜像缓存-成功" class="headerlink" title="镜像缓存 - 成功"></a>镜像缓存 - 成功</h2><p>然后就搜到了这篇<a href="https://stackoverflow.com/a/58474618/4431337" target="_blank" rel="noopener">cache-rust-dependencies-with-docker-build</a></p><p>真是非常tricky！</p><p>思想很简单，就是缓存要在依赖不变的前提下，而docker build时源代码更改会使缓存的<code>docker layer</code>失效。</p><p>那就先用一个不会变得源代码编译依赖，编译好依赖缓存layer，再文件替换到实际代码，重新进行编译就正常运行加缓存两不误了。</p><p>具体构建方式如下：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> rust</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"fn main() &#123;&#125;"</span> &gt; dummy.rs</span></span><br><span class="line"><span class="keyword">ARG</span> SRC_DIR</span><br><span class="line"><span class="keyword">ENV</span> SRC_DIR=$&#123;SRC_DIR:-&#125;</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;SRC_DIR&#125;</span>/Cargo.toml .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s#src/main.rs#dummy.rs#'</span> Cargo.toml</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cargo build --release</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s#dummy.rs#src/main.rs#'</span> Cargo.toml</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;SRC_DIR&#125;</span>/. .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cargo build --release</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"target/release/app"</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>这里构建参数<code>SRC_DIR</code>是为了指定不同代码，复用同一个<code>Dockerfile</code></p></blockquote><p>相应的<code>Cargo.toml</code>指定打包的程序名和路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[bin]]</span><br><span class="line">name = "app"</span><br><span class="line">path = "src/main.rs"</span><br></pre></td></tr></table></figure><p>打包和运行则可以一行命令搞定：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run.sh</span></span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">WORKSPACE=$(cd <span class="string">"$(dirname "</span>$<span class="number">0</span><span class="string">")"</span> &amp;&amp; pwd -P)</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --rm -it <span class="string">"<span class="variable">$(docker build --build-arg SRC_DIR="$SRC_DIR" -q "$WORKSPACE" -t "rust-$SRC_DIR")</span>"</span> <span class="comment">#"$@"</span></span></span><br></pre></td></tr></table></figure><p>运行时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> eg：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SRC_DIR=scrape_url sh run.sh https://www.rust-lang.org/ rust.md</span></span><br></pre></td></tr></table></figure><p>完美缓存了依赖更新，可以继续学习了</p><p>另外也推荐下陈天老师的rust课，由浅入深，感兴趣的同学可以试试</p><p><img src="http://media.newbmiao.com/assets/rust.jpeg" alt="陈天 · Rust 编程第一课"></p><blockquote><p>本文代码示例详见<a href="https://github.com/NewbMiao/rust-koan" target="_blank" rel="noopener">rust-koan</a></p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      cache-rust-dependencies-with-docker-build
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="docker" scheme="https://newbmiao.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊鉴权背后的那些技术</title>
    <link href="https://newbmiao.github.io/2021/09/19/tech-behind-authentication.html"/>
    <id>https://newbmiao.github.io/2021/09/19/tech-behind-authentication.html</id>
    <published>2021-09-19T15:00:09.000Z</published>
    <updated>2023-06-18T15:04:08.040Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>最近弄了一个<code>keycloak</code>鉴权相关demo(地址附文末)， 可以让不熟悉的<code>keycloak</code>的同学有一个快速、直观的了解。</p><p>今天结合背后的技术概念，简单聊聊：鉴权（<code>authentication</code>）和授权（<code>authorization</code>）以及<code>Oauth2</code>、<code>OpenID Connect</code>、<code>JWT</code> 和 <code>JWKS</code>。</p><a id="more"></a><h2 id="鉴权-VS-授权"><a href="#鉴权-VS-授权" class="headerlink" title="鉴权 VS 授权"></a>鉴权 VS 授权</h2><p>这两个概念的英文太相近，真是傻傻分不清，不过中文还好。</p><p>鉴权（<code>Authentication</code>, 也作<code>AuthN</code>）：判断你是谁，通过密码或者授权码之类凭证</p><p>授权（<code>Authorization</code>，也作<code>AuthZ</code>）：授权用户或角色等访问资源的权限，</p><p>如下图：</p><p><img src="https://www.okta.com/sites/default/files/styles/1640w_scaled/public/media/image/2020-10/Authentication_vs_Authorization.png?itok=uBFRCfww" alt="Authentication VS Authorization"></p><p>举例来说会更清晰：</p><p>假如你需要让A帮忙喂宠物，你给A了一个一次性的密码Key让其可以通过你家门禁（鉴权）。<br>但A进去后，只有到厨房拿宠物粮和客厅喂宠物，不能到其他房间则是其持有密码Key的权限（授权）</p><h2 id="Oauth2"><a href="#Oauth2" class="headerlink" title="Oauth2"></a>Oauth2</h2><p><code>Oauth2</code>是一个授权的协议，为客户端授权提供了一系列授权的流程来获取授权的访问令牌（<code>AccessToken</code>），比如</p><ul><li><code>Authorization Code flow</code><br>需要提供注册的clientID和clientSecret<br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image5.png" alt="Authorization Code flow"></li><li><del><code>Implicit flow</code></del><br>省掉了<code>Code</code>环节, 放松了对客户端的校验，牺牲安全性来提高效率，<strong>已不推荐</strong><br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image1.png" alt="Implicit flow"></li><li><code>Authorization Code flow (with PKCE)</code><br>需要提供注册的clientID和即时生成的 <code>code challenge</code>（像一次性的secret，不可被篡改）<br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image6.png" alt="PKCE flow"></li></ul><p>为什么需要<code>Oauth2</code>?</p><p>还拿喂宠物的例子来说，你找代理喂宠物，不会想把自己的密码直接给他，那太不安全，需要一个安全的机制来临时授予尽量少的权限给代理方。</p><h2 id="OpenID-connect-OIDC"><a href="#OpenID-connect-OIDC" class="headerlink" title="OpenID connect (OIDC)"></a>OpenID connect (OIDC)</h2><p><code>OIDC</code>是在<code>Oauth2</code>协议基础上扩展的认证层，提供ID令牌（<code>IDToken</code>）可以让客户端通过认证来识别用户.</p><p>应该是当今最常用的鉴权实现协议，有很多相关实现的通用类库。</p><h2 id="JWT-amp-amp-JWKS"><a href="#JWT-amp-amp-JWKS" class="headerlink" title="JWT &amp;&amp; JWKS"></a>JWT &amp;&amp; JWKS</h2><p>上边提到的<code>AccessToken</code>和<code>IDToken</code>都是用<code>Json Web Token（JWT）</code>技术来实现的。</p><p><code>JWT</code>分为三段（<code>.</code>分隔，各自<code>base64Url</code>编码）</p><ul><li>header<br>包含如签名算法<code>alg</code>，签名公钥ID <code>kid</code>, 类型等</li><li>payload<br>包含令牌签发相关数据如签发人<code>iss</code>，过期时间<code>exp</code>,签发时间<code>iat</code>等，及自定义的数据如权限及用户标识等<br>具体token所携带的信息可以通过<a href="https://jwt.io/" target="_blank" rel="noopener">jwt.io</a>来查看</li><li>signature<br>token前两部分的签名，防止被篡改</li></ul><p>这里校验可以用签名的公钥,可以在<code>JSON Web Key Set（JWKS）</code>中通过<code>header</code>的公钥id<code>kid</code>和<code>payload</code>的签发服务<code>iss</code>的配置服务中（<code>/.well-known/openid-configuration</code>）找到。</p><p>如demo中:</p><ul><li>签发服务（<code>iss</code>)<br><code>http://localhost/auth/realms/myrealm</code></li><li>配置发现（<code>discovery configuration</code>)<br><code>http://localhost/auth/realms/myrealm/.well-known/openid-configuration</code></li><li><code>JWK</code>公钥配置(<code>jwks_uri</code>)<br><code>http://localhost/auth/realms/myrealm/protocol/openid-connect/certs</code></li></ul><h2 id="Keycloak"><a href="#Keycloak" class="headerlink" title="Keycloak"></a>Keycloak</h2><p>说这么一圈，回到demo的主题，<code>keycloak</code>,一种开源的身份及访问管理（<code>IAM</code>）服务。官方称，“为现代应用系统和服务提供开源的鉴权和授权访问控制管理”。</p><p>实现了<code>Oauth2,OpenID Connet,Saml</code>协议的单点登陆<code>SSO</code>，支持多种第三方身份服务<code>Identity Provider(IdP)</code> （OpenID Connect, SAML2.0 IdPs，Github，Google等）来做鉴权，方便简单可以开箱即用。</p><p>在我提供的demo中，主要展示了鉴权相关：</p><ul><li>获取<code>token</code>：在客户端（<code>web</code>页面）使用推荐的<code>PKCE</code>方式获取`accessToken</li><li>校验<code>token</code>：用<code>token issuer</code>配置中<code>jwks</code>的公钥来验证token签名是否合法</li></ul><blockquote><p>相当于离线验证，只能知道<code>token</code>是否合法，不能知道token是否被失效等，更安全的方式是通过<code>token introspection</code>接口验证token是否还有效)</p></blockquote><p>其中<code>web</code>页面内用了<code>react</code>,获取<code>token</code>用了<code>@react-keycloak/web</code>, <code>token</code>校验用了<code>OpenPolicyAgent</code>(单纯为玩，不是推荐用法)<br>为了避免网页跨域<code>cors</code>问题加了<code>nginx</code>反向代理</p><p>动图如下：<br><img src="http://media.newbmiao.com/tech/kecloak-authN.gif" alt="demo"></p><p>具体示例详见：<strong><a href="https://github.com/NewbMiao/keycloak-authN" target="_blank" rel="noopener">https://github.com/NewbMiao/keycloak-authN</a></strong>, 有<code>readme</code>，一键启动。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      tech-behind-authentication
    
    </summary>
    
    
      <category term="tech" scheme="https://newbmiao.github.io/categories/tech/"/>
    
      <category term="OIDC" scheme="https://newbmiao.github.io/categories/tech/OIDC/"/>
    
      <category term="oauth2" scheme="https://newbmiao.github.io/categories/tech/OIDC/oauth2/"/>
    
    
      <category term="oauth2" scheme="https://newbmiao.github.io/tags/oauth2/"/>
    
      <category term="OIDC" scheme="https://newbmiao.github.io/tags/OIDC/"/>
    
      <category term="keycloak" scheme="https://newbmiao.github.io/tags/keycloak/"/>
    
      <category term="authentication" scheme="https://newbmiao.github.io/tags/authentication/"/>
    
      <category term="authorization" scheme="https://newbmiao.github.io/tags/authorization/"/>
    
  </entry>
  
  <entry>
    <title>二分递归版or-channel模式的问题</title>
    <link href="https://newbmiao.github.io/2021/08/22/recursive-ordone-issue.html"/>
    <id>https://newbmiao.github.io/2021/08/22/recursive-ordone-issue.html</id>
    <published>2021-08-22T13:04:19.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>今天在修正昨天的文章《orDone的两种实现》中的压测代码时，无意发现其中的二分递归版的代码是有问题的。</p><p>主要是<code>goroutine</code>泄露的问题，下边简单说明下，也参考自文章<a href="https://tjjsjwhj.me/2021/04/25/go-or-done/" target="_blank" rel="noopener">记一次学习 orDone 模式爬坑经历</a></p><a id="more"></a><h2 id="goroutine泄露"><a href="#goroutine泄露" class="headerlink" title="goroutine泄露"></a>goroutine泄露</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">    <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 2个也是一种特殊情况</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//超过两个，二分法递归处理</span></span><br><span class="line">        m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-or(channels[:m]...):</span><br><span class="line">        <span class="keyword">case</span> &lt;-or(channels[m:]...):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>原代码递归时，没有将结束通道<code>orDone</code>合并，在<code>orDone</code>关闭后，没法通知递归中的<code>goroutine</code>退出，有<code>goroutine</code>泄露的可能</p><p>可修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrWithIssue(<span class="built_in">append</span>(channels[:m:m], orDone)...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrWithIssue(<span class="built_in">append</span>(channels[m:], orDone)...):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无限递归"><a href="#无限递归" class="headerlink" title="无限递归"></a>无限递归</h2><p>以上代码时，还有个问题是在参数为三个<code>chan</code>时会无限递归，(文末参考文章里有通过打印协程数来测试这个问题的代码，感兴趣可以去看下)</p><p>递归树如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3个时有无限递归的问题:</span></span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">    f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">       f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure><p>所以需要对3这种<code>case</code>区分处理</p><p>最终代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrRecur</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 特殊情况，只有0个或者1个chan</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 特殊情况</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 特殊情况</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">2</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 超过3个，二分法递归处理</span></span><br><span class="line">   m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrRecur(<span class="built_in">append</span>(channels[:m:m], orDone)...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrRecur(<span class="built_in">append</span>(channels[m:], orDone)...):</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再补充下修正后压测结果，二分递归比反射性能更好些</p><p><img src="http://media.newbmiao.com/dig101/go/orDoneTime.png" alt="时间消耗"><br><img src="http://media.newbmiao.com/dig101/go/orDoneMemory.png" alt="内存消耗"></p><p>感兴趣可以自己跑下<a href="https://github.com/NewbMiao/Dig101-Go/tree/master/concurrency/channel/schedule/orDone" target="_blank" rel="noopener">压测代码</a></p><blockquote><p>虽然是常见的orDone模式，但还是有不少可以探究的地方，想要用好chan还是需要足够仔细啊。</p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      recursive-o-issue
    
    </summary>
    
    
      <category term="go" scheme="https://newbmiao.github.io/categories/go/"/>
    
      <category term="dig101" scheme="https://newbmiao.github.io/categories/go/dig101/"/>
    
    
      <category term="go" scheme="https://newbmiao.github.io/tags/go/"/>
    
      <category term="or-channel-pattern" scheme="https://newbmiao.github.io/tags/or-channel-pattern/"/>
    
  </entry>
  
  <entry>
    <title>or-channel模式的两种实现</title>
    <link href="https://newbmiao.github.io/2021/08/19/2-way-of-or-done-pattern.html"/>
    <id>https://newbmiao.github.io/2021/08/19/2-way-of-or-done-pattern.html</id>
    <published>2021-08-19T14:08:01.000Z</published>
    <updated>2023-06-18T00:52:29.950Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p><code>or</code> channel模式是一种并发控制模式，旨在多任务场景下实现，有一个任务成功返回即立即结束等待。</p><p>今天我们来看下两种不同的实现方式：</p><a id="more"></a><h2 id="方式一-递归"><a href="#方式一-递归" class="headerlink" title="方式一 递归"></a>方式一 递归</h2><p>利用二分法递， 将所有待监听信号的<code>chan</code>都<code>select</code>起来，</p><p>当有第一个<code>chan</code>返回时，<code>close orDone</code> 来通知读取方已有第一个任务返回</p><p>代码如下比较直观：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入多个并发chan，返回是否结束的 orDone chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Or</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 只有零个或者1个chan</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 返回nil， 让读取阻塞等待</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 返回时利用close做结束信号的广播</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用select监听第一个chan的返回</span></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 直接select</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 二分法递归处理</span></span><br><span class="line">   m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-Or(channels[:m]...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-Or(channels[m:]...):</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二-利用反射"><a href="#方式二-利用反射" class="headerlink" title="方式二 利用反射"></a>方式二 利用反射</h2><p>这里要用到<code>reflect.SelectCase</code>, 他可以描述一种<code>select</code>的<code>case</code>,<br>来指明其接受的是<code>chan</code>的读取或发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SelectCase <span class="keyword">struct</span> &#123;</span><br><span class="line"> Dir  SelectDir <span class="comment">// direction of case</span></span><br><span class="line"> Chan Value     <span class="comment">// channel to use (for send or receive)</span></span><br><span class="line"> Send Value     <span class="comment">// value to send (for send)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个，就可以之间遍历，不用递归来实现有限的<code>select case</code>构造</p><p>最后用<code>reflect.Select(cases)</code>监听信号就可以了，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrInReflect</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 只有0个或者1个</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">  <span class="comment">// 利用反射构建SelectCase，这里是读取</span></span><br><span class="line">  <span class="keyword">var</span> cases []reflect.SelectCase</span><br><span class="line">  <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line">   cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">    Dir:  reflect.SelectRecv,</span><br><span class="line">    Chan: reflect.ValueOf(c),</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机选择一个可用的case</span></span><br><span class="line">  reflect.Select(cases)</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h2><p>这两种都可以支持大量<code>chan</code>的信号监听，那性能差异大么</p><p>虽说递归开销肯定不小，反射也不一定效率高，拿个压测来试试吧</p><p>先构造一下<code>chan</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsStream</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, values ...<span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> s := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 退出时关闭chan             </span></span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(s)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">case</span> s &lt;- v:</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后压测</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []<span class="keyword">struct</span> &#123;</span><br><span class="line"> name <span class="keyword">string</span></span><br><span class="line"> f    <span class="function"><span class="keyword">func</span><span class="params">(...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;&#123;</span><br><span class="line"> &#123;<span class="string">"reflection"</span>, OrInReflect&#125;,</span><br><span class="line"> &#123;<span class="string">"recursion"</span>, OrRecur&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkOr</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">  <span class="keyword">for</span> n := <span class="number">8</span>; n &lt;= <span class="number">1024</span>; n *= <span class="number">2</span> &#123;</span><br><span class="line">   b.Run(fmt.Sprintf(<span class="string">"%s/%d"</span>, f.name, n), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">     b.StopTimer()</span><br><span class="line">     done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">     <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">     streams := <span class="built_in">make</span>([]&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, n)</span><br><span class="line">     <span class="keyword">for</span> i := <span class="keyword">range</span> streams &#123;</span><br><span class="line">      streams[i] = AsStream(done, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>&#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     b.StartTimer()</span><br><span class="line">     &lt;-f.f(streams...)</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了下结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/NewbMiao/Dig101-Go/concurrency/channel/schedule/or</span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-8750</span>H CPU @ <span class="number">2.20</span>GHz</span><br><span class="line">BenchmarkOr/reflection/<span class="number">8</span><span class="number">-12</span>                    <span class="number">60044</span>             <span class="number">22924</span> ns/op            <span class="number">2839</span> B/op         <span class="number">28</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">16</span><span class="number">-12</span>                   <span class="number">82941</span>             <span class="number">27764</span> ns/op            <span class="number">4684</span> B/op         <span class="number">41</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">32</span><span class="number">-12</span>                   <span class="number">56890</span>             <span class="number">40326</span> ns/op            <span class="number">8397</span> B/op         <span class="number">66</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">64</span><span class="number">-12</span>                   <span class="number">33350</span>             <span class="number">90301</span> ns/op           <span class="number">16485</span> B/op        <span class="number">116</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">128</span><span class="number">-12</span>                  <span class="number">17476</span>            <span class="number">109545</span> ns/op           <span class="number">34300</span> B/op        <span class="number">230</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">256</span><span class="number">-12</span>                   <span class="number">8155</span>            <span class="number">257080</span> ns/op           <span class="number">68398</span> B/op        <span class="number">443</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">512</span><span class="number">-12</span>                   <span class="number">4018</span>            <span class="number">429550</span> ns/op          <span class="number">134260</span> B/op        <span class="number">842</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">1024</span><span class="number">-12</span>                  <span class="number">2131</span>            <span class="number">890946</span> ns/op          <span class="number">266877</span> B/op       <span class="number">1648</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">8</span><span class="number">-12</span>                    <span class="number">186949</span>              <span class="number">6770</span> ns/op            <span class="number">1190</span> B/op         <span class="number">12</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">16</span><span class="number">-12</span>                   <span class="number">127618</span>             <span class="number">10651</span> ns/op            <span class="number">2048</span> B/op         <span class="number">21</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">32</span><span class="number">-12</span>                    <span class="number">83200</span>             <span class="number">24578</span> ns/op            <span class="number">3405</span> B/op         <span class="number">35</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">64</span><span class="number">-12</span>                    <span class="number">69890</span>             <span class="number">33589</span> ns/op            <span class="number">5162</span> B/op         <span class="number">53</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">128</span><span class="number">-12</span>                   <span class="number">32719</span>             <span class="number">58391</span> ns/op            <span class="number">8301</span> B/op         <span class="number">86</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">256</span><span class="number">-12</span>                   <span class="number">10000</span>            <span class="number">162016</span> ns/op           <span class="number">13487</span> B/op        <span class="number">140</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">512</span><span class="number">-12</span>                    <span class="number">7225</span>            <span class="number">283879</span> ns/op           <span class="number">24199</span> B/op        <span class="number">252</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">1024</span><span class="number">-12</span>                   <span class="number">3112</span>            <span class="number">645105</span> ns/op           <span class="number">50744</span> B/op        <span class="number">528</span> allocs/op</span><br></pre></td></tr></table></figure><p>压测结果如图所示<br><img src="http://media.newbmiao.com/dig101/go/orBenchmark.png" alt="orBenchmark"></p><p>可以看出，大量并发<code>chan</code>场景下， 递归效率更好一些。</p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      2-way-of-or-channel-pattern
    
    </summary>
    
    
      <category term="go" scheme="https://newbmiao.github.io/categories/go/"/>
    
      <category term="dig101" scheme="https://newbmiao.github.io/categories/go/dig101/"/>
    
    
      <category term="go" scheme="https://newbmiao.github.io/tags/go/"/>
    
      <category term="or-channel-pattern" scheme="https://newbmiao.github.io/tags/or-channel-pattern/"/>
    
  </entry>
  
  <entry>
    <title>举例来学cond原语</title>
    <link href="https://newbmiao.github.io/2021/08/09/one-example-to-learn-cond.html"/>
    <id>https://newbmiao.github.io/2021/08/09/one-example-to-learn-cond.html</id>
    <published>2021-08-09T13:04:19.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>最近看了鸟窝的《Go并发编程实战课》，写的挺有意思的，打算后边弄些例子再回顾下并发原语。</p><p>今天来看看<code>cond</code>原语。</p><p><code>cond</code> 是用于等待或通知场景下的并发原语，条件不满足时，阻塞(<code>wait</code>)一组<code>goroutine</code>；条件满足后，唤醒单个（<code>signal</code>）或所有(<code>broadcast</code>)阻塞的<code>goroutine</code>.</p><p>比如10个运动员跑步，都准备好了，裁判才发令的例子：</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化带锁的条件变量</span></span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> ready <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起10个协程，随机等待后模拟运动员就位，并记录就位人数（加锁更新）</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Duration(rand.Int63n(<span class="number">5</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">    ready++</span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"运动员#%d 已准备就绪\n"</span>, i)</span><br><span class="line">    <span class="comment">// 广播唤醒所有的等待者</span></span><br><span class="line">    <span class="comment">// 这里用signal也可以，因为等待者只有一个main goroutine</span></span><br><span class="line">    c.Broadcast()</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件满足：10人都就位</span></span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> ready != <span class="number">10</span> &#123;</span><br><span class="line">  c.Wait()</span><br><span class="line">  log.Println(<span class="string">"裁判员被唤醒一次"</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的运动员是否就绪</span></span><br><span class="line">log.Println(<span class="string">"所有运动员都准备就绪。比赛开始，3，2，1, ......"</span>)</span><br></pre></td></tr></table></figure><p>输出差不多如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 运动员#<span class="number">0</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 运动员#<span class="number">4</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">5</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">3</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">9</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">10</span> 运动员#<span class="number">7</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">10</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">11</span> 运动员#<span class="number">1</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">11</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 运动员#<span class="number">6</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 运动员#<span class="number">2</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 运动员#<span class="number">8</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 所有运动员都准备就绪。比赛开始，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span>, ......</span><br></pre></td></tr></table></figure><p>可以看出<code>cond</code>在更改条件或者检查条件时需要加锁处理，避免并发下读写不一致问题。</p><p>里边<code>wait</code>等待条件满足时比较特殊，需要加锁并在<code>for</code>循环中等待，为什么呢？</p><p>根据源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line"> c.checker.check()</span><br><span class="line"> <span class="comment">// 更新等待groutine的计数： wait</span></span><br><span class="line"> t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line"> <span class="comment">// 释放锁，防止阻塞后别的goroutine拿不到锁</span></span><br><span class="line"> c.L.Unlock()</span><br><span class="line"> <span class="comment">// 切走当前goroutine，等待唤起</span></span><br><span class="line"> runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line"> <span class="comment">// 唤起后持有锁</span></span><br><span class="line"> c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wait</code>时，将当前<code>goroutine</code>加到等待队列（<code>notifyList</code>）前释放了锁，避免锁持有导致别的<code>goroutine</code>死锁；</p><p>唤起后，又持有锁，再持有锁前，可能有别的<code>goroutine</code>持有过锁，比如多次<code>signal</code>或者<code>broadcast</code>,<br>这里没法确定，当前<code>goroutine</code>唤起后条件没有改变，所以需要在<code>for</code>循环中检测条件是否依然满足</p><p>即，官方文档说明的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  c.L.Lock()</span></span><br><span class="line"><span class="comment">//  for !condition() &#123;</span></span><br><span class="line"><span class="comment">//      c.Wait()</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  ... make use of condition ...</span></span><br><span class="line"><span class="comment">//  c.L.Unlock()</span></span><br></pre></td></tr></table></figure><p>如果用<code>channel</code>来实现，也可以做类似的事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unbuffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  ch &lt;- <span class="number">1</span> <span class="comment">// i is ready</span></span><br><span class="line"> &#125;(i) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"all is ready!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// buffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(ch) != <span class="number">10</span> &#123;</span><br><span class="line">  time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"all is ready!"</span>)</span><br></pre></td></tr></table></figure><p>但<code>cond</code>的优势在于其同时支持<code>signal</code>和<code>broadcast</code>，<code>channel</code>同时只能实现一种（<code>close</code>算<code>broadcast</code>，但只能用一次，不可重复调用）</p><p>用<code>waitGroup</code>也可以模拟等待条件满足，但是针对的是主<code>goroutine</code>对确定数量<code>goroutine</code>的等待，不像<code>cond</code>只关心条件是否满足，对等待<code>goroutine</code>数目没有要求。</p><p>最后，推荐一个《concurrency-in-go》中提到的代码例子，<a href="https://github.com/kat-co/concurrency-in-go-src/blob/master/an-introduction-to-concurrency/why-is-concurrency-hard/deadlocks-livelocks-and-starvation/livelock/fig-livelock-hallway.go" target="_blank" rel="noopener">fig-livelock-hallway</a></p><p>展示了用<code>cond</code>模拟的狭路相逢谁也过不去的活锁问题。</p><blockquote><p>关于鸟窝的《Go并发编程实战课》，我链接放到<a href="https://time.geekbang.org/column/intro/355?code=pLKPP5Hiu4B61apPRONmbYHopf6Y0TlfGvbXwOEDKKc%3D&utm_term=SPoster" target="_blank" rel="noopener">这里</a>，感兴趣的同学可以去听听，质量很高！</p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      one-example-to-learn-cond
    
    </summary>
    
    
      <category term="go" scheme="https://newbmiao.github.io/categories/go/"/>
    
      <category term="dig101" scheme="https://newbmiao.github.io/categories/go/dig101/"/>
    
    
      <category term="go" scheme="https://newbmiao.github.io/tags/go/"/>
    
      <category term="cond" scheme="https://newbmiao.github.io/tags/cond/"/>
    
  </entry>
  
  <entry>
    <title>一个8bytes的内存优化</title>
    <link href="https://newbmiao.github.io/2021/08/07/one-8-bytes-optimization.html"/>
    <id>https://newbmiao.github.io/2021/08/07/one-8-bytes-optimization.html</id>
    <published>2021-08-07T07:36:13.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>最近看<a href="https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memor" target="_blank" rel="noopener">Dave Cheney的一篇文章</a>，发现一个有趣的代码片段，里面展示了一个8byte的内存优化。</p><p>代码片段是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSortStrings</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> s := []<span class="keyword">string</span>&#123;<span class="string">"heart"</span>, <span class="string">"lungs"</span>, <span class="string">"brain"</span>, <span class="string">"kidneys"</span>, <span class="string">"pancreas"</span>&#125;</span><br><span class="line"> b.ReportAllocs()</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  <span class="keyword">var</span> ss sort.StringSlice = s</span><br><span class="line">  <span class="keyword">var</span> si sort.Interface = ss</span><br><span class="line">  sort.Sort(si)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码很简单，是对一个<code>[]string</code>做排序的内存分配压测</p><p>其中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ss sort.StringSlice = s</span><br><span class="line"><span class="keyword">var</span> si sort.Interface = ss</span><br><span class="line">sort.Sort(si)</span><br></pre></td></tr></table></figure><p>等同于代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Strings(s)</span><br></pre></td></tr></table></figure><p>涉及了对 <code>[]string</code> 转换为实现排序的接口 <code>sort.Interface</code></p><p>了解<code>iface</code>实现的同学知道其<code>data</code>会存储底层数据，一般是一个机器字长的大小（<code>8bytes</code>）</p><p>而<code>slice</code>是<code>24bytes</code>: 底层数组指针（<code>8bytes</code>）+ 长度（<code>8bytes</code>）+ 容量（<code>8bytes</code>）</p><p>直接存不下，就只能<code>indirection</code>, 存指向切片的指针了</p><p>创建前片指针的过程中，切片escape到了heap上，因为不知道原切片<code>ss</code>是否会在<code>si</code>使用过程中消失。</p><p>即，内存分配发生在了这里！</p><p>看下压测结果（<code>go1.16</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test sort_test.<span class="keyword">go</span> -bench . -benchmem </span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i5<span class="number">-5257</span>U CPU @ <span class="number">2.70</span>GHz</span><br><span class="line">BenchmarkInts<span class="number">-4</span>         <span class="number">18846020</span>                <span class="number">90.09</span> ns/op           <span class="number">24</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  <span class="number">2.663</span>s</span><br></pre></td></tr></table></figure><p>结果就是<code>24bytes</code>啊，那所谓的<code>8bytes</code>优化在哪里呢</p><p>是相对于的<code>go1.16</code>前版本的<code>go</code>的, 比如<code>go1.15</code>下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go1<span class="number">.15</span> test sort_test.<span class="keyword">go</span> -bench . -benchmem </span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkSortStrings<span class="number">-4</span>           <span class="number">8617881</span>               <span class="number">172</span> ns/op              <span class="number">32</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  <span class="number">1.649</span>s</span><br></pre></td></tr></table></figure><p>找了下具体提交，其实就是在内存分配里针对三个机器字大小增加了<code>24bytes</code>的<code>sizeClass</code>，避免原来的向上取整到<code>32bytes</code></p><p>感兴趣的同学可以去看着具体实现：<br><a href="https://github.com/golang/go/commit/14c7caae5074fdf0d97a3ad995e20c63e4065cbf" target="_blank" rel="noopener">runtime: add 24 byte allocation size class</a></p><blockquote><p>题外话，好久没有更新了，不好意思了都，后边再捡起来😂</p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      one-8-bytes-optimization
    
    </summary>
    
    
      <category term="go" scheme="https://newbmiao.github.io/categories/go/"/>
    
      <category term="dig101" scheme="https://newbmiao.github.io/categories/go/dig101/"/>
    
    
      <category term="go" scheme="https://newbmiao.github.io/tags/go/"/>
    
      <category term="memory" scheme="https://newbmiao.github.io/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>2020年回顾</title>
    <link href="https://newbmiao.github.io/2021/01/02/summary-of-2020.html"/>
    <id>https://newbmiao.github.io/2021/01/02/summary-of-2020.html</id>
    <published>2021-01-02T09:23:34.000Z</published>
    <updated>2023-06-18T00:52:29.957Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，2020年就过去了，是时候说一声再见了。</p><p>2020对于我还是有比较多的新体验。</p><a id="more"></a><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>年初父母来西安一起过年，不料被疫情隔离在小区近一个多月，过了一个慵懒的年，也多了许多陪娃的时间。</p><p>因某些原因，公司不需要我在家办公，然后再大家都开始上班后，我又有近两周的赋闲时间。</p><p>一时兴起，就花时间倒腾了一系列<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1345369054160306177#wechat_redirect" target="_blank" rel="noopener">Go源码分析</a>, 让好久不用的公众号也有了更新。</p><p>那段时间，静下心刨根问底的去研究Go语言设计背后的逻辑，让自己多Go有了更深的理解。</p><p>期间也接触了许多Go社区活跃的大佬，有幸一起探讨一些问题，并做了一期分享，都是之前不曾尝试的体验。</p><p>不得不说，技术这东西只要你感兴趣肯花时间，确实是可以一直挖下去。</p><p>隔离结束后，上半年又搞了许多不曾接触的云原生自动化与策略配置。</p><p>从很有压力、略有排斥，到不去逃避，看英文文档自行解决遇到的技术问题。</p><p>这期间也分享一系列<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1345371288113725441#wechat_redirect" target="_blank" rel="noopener">云原生通用规则引擎（OPA）的入门教程</a>，推广了下这项自己很看好的策略描述语言。</p><p>然后下半年又面向需求开发，学习了前端，把以前只是听过的一些技术单词变成了能力。顺带把自己之前做的小程序云开发重新优化成了一期<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1554691207543504896#wechat_redirect" target="_blank" rel="noopener">入门教程</a>。</p><p>这搁以前，怕是更不会去尝试的东西。</p><p>一路走来，现在的自己，对于技术已经不再执著于某一语言、前端或后端，面向需求开发，只看技术是否合适罢了。</p><h2 id="奶爸"><a href="#奶爸" class="headerlink" title="奶爸"></a>奶爸</h2><p>去年5月，喜提小可爱一枚。</p><p>如今小可爱都快两岁了，吃饭，走路，学本领都很快，不得不说，我和她妈的基因还是挺强大的，哈哈。（其实都是她妈带得好）</p><p>不过好久没能睡过懒觉了，另外抱娃哄睡这一技能也已经日益娴熟。所以前不久奖励了自己一个45千克的室内引体向上架，让（希望）自己臂力可以跟上娃日益上涨的体重。</p><p>现在耐心也好了许多（虽然有时还是容易急），渐渐开始适应奶爸这一角色。</p><p>偶尔生气时也懊恼为啥要生娃添堵，但过后看着娃的笑脸，觉得这一切都是值得的，一切都是最好的安排。</p><p>只要陪她一起快乐长大就好了。</p><h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><p>最后这一年的收益率跑赢了沪深300，虽对于翻倍的行情不是很完美，但至少跑赢了市场也学到一些去年做不到的东西。</p><p>用曾经看到的一句话作为投资的总结就是：</p><p>做投资一定要路子对，路子对的话，无非是三年成功还是五年成功。但如果路子不对，你永远不行。</p><p>感兴趣可以去看我的<a href="https://mp.weixin.qq.com/s/MJ3aujCNYjRYJ2x1SGBc8w" target="_blank" rel="noopener">2020投资回顾</a>，细节这里就不展开了</p><hr><p>2021，继续干就好了！</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉，2020年就过去了，是时候说一声再见了。&lt;/p&gt;
&lt;p&gt;2020对于我还是有比较多的新体验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="summary" scheme="https://newbmiao.github.io/categories/summary/"/>
    
    
      <category term="summary" scheme="https://newbmiao.github.io/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>Dig101-Go之深入理解mutex</title>
    <link href="https://newbmiao.github.io/2020/07/01/dig101-golang-understanding-mutex.html"/>
    <id>https://newbmiao.github.io/2020/07/01/dig101-golang-understanding-mutex.html</id>
    <published>2020-06-30T23:38:33.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><!-- **文章目录** --><!-- [TOC] --><p><code>sync.Mutex</code>是<code>Go</code>实现的互斥锁，提供了基本的同步操作，使用很方便。</p><p>不过，你是否好奇过，<code>Go</code>是如何实现的<code>Mutex</code>，又是为什么要这样实现？</p><p>今天跟随几个问题，我们一起探索下<code>Mutex</code>背后的设计。</p><p>（不用担心，不会有大段的源码分析出现在本文😳）</p><a id="more"></a><h2 id="0x01-为什么需要锁"><a href="#0x01-为什么需要锁" class="headerlink" title="0x01 为什么需要锁"></a>0x01 为什么需要锁</h2><p>锁当然是为了保证同步操作，或者应该这样问：没有锁的时候，为什么会有不同步？</p><p>这里导致不同步的原因主要有两点：</p><h3 id="非原子操作"><a href="#非原子操作" class="headerlink" title="非原子操作"></a>非原子操作</h3><p>如果一个线程的内存操作的<strong>中间状态</strong>（比如只完成一半），可以被<strong>另一个线程获取到</strong>，那么其操作就是非原子操作。</p><p>或者说其操作不是<strong>不可再分</strong>的。</p><p>比如自增操作<code>i++</code>, <code>i</code>的读取、修改、写入（<code>RMW</code>），其底层<strong>cpu和内存实际交互了两次</strong>，自然没法保证操作过程的原子性。</p><p><img src="http://media.newbmiao.com/dig101/go/self-incr.png" alt="自增操作"></p><p>那直接读取操作是否就能保证原子性呢？</p><p>也不一定，比如一般操作系统操作内存的最小粒度是一个机器字<code>machine word</code>(32位系统是<code>4B</code>,64位系统是<code>8B</code>)</p><p>内存对齐的情况下，在32位系统上读取一个<code>int64</code>(<code>8B</code>)就不可能是原子的，更别说如果内存是不对齐的了。</p><h3 id="内存重排"><a href="#内存重排" class="headerlink" title="内存重排"></a>内存重排</h3><p>我们写的代码顺序与实际执行的顺序可能并不一致。这是因为有内存重排的存在。他会发生在两个地方：</p><ul><li>语言编译时</li></ul><p>语言为了一些优化考虑，可能会在编译期间重排代码顺序。</p><ul><li>系统执行时</li></ul><p>这个完全取决于系统底层指令的实现，主要是为了更好利用那些原本要浪费掉的<strong>指令周期</strong>，提升程序的执行速度。</p><p>比如cpu和主存（<code>main memory</code>）访问延时是很高的。多核时代，每个cpu核为了加速访问，就增加了各自与主存交互的缓存(<code>cache</code>)。</p><p>如果缓存中有就无需再和主存交互了。如下图所示：</p><p><img src="http://media.newbmiao.com/dig101/go/cpu-cache-main-memory.png" alt="cpu的缓存与主存"></p><p>但有多份缓存，就需要有缓存一致（<code>cache coherency</code>）协议保证他们的结果一致。(具体可以了解<a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">MESI协议</a>)。</p><p>这种情况下，如果多个cpu核同时修改或读取同一份数据，且这份数据在各自的缓存中，为避免<strong>缓存间不一致</strong>，就不可避免有的cpu核要等待其他cpu核先操作数据。</p><p>所以在这些cpu核<strong>等待期间</strong>，他可以先执行其他内存指令。</p><blockquote><p>详细可以参考 <a href="https://www.internalpointers.com/post/understanding-memory-ordering" target="_blank" rel="noopener">Understanding memory reordering</a> 这篇文章。</p></blockquote><h2 id="0x02-mutex如何实现原子操作"><a href="#0x02-mutex如何实现原子操作" class="headerlink" title="0x02 mutex如何实现原子操作"></a>0x02 mutex如何实现原子操作</h2><p>利用<code>atomic</code>提供的<code>AddInt32</code>和<code>CompareAndSwapInt32</code>函数，其底层使用了系统架构提供的<code>LOCK</code>前缀指令。</p><p>该指令会设置处理器的<code>LOCK</code>信号。</p><p>这个信号会使总线锁定，阻止其他处理器接管总线访问内存，直到使用<code>LOCK</code>前缀指令执行结束，这会使这条指令的执行变为原子操作。</p><p>在多处理器环境下，设置<code>LOCK</code>信号能保证某个处理器对共享内存的独占使用。</p><p>具体指令参见：<code>runtime/internal/atomic/asm_amd64.s</code></p><p>如<code>Cas</code>的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bool Cas(int32 *val, int32 old, int32 new)</span></span><br><span class="line"><span class="comment">// Atomically:</span></span><br><span class="line"><span class="comment">//if(*val == old)&#123;</span></span><br><span class="line"><span class="comment">//*val = new;</span></span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="comment">//&#125; else</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$<span class="number">0</span><span class="number">-17</span></span><br><span class="line">MOVQptr+<span class="number">0</span>(FP), BX</span><br><span class="line">MOVLold+<span class="number">8</span>(FP), AX</span><br><span class="line">MOVL<span class="built_in">new</span>+<span class="number">12</span>(FP), CX</span><br><span class="line">LOCK</span><br><span class="line">CMPXCHGLCX, <span class="number">0</span>(BX)</span><br><span class="line">SETEQret+<span class="number">16</span>(FP)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><h2 id="0x03-mutex如何避免内存重排"><a href="#0x03-mutex如何避免内存重排" class="headerlink" title="0x03 mutex如何避免内存重排"></a>0x03 mutex如何避免内存重排</h2><p>上边提到的<code>LOCK</code>指令及<code>XCHG</code>等指令，会引入内存屏障（<code>memory barrier</code>）</p><p>内存屏障是强制处理器按照可预知的方式访问内存的CPU指令。</p><p>内存屏障的工作方式类似路障：内存屏障之前的指令保证先于内存屏障之后的指令执行。</p><blockquote><p>更多关于内存屏障可以看看这篇文章中对 <a href="https://my.oschina.net/chuqq/blog/3022854" target="_blank" rel="noopener">POSIX多线程程序设计-3.4节</a> 引用。</p></blockquote><h2 id="0x04-Go对mutex的优化点"><a href="#0x04-Go对mutex的优化点" class="headerlink" title="0x04 Go对mutex的优化点"></a>0x04 Go对mutex的优化点</h2><p>有了底层架构指令支持，如果<code>Go</code>直接基于<code>atomic.CAS</code>+cpu时钟周期阻塞，就可实现常见的自旋锁（<code>spinLock</code>）：</p><p>未获取锁前阻塞线程，每次等待一些cpu时钟周期，直到锁可用就好了。</p><p>但Go自己还是做了一些优化，一般情况下会优于常见的多线程互斥锁。</p><p>主要优化点是：</p><h3 id="不一直让cpu空转等待锁"><a href="#不一直让cpu空转等待锁" class="headerlink" title="不一直让cpu空转等待锁"></a>不一直让cpu空转等待锁</h3><p>一直自旋最大的问题就是浪费cpu时钟周期，会占用一些cpu，除非锁能很快获取到的。</p><p>所以Go在<strong>多核</strong>且<strong>不会影响其他<code>Goroutine</code>调度</strong>时，会最多自旋4次，且每次空转30个cpu时钟周期。以期能短期内获取锁。</p><p>详见<code>runtime_canSpin</code>和<code>runtime_doSpin</code> (源码见<code>runtime/proc.go</code>)</p><h3 id="用信号量实现睡眠的协程唤起"><a href="#用信号量实现睡眠的协程唤起" class="headerlink" title="用信号量实现睡眠的协程唤起"></a>用信号量实现睡眠的协程唤起</h3><p>上边说了不会一直空转cpu，那4次空转之后锁还没好，怎么办？</p><p>在多线程场景里一般就会基于信号量（<code>semaphore</code>）实现 <a href="https://zh.wikipedia.org/wiki/Futex" target="_blank" rel="noopener"><code>futex</code></a>，来让线程睡眠直至条件满足后唤醒。</p><p>Go也用信号量实现了类似<code>futex</code>的<code>wake</code>和<code>sleep</code>. 只不过他们管理的Go自己调度的<strong>协程</strong>而非线程。</p><p>这样好处是，让协程等待的代价要比线程更低，而且<strong>协程上下文切换</strong>也更快一些。</p><h3 id="避免过多无效的协程唤起"><a href="#避免过多无效的协程唤起" class="headerlink" title="避免过多无效的协程唤起"></a>避免过多无效的协程唤起</h3><p>如果一个锁有多个协程在抢，且已经有被挂起的协程在等待唤起。</p><p>这种情况下，当锁释放，等待被唤起的协程被唤醒时，他会和其他<strong>已经在cpu上运行的协程</strong>一起去抢锁，自然很容易失败而导致继续挂起。</p><p>为缓解这种极端情况的延迟。<code>Go</code>增加饥饿模式（<code>starvation mode</code>）：</p><p>正常情况按先进先出唤醒抢锁；如果有协程获取锁失败被挂起超过<strong>1ms</strong>，就将其放到队首，并转为饥饿模式。</p><p>这种模式下，下次唤醒就直接把锁<strong>交给</strong>（<code>handoff</code>）队首等待已久的协程。</p><p>了解这些，再去看<code>mutex</code>的源码可能会更好理解一些。</p><p>最后推荐一个talk，是英文版的，里边有很详细的关于<code>mutex</code>的讨论。</p><!-- ![Kavya Joshi - Let’s talk locks](https://www.bilibili.com/video/BV1kz411e7dL/) --><iframe src="//player.bilibili.com/player.html?aid=201155404&bvid=BV1kz411e7dL&cid=206127447&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><!-- ---文章首发公众号：newbmiao推荐阅读：[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      dig101-golang-understanding-mutex
    
    </summary>
    
    
      <category term="go" scheme="https://newbmiao.github.io/categories/go/"/>
    
      <category term="dig101" scheme="https://newbmiao.github.io/categories/go/dig101/"/>
    
    
      <category term="go" scheme="https://newbmiao.github.io/tags/go/"/>
    
      <category term="mutex" scheme="https://newbmiao.github.io/tags/mutex/"/>
    
      <category term="memory-reordering" scheme="https://newbmiao.github.io/tags/memory-reordering/"/>
    
      <category term="atomic" scheme="https://newbmiao.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>Go之如何操作结构体的非导出字段</title>
    <link href="https://newbmiao.github.io/2020/06/13/dig101-golang-reflect-handle-unexport-field.html"/>
    <id>https://newbmiao.github.io/2020/06/13/dig101-golang-reflect-handle-unexport-field.html</id>
    <published>2020-06-13T14:42:03.000Z</published>
    <updated>2023-06-18T00:52:29.950Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><p>我们都知道<code>Go</code>的<code>struct</code>里，小写字段是非导出的，即不可从包外部访问。</p><p>但非导出字段在外部也并不是没有办法访问，也不是不可以修改。</p><p>今天看下<code>reflect</code>包如何在包外操作非导出字段。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="取地址访问"><a href="#取地址访问" class="headerlink" title="取地址访问"></a>取地址访问</h2><p>先来看第一个函数<code>NewAt</code>：</p><p>对于结构体，通过其底层地址（指针p）和类型，返回指向该结构体的一个<strong>指针</strong>，</p><p>该值是可寻址的（<code>addressable</code>），即可<strong>访问</strong>该结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflect/value.go</span></span><br><span class="line"><span class="comment">// NewAt returns a Value representing a pointer to a value of the</span></span><br><span class="line"><span class="comment">// specified type, using p as that pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAt</span><span class="params">(typ Type, p unsafe.Pointer)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">  fl := flag(Ptr)</span><br><span class="line">  t := typ.(*rtype)</span><br><span class="line">  <span class="keyword">return</span> Value&#123;t.ptrTo(), p, fl&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个这个方法，就可以通过<code>struct</code>的反射获取非导出字段</p><p>比如访问，对于如下含有非导出字段的结构体<code>Example</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testData</span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line">  a <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便可以通过对结构体<code>eg</code>取地址的方式，获取其非导出字段<code>a</code>的内容</p><p>这里<code>Elem</code>是获取其底层数据对象的方式，</p><p>如果知道类型，也可显示指定调用，如<code>reflect.value.Interface,reflect.value.Int...</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eg testData.Example</span><br><span class="line">a:=GetStructPtrUnExportedField(&amp;eg, <span class="string">"a"</span>).String()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructPtrUnExportedField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取非导出字段反射对象</span></span><br><span class="line">  v := reflect.ValueOf(source).Elem().FieldByName(fieldName)</span><br><span class="line">  <span class="comment">// 构建指向该字段的可寻址（addressable）反射对象</span></span><br><span class="line">  <span class="keyword">return</span> reflect.NewAt(v.Type(), unsafe.Pointer(v.UnsafeAddr())).Elem()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意必须要对<code>eg</code><strong>取地址</strong>, 否则会<code>panic</code>:</p><p><code>panic: reflect: call of reflect.Value.Elem on struct Value</code></p><p>因为<code>reflect.Value.Elem</code>需要<code>reflect.Value</code>类型必须是<code>interface</code>或者<code>ptr</code>,</p><p>这样获取其<strong>底层的值</strong>才有意义：要么返回<code>interface</code>底层的值或者<code>ptr</code>指向的值</p><p>其注释如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Elem returns the value that the interface v contains</span></span><br><span class="line"><span class="comment">// or that the pointer v points to.</span></span><br><span class="line"><span class="comment">// It panics if v's Kind is not Interface or Ptr.</span></span><br><span class="line"><span class="comment">// It returns the zero Value if v is nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span> &#123;</span><br></pre></td></tr></table></figure><h2 id="取地址修改"><a href="#取地址修改" class="headerlink" title="取地址修改"></a>取地址修改</h2><p>那可以访问了，如何修改呢？</p><p>利用<code>reflect.value.Set</code>就可以：</p><p>上边<code>Elem</code>获取到的反射值是可修改的（<code>assignable</code>）,突破了非导出字段不能从外部修改的限制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eg testData.Example</span><br><span class="line">err := SetStructPtrUnExportedStrField(&amp;eg, <span class="string">"a"</span>, <span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetStructPtrUnExportedStrField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>, fieldVal <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  v := GetStructPtrUnExportedField(source, fieldName)</span><br><span class="line">  rv := reflect.ValueOf(fieldVal)</span><br><span class="line">  <span class="keyword">if</span> v.Kind() != rv.Kind() &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid kind: expected kind %v, got kind: %v"</span>, v.Kind(), rv.Kind())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改非导出字段值</span></span><br><span class="line">  v.Set(rv)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是以反射值来修改非导出字段值，内部类型须一致。修改后内容会直接反应到<code>eg</code>上</p><p>类似的还有指定类型的设置方法如<code>SetString,SetBool...</code></p><h2 id="非取地址访问"><a href="#非取地址访问" class="headerlink" title="非取地址访问"></a>非取地址访问</h2><p>当然不取地址也是可以访问非导出字段的。</p><p>这里用到的第二个函数是<code>New</code>:</p><p>基于指定类型创建一个可以表示该类型的<strong>指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns a Value representing a pointer to a new zero value</span></span><br><span class="line"><span class="comment">// for the specified type. That is, the returned Value's Type is PtrTo(typ).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(typ Type)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"reflect: New(nil)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  t := typ.(*rtype)</span><br><span class="line">  ptr := unsafe_New(t)</span><br><span class="line">  fl := flag(Ptr)</span><br><span class="line">  <span class="keyword">return</span> Value&#123;t.ptrTo(), ptr, fl&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体访问代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructUnExportedField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>)</span> <span class="params">(accessableField, addressableSourceCopy reflect.Value)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(source)</span><br><span class="line">  <span class="comment">// since source is not a ptr, get an addressable copy of source to modify it later</span></span><br><span class="line">    addressableSourceCopy = reflect.New(v.Type()).Elem()</span><br><span class="line">    <span class="comment">// make a copy of source</span></span><br><span class="line">  addressableSourceCopy.Set(v)</span><br><span class="line">  accessableField = addressableSourceCopy.FieldByName(fieldName)</span><br><span class="line">  accessableField = reflect.NewAt(accessableField.Type(), unsafe.Pointer(accessableField.UnsafeAddr())).Elem()</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样其实是内部构造了一个对该结构其取地址的指针，以满足后续调用<code>Elem</code>时可寻址!</p><h2 id="非取地址修改"><a href="#非取地址修改" class="headerlink" title="非取地址修改"></a>非取地址修改</h2><p>非取地址的方式访问没有问题，要还想修改就不会反应到原始结构体上了</p><p>毕竟是内部重新拷贝了一个结构体进行的操作。</p><p>具体操作类似取地址修改的方式，这里不赘述了。</p><p>实际使用中，还是通过<code>NewAt</code>获取可读写的非导出字段更方便一些。</p><blockquote><p>本文代码见 <a href="https://github.com/NewbMiao/Dig101-Go/blob/master/reflect" target="_blank" rel="noopener">NewbMiao/Dig101-Go</a></p></blockquote><!-- ---文章首发公众号：newbmiao推荐阅读：[Dig101-Go系列](http://blog.newbmiao.com/categories/go/dig101/)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      dig101-golang-reflect-handle-unexport-field
    
    </summary>
    
    
      <category term="go" scheme="https://newbmiao.github.io/categories/go/"/>
    
      <category term="dig101" scheme="https://newbmiao.github.io/categories/go/dig101/"/>
    
    
      <category term="go" scheme="https://newbmiao.github.io/tags/go/"/>
    
      <category term="reflect" scheme="https://newbmiao.github.io/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>Dig101-Go之如何在函数内修改指针指向</title>
    <link href="https://newbmiao.github.io/2020/05/22/how-to-modify-a-pointer-of-go-inside.html"/>
    <id>https://newbmiao.github.io/2020/05/22/how-to-modify-a-pointer-of-go-inside.html</id>
    <published>2020-05-22T13:51:32.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><!-- **文章目录** --><!-- [TOC] --><p>今天来看一个小问题：<strong>如何在函数内部修改一个指针（参数或接收者）指向，使其值的改变能反映在函数外部</strong>？</p><p>直接上代码，这样可以么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArgType <span class="keyword">struct</span> &#123;</span><br><span class="line">  A <span class="keyword">string</span></span><br><span class="line">  b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg1</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  arg = &amp;ArgType&#123;<span class="string">"arg1"</span>, <span class="number">1</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg1:"</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>答案是【不可以】</p><p>等会分析，再看一个，这个呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg2</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  *arg = ArgType&#123;<span class="string">"arg2"</span>, <span class="number">2</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg2:"</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是【可以】</p><p>仔细看下，你应该就明白了。</p><p>第一个替换的是<strong>指针变量本身</strong>,</p><p>也就是在函数<code>modifyPointerArg1</code>的作用域内，其修改是有效</p><p>函数返回后，并不影响指针<code>arg</code>所指向的值（别忘了，Go参数传递是值传递嘛！）</p><p>至于<code>modifyPointerArg2</code>则是对指针解引用，修改了<strong>其指向的值</strong></p><hr><p>这样的方式其实还有很多，比如这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg3</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  val := reflect.ValueOf(arg)</span><br><span class="line">  val.Elem().FieldByName(<span class="string">"A"</span>).SetString(<span class="string">"arg3"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg3:"</span>, arg)</span><br><span class="line">  <span class="comment">// val.Elem().FieldByName("b").SetInt(3)</span></span><br><span class="line">  <span class="comment">// panic: reflect: reflect.flag.mustBeAssignable using value obtained using unexported field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际是利用反射的<code>Elem()</code>获取<code>val</code>的值</p><ul><li>如果其为空接口（<code>empty interface</code>），则获取其内部值（空接口值字段的类型是指针哦）</li><li>如果其为指针（<code>pointer</code>），则获取其指向的值</li></ul><p>获取到的结构如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    typ *rtype</span><br><span class="line">    <span class="comment">// 值指针</span></span><br><span class="line">    ptr unsafe.Pointer</span><br><span class="line">    <span class="comment">// 标志位</span></span><br><span class="line">  flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对应类型修改时, 实际就是对指针解引用修改其指向的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetString</span><span class="params">(x <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  v.mustBeAssignable()</span><br><span class="line">  v.mustBe(String)</span><br><span class="line">  <span class="comment">// 这里</span></span><br><span class="line">  *(*<span class="keyword">string</span>)(v.ptr) = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips： 这里注意一点，不导出的字段（结构体内小写的字段）不能用此类方法修改，会panic！</p></blockquote><p>再如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg4</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  jsonStr := <span class="string">`&#123;"A":"arg4","b":4&#125;`</span></span><br><span class="line">  json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部实际也是用了反射修改指针指向的值</p><p>另外，把上边几个测试函数由<strong>指针参数</strong>换为<strong>指针接受者</strong>，也是一样的</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ArgType)</span> <span class="title">modifyPointerReceiver4</span><span class="params">()</span></span> &#123;</span><br><span class="line">  jsonStr := <span class="string">`&#123;"A":"arg4","b":4&#125;`</span></span><br><span class="line">  json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣可以去自行尝试下其他几个函数。</p><p>说了这么多，这样修改有啥用么？</p><p>常见的一个场景便是：</p><p><strong>测试时，可以通过对接口实现对应的mock函数，改变参数或接收者，以达到排除依赖，进行单元测试的目的。</strong></p><!-- ---文章首发公众号：newbmiao推荐阅读：[OPA系列](http://blog.newbmiao.com/categories/OPA/)[Dig101-Go系列](http://mp.weixin.qq.com/mp/homepage?__biz=MzUxNzA2NzEzNw==&hid=3&sn=6ded611e164ec49132752fdbdaac552f&scene=18#wechat_redirect)![欢迎关注，获取及时更新内容](http://media.newbmiao.com/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      how-to-modify-a-pointer-inside-function
    
    </summary>
    
    
      <category term="go" scheme="https://newbmiao.github.io/categories/go/"/>
    
      <category term="dig101" scheme="https://newbmiao.github.io/categories/go/dig101/"/>
    
    
      <category term="go" scheme="https://newbmiao.github.io/tags/go/"/>
    
      <category term="reflect" scheme="https://newbmiao.github.io/tags/reflect/"/>
    
      <category term="dereference" scheme="https://newbmiao.github.io/tags/dereference/"/>
    
  </entry>
  
</feed>
