<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟Miao</title>
  <icon>https://www.gravatar.com/avatar/644a62fb3ee1c60061ebca1d0996b0ae</icon>
  <subtitle>start from a newb...(博客地址: https://newbmiao.github.io)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://newbmiao.github.io/"/>
  <updated>2024-08-20T11:08:36.416Z</updated>
  <id>https://newbmiao.github.io/</id>
  
  <author>
    <name>菜鸟Miao</name>
    <email>newbvirgil@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码封装也有碰壁的时候。。。</title>
    <link href="https://newbmiao.github.io/2024/08/17/iac-loves-simple.html"/>
    <id>https://newbmiao.github.io/2024/08/17/iac-loves-simple.html</id>
    <published>2024-08-17T06:42:25.000Z</published>
    <updated>2024-08-20T11:08:36.416Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**--><p>最近在搞<code>devops</code>，有一点对<code>Infrastructure as code</code>代码风格的感悟</p><p>直接从一个例子展开吧</p><p>假如需要将原来单账号下以下多网络分别创建到单独的账号下</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># network.auto.tfvars</span></span><br><span class="line"><span class="attr">vpcs</span> = &#123;</span><br><span class="line">  <span class="attr">network1</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>     = <span class="string">"vpc-1"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">network2</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>     = <span class="string">"vpc-2"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">network3</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>     = <span class="string">"vpc-3"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了网络创建复用自然需要使用<code>module</code>去按账号构建</p><p>（别想动态指定<code>provider</code>，<code>terraform</code>不支持！）</p><p>那问题是怎么将<code>vpc</code>的配置按账号分组传递给对应的<code>module</code></p><p>来看两种方案</p><a id="more"></a><h2 id="方案一：-动态分组"><a href="#方案一：-动态分组" class="headerlink" title="方案一： 动态分组"></a>方案一： 动态分组</h2><p>给每个<code>vpc</code>配置加<code>acct_key</code>, 然后代码动态分组</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># network.auto.tfvars</span></span><br><span class="line"><span class="attr">vpcs</span> = &#123;</span><br><span class="line">    <span class="attr">network1</span> = &#123;</span><br><span class="line">        <span class="attr">acct_key</span> = <span class="string">"a"</span></span><br><span class="line">        <span class="attr">name</span>     = <span class="string">"vpc-1"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">network2</span> = &#123;</span><br><span class="line">        <span class="attr">acct_key</span> = <span class="string">"a"</span></span><br><span class="line">        <span class="attr">name</span>     = <span class="string">"vpc-2"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">network3</span> = &#123;</span><br><span class="line">        <span class="attr">acct_key</span> = <span class="string">"b"</span></span><br><span class="line">        <span class="attr">name</span>     = <span class="string">"vpc-3"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## main.tf</span></span><br><span class="line">locals &#123;</span><br><span class="line">  <span class="comment"># 按 acct_key 聚合网络</span></span><br><span class="line">  <span class="attr">grouped_networks_as_array</span> = &#123;</span><br><span class="line">    for k, v <span class="keyword">in</span> var.vpcs :</span><br><span class="line">    v.<span class="attr">acct_key</span> =&gt; &#123; <span class="string">"<span class="subst">$&#123;k&#125;</span>"</span> = v &#125;...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">grouped_networks_as_object</span> = &#123;</span><br><span class="line">    for k, v <span class="keyword">in</span> local.grouped_networks_as_array :</span><br><span class="line">    <span class="attr">k</span> =&gt; merge(&#123;&#125;, v...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output <span class="string">"group_result"</span> &#123;</span><br><span class="line">  <span class="attr">value</span> = local.grouped_networks_as_object</span><br><span class="line">&#125;</span><br><span class="line">provider <span class="string">"external"</span> &#123;</span><br><span class="line">  <span class="attr">alias</span> = <span class="string">"acct_a"</span></span><br><span class="line">&#125;</span><br><span class="line">provider <span class="string">"external"</span> &#123;</span><br><span class="line">  <span class="attr">alias</span> = <span class="string">"acct_b"</span></span><br><span class="line">&#125;</span><br><span class="line">module <span class="string">"acct_a_vpcs_1"</span> &#123;</span><br><span class="line">  <span class="attr">source</span> = <span class="string">"./vpc"</span></span><br><span class="line">  <span class="attr">vpcs</span>   = local.grouped_networks_as_object.a</span><br><span class="line">  <span class="attr">providers</span> = &#123;</span><br><span class="line">    <span class="attr">external</span> = external.acct_a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module <span class="string">"acct_b_vpcs_1"</span> &#123;</span><br><span class="line">  <span class="attr">source</span> = <span class="string">"./vpc"</span></span><br><span class="line">  <span class="attr">vpcs</span>   = local.grouped_networks_as_object.b</span><br><span class="line">  <span class="attr">providers</span> = &#123;</span><br><span class="line">    <span class="attr">external</span> = external.acct_b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚合那里代码需要两段，主要是<code>terraform</code>的默认聚合，只会按<code>key</code>相同合并成<code>array</code>，但我们其实是要把<code>array</code>的每个元素合并成一个<code>object</code>, 方便后续按网络的<code>key</code>去索引资源创建的结果</p><p>（比如<code>module</code>输出了<code>vpc</code>资源的创建结果<code>vpcs</code>，就可以用<code>module.acct_a_vpcs.vpcs.network1</code>拿到<code>network1</code>的结果）</p><p>聚合后结果如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="attr">group_result</span> = &#123;</span><br><span class="line">    + <span class="attr">a</span> = &#123;</span><br><span class="line">        + <span class="attr">network1</span> = &#123;</span><br><span class="line">            + <span class="attr">acct_key</span> = <span class="string">"a"</span></span><br><span class="line">            + <span class="attr">name</span>     = <span class="string">"vpc-1"</span></span><br><span class="line">        &#125;</span><br><span class="line">        + <span class="attr">network2</span> = &#123;</span><br><span class="line">            + <span class="attr">acct_key</span> = <span class="string">"a"</span></span><br><span class="line">            + <span class="attr">name</span>     = <span class="string">"vpc-2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    + <span class="attr">b</span> = &#123;</span><br><span class="line">        + <span class="attr">network3</span> = &#123;</span><br><span class="line">            + <span class="attr">acct_key</span> = <span class="string">"b"</span></span><br><span class="line">            + <span class="attr">name</span>     = <span class="string">"vpc-3"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是程序员最擅长的代码封装么，配置没怎么变，代码动态一聚合就完成了变更的需求。</p><p>等等，再来看一个方案</p><h2 id="方案二：-静态分组"><a href="#方案二：-静态分组" class="headerlink" title="方案二： 静态分组"></a>方案二： 静态分组</h2><p>就是配置按账号重新拆分</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># network.auto.tfvars</span></span><br><span class="line"><span class="attr">accounts</span> = &#123;</span><br><span class="line">  <span class="attr">acct_a</span> = &#123;</span><br><span class="line">    <span class="attr">vpcs</span> = &#123;</span><br><span class="line">      <span class="attr">network1</span> = &#123;</span><br><span class="line">        <span class="attr">name</span> = <span class="string">"vpc-1"</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="attr">network2</span> = &#123;</span><br><span class="line">        <span class="attr">name</span> = <span class="string">"vpc-2"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">acct_b</span> = &#123;</span><br><span class="line">    <span class="attr">vpcs</span> = &#123;</span><br><span class="line">      <span class="attr">network3</span> = &#123;</span><br><span class="line">        <span class="attr">name</span> = <span class="string">"vpc-3"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用时按账号获取配置就是一目了然的事</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module <span class="string">"acct_a_vpcs"</span> &#123;</span><br><span class="line">  <span class="attr">source</span> = <span class="string">"./vpc"</span></span><br><span class="line">  <span class="attr">vpcs</span>   = var.acct_a.vpcs</span><br><span class="line">  <span class="attr">providers</span> = &#123;</span><br><span class="line">    <span class="attr">external</span> = external.acct_a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module <span class="string">"acct_b_vpcs"</span> &#123;</span><br><span class="line">  <span class="attr">source</span> = <span class="string">"./vpc"</span></span><br><span class="line">  <span class="attr">vpcs</span>   = var.acct_b.vpcs</span><br><span class="line">  <span class="attr">providers</span> = &#123;</span><br><span class="line">    <span class="attr">external</span> = external.acct_b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体看下来两种方案好像都差不多，但如果考虑代码的简洁与配置聚合的粒度的话，第二种就更胜一筹</p><p>毕竟对于IaC而言，一目了然的简洁比复杂的代码抽象更易于维护，基础设施的配置文件本来就不应该搞复杂。</p><p>哈哈, 代码封装也有碰壁的时候。</p><p>当然也有需要代码封装的时候，比如把多个账号的vpcs结果合并起来，便于其他资源跨账号按vpc key查询资源id，路由表id啥的</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  combined_acct_vpcs = merge(</span><br><span class="line">    <span class="class"><span class="keyword">module</span>.<span class="title">acct_a_vpcs</span>.<span class="title">vpcs</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">module</span>.<span class="title">acct_b_vpcs</span>.<span class="title">vpcs</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      基础设施的代码真的更偏爱简洁啊
    
    </summary>
    
    
      <category term="infra" scheme="https://newbmiao.github.io/categories/infra/"/>
    
    
      <category term="terraform" scheme="https://newbmiao.github.io/tags/terraform/"/>
    
  </entry>
  
  <entry>
    <title>FLT空投：2023年参与过web3的开发能领</title>
    <link href="https://newbmiao.github.io/2024/07/20/flt-dev-rewards.html"/>
    <id>https://newbmiao.github.io/2024/07/20/flt-dev-rewards.html</id>
    <published>2024-07-20T00:59:22.000Z</published>
    <updated>2024-07-24T02:17:18.292Z</updated>
    
    <content type="html"><![CDATA[<p>偶然发现一个参与过web3开发能领的空投：FLT-DROP，目前价值600刀左右。</p><p>这个可能在web3开发里不算啥新鲜事，对于一个只是玩票过web3的开发还是比较有意思的（之前研究ICP时写过一个<a href="https://github.com/NewbMiao/dvote" target="_blank" rel="noopener">web3投票</a>的github repo，算是浅浅的参与了下web3）。</p><p>那就记录下如何领到空投吧（毕竟第一次弄web3钱包，转错了网络还是很折腾的）</p><a id="more"></a><!-- **文章目录** --><!-- [TOC] --><h2 id="连接钱包"><a href="#连接钱包" class="headerlink" title="连接钱包"></a>连接钱包</h2><p>去网页 <a href="https://claim.fluence.network/" target="_blank" rel="noopener">https://claim.fluence.network/</a>, 先连接web3钱包</p><p>可以用自己喜欢的web3钱包，推荐浏览器插件版。没有钱包的先去生成一个，注意记好自己的seed phrase，是钱包唯一的密码标志</p><p>后边提取空投时还要确保eth钱包里够交2刀左右的gas费（手续费）</p><p><img src="/images/web3/connect-wallet.png" alt="OKX wallet"></p><p>我用的是OKX wallet，方便国内充币，亲测可用。需要的可以去<a href="https://www.cnouyi.studio/join/8589760" target="_blank" rel="noopener">OKX注册</a>，新用户被邀请能得虚拟币盲盒奖励。</p><h2 id="验证资格（eligible）"><a href="#验证资格（eligible）" class="headerlink" title="验证资格（eligible）"></a>验证资格（eligible）</h2><p>然后输入github用户名，查看是否有资格。</p><p>也可以直接去官方给出的<a href="https://claim.fluence.network/static/media/github-accounts.579a238639e5f9da5fd0.txt" target="_blank" rel="noopener">github名单</a>里搜自己的用户名</p><p>有资格的话会有2500flt可领，最开始是5000flt，每三个月减半。</p><h2 id="提交证明（proof）"><a href="#提交证明（proof）" class="headerlink" title="提交证明（proof）"></a>提交证明（proof）</h2><p>就是用本地运行命令证明你是github账号所有者，会用到本地ssh key，是安全的，担心的可以先看看源码以及<a href="https://foresightnews.pro/article/detail/55623" target="_blank" rel="noopener">这篇博客</a>的分析。</p><h2 id="获得空投（claim）"><a href="#获得空投（claim）" class="headerlink" title="获得空投（claim）"></a>获得空投（claim）</h2><p>这一步会从eth主网发起flt-drop转账到你的eth钱包地址。</p><blockquote><p>这里的flt-drop会在2个月后解锁，才可以兑换成flt去交易。</p></blockquote><p>如果你的eth地址不够手续费，会提示你需要充一些币到里边，gas费需要的eth币不等，一般价值$2-$6都有，我提取的是不到$2，自己选个手续费低的时候提交就行。</p><h2 id="充币"><a href="#充币" class="headerlink" title="充币"></a>充币</h2><p>这里最麻烦的就是eth里没币，需要充。可以OKX上<strong>C2C快捷交易</strong>买币到OKX账号，再<strong>提币</strong>到自己eth钱包地址。</p><p>注意的是这两步都会有手续费，所以提前算好把手续费覆盖了。</p><p><img src="/images/web3/deposit.png" alt="deposit"></p><blockquote><p> 比如按这个行情，提币这里至少要0.01054币才可以提，扣掉手续费0.00054你能提到0.01ETH，当然flt drop手续费只用一点，但你至少得充0.01054币才行。</p></blockquote><p>还有提币必须用ETH-ERC20(主网)。因为flt drop发起交易就是在主网上。（别问我怎么知道的，我第一次为手续费便宜提到了x-layer网，还得充OKB（x-layer的币种）操作退回OKX账号。。。）</p><h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>到这里空投就成功提取了，等两个月解锁再看看啥情况。</p><blockquote><p>到期可以用官方的工具转成FLT: <a href="https://claim.fluence.network/claim-flt" target="_blank" rel="noopener">https://claim.fluence.network/claim-flt</a></p></blockquote><p>另外提一句，flunence的web3应用开发支持rust，可以<a href="https://fluence.dev/docs/build/quickstarts/your_first_function" target="_blank" rel="noopener">构建云函数</a>，感兴趣的还是可以玩玩的，看着很方便上手。</p><p><img src="/images/web3/flt-done.png" alt="done"></p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      FLT空投：2023年参与过web3的开发能领
    
    </summary>
    
    
      <category term="web3" scheme="https://newbmiao.github.io/categories/web3/"/>
    
    
      <category term="web3" scheme="https://newbmiao.github.io/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>Rust工具集之arc-swap</title>
    <link href="https://newbmiao.github.io/2024/05/31/rust-arc-swap.html"/>
    <id>https://newbmiao.github.io/2024/05/31/rust-arc-swap.html</id>
    <published>2024-05-31T10:08:39.000Z</published>
    <updated>2024-05-31T10:42:45.569Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Rust</code>中常有配置读写的操作，一般可以用<code>Arc&lt;RwLock&lt;T&gt;&gt;</code>来实现，也可以用<code>arc-swap</code>来。有什么不同？</p><p>下面拿一个例子来说明下</p><p>假设有个配置，会有一个read thread不断获取配置，配置更新时要实时反映出来。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="RwLock"><a href="#RwLock" class="headerlink" title="RwLock"></a>RwLock</h2><p>用<code>RwLock</code>实现一下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, RwLock&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> config = Arc::new(RwLock::new(<span class="string">"Initial Config"</span>.to_string()));</span><br><span class="line">    <span class="keyword">let</span> shared_config = Arc::clone(&amp;config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> reader_thread = &#123;</span><br><span class="line">        thread::spawn(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// 1. read config</span></span><br><span class="line">            <span class="keyword">let</span> current_config = shared_config.read().unwrap();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Reader thread: &#123;&#125;"</span>, *current_config);</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the configuration after 1s</span></span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Updating config"</span>);</span><br><span class="line">    <span class="comment">// 2. write config</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current_config = config.write().unwrap();</span><br><span class="line">    *current_config = <span class="string">"Updated Config"</span>.to_string();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Updating config done"</span>);</span><br><span class="line">    reader_thread.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果你执行会发现，2修改配置后，1读取配置还是没有变化，而且不会打印<code>Updating config done</code>， 为啥呢？</p><p>这里其实是一个错误示范，<code>RwLock</code>读会持有锁，如果不释放锁，可以加多个读锁，但是不能获取写锁来修改。</p><p>修改代码，用作用域来释放锁</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. read config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> current_config = shared_config.read().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Reader thread: &#123;&#125;"</span>, *current_config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 2. write config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current_config = config.write().unwrap();</span><br><span class="line">    *current_config = <span class="string">"Updated Config"</span>.to_string();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Updating config done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在结果就满足预期了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Reader thread: Initial Config</span><br><span class="line">Updating config</span><br><span class="line">Updating config done</span><br><span class="line">Reader thread: Updated Config</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="arc-swap"><a href="#arc-swap" class="headerlink" title="arc-swap"></a>arc-swap</h2><p>这样使用<code>RwLock</code>修改配置需要注意锁的持有和释放，本质上是无法原子操作读写，导致代码实现上不够友好，也容易写出死锁的代码。</p><p><code>arc-swap</code>主要就是为了优化这点，原子操作资源，让你可以直接编写读写操作而无需顾虑锁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> arc_swap::ArcSwap;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> config = Arc::new(<span class="string">"Initial Config"</span>.to_string());</span><br><span class="line">    <span class="keyword">let</span> shared_config = Arc::new(ArcSwap::new(config));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> reader_thread = &#123;</span><br><span class="line">        <span class="keyword">let</span> shared_config = Arc::clone(&amp;shared_config);</span><br><span class="line">        thread::spawn(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> current_config = shared_config.load();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Reader thread: &#123;&#125;"</span>, current_config);</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> new_config = Arc::new(<span class="string">"Updated Config"</span>.to_string());</span><br><span class="line">    shared_config.store(new_config);</span><br><span class="line"></span><br><span class="line">    reader_thread.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样，代码是不是直截了当了许多？</p><p>一般很多读多写少的场景都可以试试<code>arc-swap</code>。</p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust工具集之arc-swap
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="arc-swap" scheme="https://newbmiao.github.io/tags/arc-swap/"/>
    
  </entry>
  
  <entry>
    <title>Rust设计模式：sealed trait续篇</title>
    <link href="https://newbmiao.github.io/2024/04/25/rust-sealed-trait-2.html"/>
    <id>https://newbmiao.github.io/2024/04/25/rust-sealed-trait-2.html</id>
    <published>2024-04-25T01:50:36.000Z</published>
    <updated>2024-04-25T02:19:03.241Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>之前写<code>sealed trait</code>时没提他在<code>oauth2-rs</code>中怎么用, 为什么用，这个其实在状态接口设计中很有用，今天展开聊聊。</p><a id="more"></a><p>首先复用上篇的代码，为模拟类库，用<code>mod oauth</code>包起来, 并暴露相关结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> oauth &#123;</span><br><span class="line">    <span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EndointSet</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EndpointNotSet</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">EndpointState</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> EndpointState <span class="keyword">for</span> EndointSet &#123;&#125;</span><br><span class="line">    <span class="keyword">impl</span> EndpointState <span class="keyword">for</span> EndpointNotSet &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Client</span></span>&lt;HasAuthUrl = EndpointNotSet, HasTokenUrl = EndpointNotSet&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        HasAuthUrl: EndpointState,</span><br><span class="line">        HasTokenUrl: EndpointState,</span><br><span class="line">    &#123;</span><br><span class="line">        auth_url: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        token_url: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">        phantom: std::marker::PhantomData&lt;(HasAuthUrl, HasTokenUrl)&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;HasAuthUrl: EndpointState, HasTokenUrl: EndpointState&gt; Client&lt;HasAuthUrl, HasTokenUrl&gt; &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">            Client &#123;</span><br><span class="line">                auth_url: <span class="literal">None</span>,</span><br><span class="line">                token_url: <span class="literal">None</span>,</span><br><span class="line">                phantom: PhantomData,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_auth_url</span></span>(<span class="keyword">self</span>, auth_url: &amp;<span class="built_in">str</span>) -&gt; Client&lt;EndointSet, HasTokenUrl&gt; &#123;</span><br><span class="line">            Client &#123;</span><br><span class="line">                auth_url: <span class="literal">Some</span>(auth_url.to_string()),</span><br><span class="line">                token_url: <span class="keyword">self</span>.token_url,</span><br><span class="line">                phantom: PhantomData,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_token_url</span></span>(<span class="keyword">self</span>, token_url: &amp;<span class="built_in">str</span>) -&gt; Client&lt;HasAuthUrl, EndointSet&gt; &#123;</span><br><span class="line">            Client &#123;</span><br><span class="line">                auth_url: <span class="keyword">self</span>.auth_url,</span><br><span class="line">                token_url: <span class="literal">Some</span>(token_url.to_string()),</span><br><span class="line">                phantom: PhantomData,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;HasTokenUrl: EndpointState&gt; Client&lt;EndointSet, HasTokenUrl&gt; &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_auth_url</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.auth_url.as_ref().unwrap()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;HasAuthUrl: EndpointState&gt; Client&lt;HasAuthUrl, EndointSet&gt; &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_token_url</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.token_url.as_ref().unwrap()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h2><p>这样的话，其实不设置<code>token_url</code>也可以绕过编译器检查，直接调用<code>get_token_url</code></p><p>比如自己实现一个带有<code>get_token_url</code>方法的<code>HackEndpointSet</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> oauth::*;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HackEndpointSet</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> EndpointState <span class="keyword">for</span> HackEndpointSet &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Client&lt;EndointSet, HackEndpointSet&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_token_url</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="string">"Hacked!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> client =</span><br><span class="line">    Client::&lt;EndointSet, HackEndpointSet&gt;::new().set_auth_url(<span class="string">"https://auth.example.com"</span>);</span><br><span class="line"><span class="comment">// .set_token_url("https://token.example.com");</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Auth URL: &#123;&#125;"</span>, client.get_auth_url());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Token URL: &#123;&#125;"</span>, client.get_token_url());</span><br></pre></td></tr></table></figure><h2 id="防止"><a href="#防止" class="headerlink" title="防止"></a>防止</h2><p>怎么防止呢？ <code>sealed trait</code>刚好就可以</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> oauth &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// sealed trait</span></span><br><span class="line">    <span class="keyword">mod</span> private &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">EndpointStateSealed</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">EndpointState</span></span>: private::EndpointStateSealed &#123;&#125;</span><br><span class="line">    <span class="keyword">impl</span> private::EndpointStateSealed <span class="keyword">for</span> EndointSet &#123;&#125;</span><br><span class="line">    <span class="keyword">impl</span> private::EndpointStateSealed <span class="keyword">for</span> EndpointNotSet &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，<code>HackEndpointSet</code>就没法实现<code>EndpointState trait</code></p><p>报错就会有<code>sealed trait</code>信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `HackEndpointSet: EndpointStateSealed` is not satisfied</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> src/main.rs:71:28</span></span><br><span class="line">   |</span><br><span class="line">71 |     impl EndpointState for HackEndpointSet &#123;&#125;</span><br><span class="line">   |                            ^^^^^^^^^^^^^^^ the trait `EndpointStateSealed` is not implemented for `HackEndpointSet`</span><br><span class="line">   |</span><br><span class="line">   = help: the following other types implement trait `EndpointStateSealed`:</span><br><span class="line">             oauth::EndointSet</span><br><span class="line">             EndpointNotSet</span><br><span class="line">note: required by a bound in `oauth::EndpointState`</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> src/main.rs:12:30</span></span><br><span class="line">   |</span><br><span class="line">12 |     pub trait EndpointState: private::EndpointStateSealed &#123;&#125;</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `EndpointState`</span><br><span class="line">   = note: `EndpointState` is a "sealed trait", because to implement it you also need to implement `oauth::private::EndpointStateSealed`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it</span><br><span class="line">   = help: the following types implement the trait:</span><br><span class="line">             oauth::EndointSet</span><br><span class="line">             oauth::EndpointNotSet</span><br></pre></td></tr></table></figure><p>最后附上<code>oauth2-rs</code>相关<a href="https://github.com/ramosbugs/oauth2-rs/blob/main/src/client.rs" target="_blank" rel="noopener">代码</a>地址, 感兴趣的可以去看下。</p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust设计模式：sealed trait续篇
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="sealed-trait" scheme="https://newbmiao.github.io/tags/sealed-trait/"/>
    
  </entry>
  
  <entry>
    <title>Rust设计模式：typestate</title>
    <link href="https://newbmiao.github.io/2024/04/24/rust-typestate-pattern.html"/>
    <id>https://newbmiao.github.io/2024/04/24/rust-typestate-pattern.html</id>
    <published>2024-04-24T06:00:19.000Z</published>
    <updated>2024-04-25T02:12:30.672Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>今天聊聊<code>typestate</code>模式。</p><p>新版<code>oauth2-rs</code>使用这个模式是想解决一个问题。</p><p>在<code>Oauth2</code>中，一般需要提前配置好<code>auth_url</code>, <code>token_url</code>, <code>introspect_url</code>等，才能调用后续的鉴权相关功能。比如没有<code>token_url</code>配置好，你就无法成功拿授权码（<code>code</code>）获取<code>token</code>。</p><p>但如果用户忘了配置，那就会在调用获取<code>token</code>时才得到运行时错误。</p><p>能不能在编译时就把错误暴露出来，让用户提前感知问题？</p><p>这就是<code>typestate</code>模式能很好解决的问题。</p><a id="more"></a><h2 id="typestate"><a href="#typestate" class="headerlink" title="typestate"></a>typestate</h2><p><code>typestate</code>是将状态定义到类型中，这样对于强类型约束的语言，可以很好的利用编译检查是否有状态和调用不符合的情况</p><p>比如如下两个<code>ticket</code>结构体表示不同状态的<code>ticket</code></p><p><code>EmptyTicket</code>只能<code>new</code>或者<code>book</code></p><p><code>book</code>会转化为<code>BookedTicket</code>, 这时只能<code>use</code>消费掉或<code>cancel</code>释放为<code>EmptyTicket</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmptyTicket</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BookedTicket</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EmptyTicket &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        EmptyTicket &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">book</span></span>(<span class="keyword">self</span>) -&gt; BookedTicket &#123;</span><br><span class="line">        BookedTicket &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BookedTicket &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">use</span></span>(<span class="keyword">self</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cancel</span></span>(<span class="keyword">self</span>) -&gt; EmptyTicket &#123;</span><br><span class="line">        EmptyTicket &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>那<code>oauth2-rs</code>如何解决文首提到的问题呢？</p><p>下边用一段代码模拟一下：</p><p><code>auth_url</code>和<code>token_url</code>都是<code>EndpointState trait</code></p><p>初始是未设置，用<code>EndointNotSet</code>表示状态</p><p>当其中一个设置时，返回的<code>Client</code>就会更新对应的状态类型为<code>EndointSet</code></p><p>这样后续相应的方法基于拥有此类型的<code>Client</code>, 就能保证必须先设置<code>url</code>才能调用相应的方法</p><p>比如</p><p><code>Client::&lt;EndointSet, EndpointNotSet&gt;</code>就声明了这个<code>Client</code>只能调用<code>auth_url</code>相关方法，不能调用<code>token_url</code>相关方法， 因为类型的状态上明确了<code>token_url</code>没有设置。</p><p>具体代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EndointSet</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EndpointNotSet</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">EndpointState</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EndpointState <span class="keyword">for</span> EndointSet &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> EndpointState <span class="keyword">for</span> EndpointNotSet &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Client</span></span>&lt;HasAuthUrl = EndpointNotSet, HasTokenUrl = EndpointNotSet&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    HasAuthUrl: EndpointState,</span><br><span class="line">    HasTokenUrl: EndpointState,</span><br><span class="line">&#123;</span><br><span class="line">    auth_url: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    token_url: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    phantom: std::marker::PhantomData&lt;(HasAuthUrl, HasTokenUrl)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;HasAuthUrl, HasTokenUrl&gt; Client&lt;HasAuthUrl, HasTokenUrl&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    HasAuthUrl: EndpointState,</span><br><span class="line">    HasTokenUrl: EndpointState,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Client &#123;</span><br><span class="line">            auth_url: <span class="literal">None</span>,</span><br><span class="line">            token_url: <span class="literal">None</span>,</span><br><span class="line">            phantom: PhantomData,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_auth_url</span></span>(<span class="keyword">self</span>, auth_url: &amp;<span class="built_in">str</span>) -&gt; Client&lt;EndointSet, HasTokenUrl&gt; &#123;</span><br><span class="line">        Client &#123;</span><br><span class="line">            auth_url: <span class="literal">Some</span>(auth_url.to_string()),</span><br><span class="line">            token_url: <span class="keyword">self</span>.token_url,</span><br><span class="line">            phantom: PhantomData,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_token_url</span></span>(<span class="keyword">self</span>, token_url: &amp;<span class="built_in">str</span>) -&gt; Client&lt;HasAuthUrl, EndointSet&gt; &#123;</span><br><span class="line">        Client &#123;</span><br><span class="line">            auth_url: <span class="keyword">self</span>.auth_url,</span><br><span class="line">            token_url: <span class="literal">Some</span>(token_url.to_string()),</span><br><span class="line">            phantom: PhantomData,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;HasTokenUrl&gt; Client&lt;EndointSet, HasTokenUrl&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    HasTokenUrl: EndpointState,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_auth_url</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.auth_url.as_ref().unwrap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;HasAuthUrl&gt; Client&lt;HasAuthUrl, EndointSet&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    HasAuthUrl: EndpointState,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_token_url</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.token_url.as_ref().unwrap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> client =</span><br><span class="line">        Client::&lt;EndointSet, EndpointNotSet&gt;::new().set_auth_url(<span class="string">"https://auth.example.com"</span>);</span><br><span class="line">    <span class="comment">// .set_token_url("https://token.example.com");</span></span><br><span class="line">    <span class="comment">// comment这里如果取消会报错，因为和set_token_url所需要的Client的类型声明不符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Auth URL: &#123;&#125;"</span>, client.get_auth_url());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Token URL: &#123;&#125;"</span>, client.get_token_url());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>这个<code>pattern</code>其实是2019年就提出来的，很感兴趣可以看看这篇<a href="https://cliffle.com/blog/rust-typestate" target="_blank" rel="noopener">博客</a></p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust设计模式：typestate
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="typestate" scheme="https://newbmiao.github.io/tags/typestate/"/>
    
  </entry>
  
  <entry>
    <title>Rust设计模式：sealed trait</title>
    <link href="https://newbmiao.github.io/2024/04/22/rust-sealed-trait.html"/>
    <id>https://newbmiao.github.io/2024/04/22/rust-sealed-trait.html</id>
    <published>2024-04-22T09:26:42.000Z</published>
    <updated>2024-04-25T01:52:49.701Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>最近升级之前写的一个<a href="https://github.com/NewbMiao/axum-koans/" target="_blank" rel="noopener">oauth2相关</a>的依赖时， 发现新版<a href="https://github.com/ramosbugs/oauth2-rs" target="_blank" rel="noopener">oauth2-rs</a>有些实现pattern很有意思，可以展开看看。</p><p>今天先看下<code>sealed trait</code>。</p><a id="more"></a><p>这种pattern是用来当自己的trait想限定一些实现方法时使用。</p><p>常规的trait定义都是很灵活的，不限定实现</p><p>比如下边<code>nosealed_trait</code>可以分别为<code>usize</code>和<code>i32</code>实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> nosealed_trait &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MyTrait</span></span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> nosealed_trait::MyTrait <span class="keyword">for</span> <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"MyTrait for usize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> nosealed_trait::MyTrait <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"MyTrait for i32"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果只想为<code>i32</code>实现呢？</p><p>可以让自己<code>trait</code>依赖一个不暴露的<code>super trait</code>，由<code>super trait</code>限定能有哪些实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sealed_trait &#123;</span><br><span class="line">    <span class="keyword">mod</span> private &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Sealed</span></span> &#123;&#125;</span><br><span class="line">        <span class="keyword">impl</span> Sealed <span class="keyword">for</span> <span class="built_in">i32</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">MySealedTrait</span></span>: private::Sealed &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> sealed_trait::MySealedTrait <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"MySealedTrait for i32"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用方想实现不在限定实现列表中的方法就会被编译错误阻止。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> sealed_trait::MySealedTrait <span class="keyword">for</span> <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_sealed_method</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"MySealedTrait for usize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误如下, 其中的<code>note</code>说的很明白。</p><blockquote><p>note: <code>MySealedTrait</code> is a “sealed trait”, because to implement it you also need to implement <code>sealedtrait::private::Sealed</code>, which is not accessible; this is usually done to force you to use one of the provided types that already implement it</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `usize: Sealed` is not satisfied</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> src/main.rs:34:37</span></span><br><span class="line">   |</span><br><span class="line">34 | impl sealedtrait::MySealedTrait for usize &#123;</span><br><span class="line">   |                                     ^^^^^ the trait `Sealed` is not implemented for `usize`</span><br><span class="line">   |</span><br><span class="line">   = help: the trait `Sealed` is implemented for `i32`</span><br><span class="line">note: required by a bound in `MySealedTrait`</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> src/main.rs:23:30</span></span><br><span class="line">   |</span><br><span class="line">23 |     pub trait MySealedTrait: private::Sealed &#123;</span><br><span class="line">   |                              ^^^^^^^^^^^^^^^ required by this bound in `MySealedTrait`</span><br><span class="line">   = note: `MySealedTrait` is a "sealed trait", because to implement it you also need to implement `sealedtrait::private::Sealed`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it</span><br><span class="line">   = help: the following type implements the trait:</span><br><span class="line">             i32</span><br></pre></td></tr></table></figure><p>下一篇再聊聊<code>typestate pattern</code>.</p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust设计模式：sealed trait
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="sealed-trait" scheme="https://newbmiao.github.io/tags/sealed-trait/"/>
    
  </entry>
  
  <entry>
    <title>如何用Rust快速构建AWS Lambda Function</title>
    <link href="https://newbmiao.github.io/2024/03/10/rust-lambda.html"/>
    <id>https://newbmiao.github.io/2024/03/10/rust-lambda.html</id>
    <published>2024-03-10T10:44:14.000Z</published>
    <updated>2024-03-10T12:11:31.964Z</updated>
    
    <content type="html"><![CDATA[<p><code>AWS Lambda Function</code>是轻量级的计算服务。优势是按需付费，专注于功能，服务本身如何构建暴露都有<code>AWS</code>都不需要自己操心。</p><p>而按需付费基本就是服务使用时长和内存占用了，这个优化的话那妥妥的是<code>Rust</code>的拿手好戏, 所以现在有好多<code>Serverless</code>服务都用<code>Rust</code>构建的<code>Lambda Function</code>来搞。</p><p>今天简单看下如何用<code>Rust</code>快速构建<code>Lambda Function</code>（别担心没aws环境，往下看，有本地沙箱可尝试）</p><a id="more"></a><!-- **文章目录** --><!-- [TOC] --><h2 id="cargo-lambda"><a href="#cargo-lambda" class="headerlink" title="cargo-lambda"></a>cargo-lambda</h2><p><code>cargo-lambda</code>这个库可以用来构建<code>Lambda Function</code> （也是官方推荐的工具）</p><p>如下代码安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap cargo-lambda/cargo-lambda</span><br><span class="line">brew install cargo-lambda</span><br></pre></td></tr></table></figure><p>然后初始化一个demo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo lambda new lambda-demo</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Is this <span class="keyword">function</span> an HTTP <span class="keyword">function</span>? Yes</span></span><br></pre></td></tr></table></figure><p>会自动生成初始化项目，引入相关依赖及运行时：<code>lambda-http</code>和<code>tokio</code>依赖</p><p>功能部分代码如下，提供一个<code>hello world</code>式请求处理：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lambda_http::&#123;run, service_fn, tracing, Body, Error, Request, RequestExt, Response&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">function_handler</span></span>(event: Request) -&gt; <span class="built_in">Result</span>&lt;Response&lt;Body&gt;, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> who = event</span><br><span class="line">        .query_string_parameters_ref()</span><br><span class="line">        .and_then(|params| params.first(<span class="string">"name"</span>))</span><br><span class="line">        .unwrap_or(<span class="string">"world"</span>);</span><br><span class="line">    <span class="keyword">let</span> message = <span class="built_in">format!</span>(<span class="string">"Hello &#123;who&#125;, this is an AWS Lambda HTTP request"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resp = Response::builder()</span><br><span class="line">        .status(<span class="number">200</span>)</span><br><span class="line">        .header(<span class="string">"content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">        .body(message.into())</span><br><span class="line">        .map_err(<span class="built_in">Box</span>::new)?;</span><br><span class="line">    <span class="literal">Ok</span>(resp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    tracing::init_default_subscriber();</span><br><span class="line"></span><br><span class="line">    run(service_fn(function_handler)).<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题外话，有没有感觉这个<code>service_fn</code>很眼熟?</p><p>这个接的<code>handler</code>也要求实现<code>Service trait</code>， 跟<code>tower service</code>一样。为啥呢，用了<code>hyper</code>库！<br>都说<code>hyper</code>基本就是<code>Rust</code>服务框架的基石不假。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>开发中用<code>watch</code>就能本地运行调试，支持变更重编译</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo lambda watch</span><br><span class="line">#  INFO invoke server listening on [::]:<span class="number">9000</span></span><br></pre></td></tr></table></figure><p>也可以命令行调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo lambda invoke lambda-demo --data-ascii "?name=newbmiao"</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo lambda build --release --arm64</span><br></pre></td></tr></table></figure><p>这样会将执行文件编译到<code>./target/lambda/lambda-demo/bootstrap</code></p><p>(注意：如果是<code>workspace</code>, 则需要去<code>workspace</code>下<code>target</code>目录找)</p><p>可执行文件压缩一下就可以用来部署了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip bootstrap.zip bootstrap</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>(这部分会设计比较多infrastructure，感兴趣的同学可以继续往下)</p><p>部署也很方便，不过难在不是所有人都有<code>aws</code>账户啊。</p><p>也好解决，<code>localstack</code>可以本地模拟<code>aws</code>环境</p><p>用<code>docker-compose up</code>起个<code>localstack</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3.8"</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  localstack:</span><br><span class="line">    container_name: <span class="string">"$&#123;LOCALSTACK_DOCKER_NAME:-localstack-main&#125;"</span></span><br><span class="line">    image: localstack/localstack</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"127.0.0.1:4566:4566"</span> <span class="comment"># LocalStack Gateway</span></span><br><span class="line">      - <span class="string">"127.0.0.1:4510-4559:4510-4559"</span> <span class="comment"># external services port range</span></span><br><span class="line">    environment:</span><br><span class="line">      <span class="comment"># LocalStack configuration: https://docs.localstack.cloud/references/configuration/</span></span><br><span class="line">      - DEBUG=$&#123;DEBUG:-<span class="number">0</span>&#125;</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">"$&#123;LOCALSTACK_VOLUME_DIR:-./volume&#125;:/var/lib/localstack"</span></span><br><span class="line">      - <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></span><br></pre></td></tr></table></figure><p>然后用<code>terraform</code>构建部署流程, 核心部分就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 构建</span><br><span class="line">resource &quot;aws_lambda_function&quot; &quot;lambda_demo&quot; &#123;</span><br><span class="line">  filename         &#x3D; &quot;bootstrap.zip&quot;</span><br><span class="line">  function_name    &#x3D; &quot;lambda_demo&quot;</span><br><span class="line">  role             &#x3D; aws_iam_role.iam_for_lambda_tf.arn</span><br><span class="line">  handler          &#x3D; &quot;bootstrap&quot;</span><br><span class="line">  source_code_hash &#x3D; filebase64sha256(&quot;bootstrap.zip&quot;)</span><br><span class="line">  runtime          &#x3D; &quot;provided.al2&quot;</span><br><span class="line">  architectures    &#x3D; [&quot;arm64&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下就是权限以及获取<code>lambda function</code>地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_lambda_function_url&quot; &quot;lambda_demo_url&quot; &#123;</span><br><span class="line">  function_name      &#x3D; aws_lambda_function.lambda_demo.arn</span><br><span class="line">  authorization_type &#x3D; &quot;NONE&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;function_url&quot; &#123;</span><br><span class="line">  description &#x3D; &quot;Function URL.&quot;</span><br><span class="line">  value       &#x3D; aws_lambda_function_url.lambda_demo_url.function_url</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_role&quot; &quot;iam_for_lambda_tf&quot; &#123;</span><br><span class="line">  name &#x3D; &quot;iam_for_lambda_tf&quot;</span><br><span class="line"></span><br><span class="line">  assume_role_policy &#x3D; &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;Version&quot;: &quot;2012-10-17&quot;,</span><br><span class="line">  &quot;Statement&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Action&quot;: &quot;sts:AssumeRole&quot;,</span><br><span class="line">      &quot;Principal&quot;: &#123;</span><br><span class="line">        &quot;Service&quot;: &quot;lambda.amazonaws.com&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Effect&quot;: &quot;Allow&quot;,</span><br><span class="line">      &quot;Sid&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样从<code>terraform apply</code> 部署结果中能拿到访问地址, 比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Apply complete! Resources: 3 added, 0 changed, 0 destroyed.</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">function_url = "http://h6v7ozz6ay3h6apr2hi5edsmnc0wpz80.lambda-url.us-east-1.localhost.localstack.cloud:4566/</span><br></pre></td></tr></table></figure><p>想上手试下的话，详细代码见<a href="https://github.com/NewbMiao/rust-koan/tree/master/aws-lambda/lambda-demo" target="_blank" rel="noopener">lambda-demo</a>, <code>build.sh</code>有详细打包流程</p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      如何用Rust快速构建Aws lambda
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="aws-lambda" scheme="https://newbmiao.github.io/tags/aws-lambda/"/>
    
  </entry>
  
  <entry>
    <title>Rust之tower如何构建请求中间件</title>
    <link href="https://newbmiao.github.io/2024/02/03/rust-tower-service.html"/>
    <id>https://newbmiao.github.io/2024/02/03/rust-tower-service.html</id>
    <published>2024-02-03T10:25:19.000Z</published>
    <updated>2024-02-03T14:50:33.958Z</updated>
    
    <content type="html"><![CDATA[<p>提到<code>Rust</code>请求中间件, 就不能不提<code>tower</code>。</p><p><code>tower</code>是一个请求协议无关的的中间件定义类库，主要定义了<code>Service</code>和<code>Layer</code>两个<code>trait</code>来帮助实现可重用的请求处理中间件。</p><p>今天拿聊聊它如何巧妙构建起中间件。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="初始请求"><a href="#初始请求" class="headerlink" title="初始请求"></a>初始请求</h2><p>假设我们有一个请求<code>handler</code>, 用<code>hyper</code>官方的<code>hello world</code>例子代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> http_body_util::Full;</span><br><span class="line"><span class="keyword">use</span> hyper::&#123;</span><br><span class="line">    body::&#123;Bytes, Incoming&#125;,</span><br><span class="line">    server::conn::http1,</span><br><span class="line">    Request, Response,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> hyper_util::rt::TokioIo;</span><br><span class="line"><span class="keyword">use</span> std::&#123;convert::Infallible, net::SocketAddr&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">handler</span></span>(_: Request&lt;Incoming&gt;) -&gt; <span class="built_in">Result</span>&lt;Response&lt;Full&lt;Bytes&gt;&gt;, Infallible&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(Response::new(Full::new(Bytes::from(<span class="string">"Hello, World!"</span>))))</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> addr = SocketAddr::from(([<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="number">3000</span>));</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(addr).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (stream, _) = listener.accept().<span class="keyword">await</span>?;</span><br><span class="line">        <span class="keyword">let</span> io = TokioIo::new(stream);</span><br><span class="line">        tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="comment">// 请求在这里转成了Service</span></span><br><span class="line">            <span class="keyword">let</span> svc = hyper::service::service_fn(handler);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(err) = http1::Builder::new().serve_connection(io, svc).<span class="keyword">await</span> &#123;</span><br><span class="line">                eprintln!(<span class="string">"server error: &#123;&#125;"</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>service_fn</code>将<code>handler</code>转成了<code>Service</code>，也就是<code>server</code>启动时要的是一个实现了<code>Service trait</code>的请求处理函数，这是后边构建中间件的基础。</p><blockquote><p>注意，在hyper 发布v1之后，这里的<code>Service</code>准确说不是<code>tower的Service trait</code>，但理念是一样，我们后边在讲他们接口的不同</p></blockquote><p>这时如果想在处理上边加上<code>Logger</code>，<code>Timeout</code>两个流程来分别记录请求日志和超时约束， 能很灵活的按如下方式组织</p><p><img src="/images/rust/tower-service.png" alt="tower-service"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = hyper::service::service_fn(handler);</span><br><span class="line"><span class="comment">// 增加两个layer中间件</span></span><br><span class="line"><span class="keyword">let</span> svc = ServiceBuilder::new()</span><br><span class="line">    .layer_fn(Logger::new)</span><br><span class="line">    .layer_fn(|s| Timeout::new(s, std::time::Duration::from_secs(<span class="number">5</span>)))</span><br><span class="line">    .service(svc);</span><br><span class="line"><span class="comment">// 先忽略下边为了接口转换，后边在展开这里</span></span><br><span class="line"><span class="comment">// let svc = TowerToHyperService::new(svc);</span></span><br></pre></td></tr></table></figure><h2 id="Service-trait"><a href="#Service-trait" class="headerlink" title="Service trait"></a>Service trait</h2><p>这样处理，就像是一个<code>service</code>链，一个<code>service</code>处理完，再调用下一个<code>service</code></p><p>所以<code>tower</code>定义了如下<code>Service trait</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Output = <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;;</span><br><span class="line">    <span class="comment">// 请求是否可以处理</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_ready</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;<span class="built_in">Result</span>&lt;(), Self::Error&gt;&gt;;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>poll_ready</code>是决定是否可以执行请求处理<code>call</code>前的判断。</p><p><code>call</code>拿到请求，返回一个异步处理的结果，这样当请求执行耗时时不阻塞其他请求的处理。</p><p>说个题外话，你可能会好奇为什么这里要返回一个<code>Future</code>而不是用<code>async</code>。</p><p>这是因为之前<code>Rust</code>不支持<code>trait</code>中定义异步函数。不过<code>Rust 1.75</code>开始支持了，如果后边换成下边的实现就不奇怪了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: Request) -&gt; <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现middleware"><a href="#实现middleware" class="headerlink" title="实现middleware"></a>实现middleware</h2><p>拿<code>Logger middleware</code>实现来看如何构建起<code>service</code>链</p><p>注释及代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tower::Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Logger</span></span>&lt;S&gt; &#123;</span><br><span class="line">    inner: S,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;S&gt; Logger&lt;S&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(inner: S) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Logger &#123; inner &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Req</span></span> = hyper::Request&lt;Incoming&gt;;</span><br><span class="line"><span class="keyword">impl</span>&lt;S&gt; Service&lt;Req&gt; <span class="keyword">for</span> Logger&lt;S&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: Service&lt;Req&gt; + <span class="built_in">Clone</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Logger拿到的也是一个Service，返回类型也没有变化，直接指定即可</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span> = S::Response;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = S::Error;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span> = S::Future;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll_ready</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">'_</span>&gt;,</span><br><span class="line">    ) -&gt; std::task::Poll&lt;<span class="built_in">Result</span>&lt;(), Self::Error&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 直接可以处理，无需额外满足条件</span></span><br><span class="line">        <span class="keyword">self</span>.inner.poll_ready(cx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: Req) -&gt; Self::Future &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"processing request: &#123;&#125; &#123;&#125;"</span>, req.method(), req.uri().path());</span><br><span class="line">        <span class="comment">// 处理完调用下一个Service</span></span><br><span class="line">        <span class="keyword">self</span>.inner.call(req)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样添加<code>Logger</code>可以这么添加</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = Logger::new(svc);</span><br></pre></td></tr></table></figure><p>再加个<code>Timeout</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = Timeout::new(svc, std::time::Duration::from_secs(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>不够优雅，而且执行顺序也是反的，最后添加的中间件先执行，要是链式操作就好了，这时就到<code>Layer trait</code>显身手了</p><h2 id="Layer-trait"><a href="#Layer-trait" class="headerlink" title="Layer trait"></a>Layer trait</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Layer</span></span>&lt;S&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Service</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">layer</span></span>(&amp;<span class="keyword">self</span>, inner: S) -&gt; Self::Service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要实现以上<code>Layer trait</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;S&gt; Layer&lt;S&gt; <span class="keyword">for</span> Logger&lt;S&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Service</span></span> = Logger&lt;S&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">layer</span></span>(&amp;<span class="keyword">self</span>, inner: S) -&gt; Self::Service &#123;</span><br><span class="line">        Logger &#123; inner &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就能用<code>ServiceBuilder</code>构建<code>service</code>链</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tower::ServiceBuilder::new()</span><br><span class="line">    .layer(LoggerLayer)</span><br><span class="line">    .layer_fn(|s| Timeout::new(s, std::time::Duration::from_secs(<span class="number">5</span>)))</span><br><span class="line">    .service(svc);</span><br></pre></td></tr></table></figure><p>当然<code>layer_fn</code>也可以直接将函数转为实现<code>Layer trait</code></p><p>最重要的是顺序是按调用顺序。</p><h2 id="hyper-Service-trait"><a href="#hyper-Service-trait" class="headerlink" title="hyper Service trait"></a>hyper Service trait</h2><p><code>hyper</code>之前依赖了<code>tower Service</code>，但v1稳定版发布前替换成了自己的<code>Service</code>。</p><p>一方面是<code>tower</code>还没有稳定版本</p><p>另一方面为了简化请求处理：</p><ul><li><p>移除了<code>poll_ready</code></p></li><li><p><code>call</code>也不再需要<code>&amp;mut self</code>，即不再考虑通过其修改请求，如果需要的话可以加<code>Arc&lt;Mutex&lt;_&gt;&gt;</code>的<code>state</code></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Service</span></span>&lt;Request&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Response</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Future</span></span>: Future&lt;Output = <span class="built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, req: Request) -&gt; Self::Future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就是为什么如果你想直接复用<code>tower Serivice</code>（如<code>Timeout</code>等）需要<code>TowerToHyperService</code>转一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = TowerToHyperService::new(svc);</span><br></pre></td></tr></table></figure><p>另外<code>hyper</code>作为比较底层的请求库，很多<code>web</code>框架（<code>Axum</code>, <code>Actix web</code>等）都依赖他。 也就也支持了<code>tower</code>, 使得<code>tower</code>实现的中间件就更容易复用了。</p><p>总的来说，<code>tower</code>能用<code>Service trait</code>构建一个请求中间件的规范，确实很神奇。从目前实现反推似乎很简单，但其实设计过程中还是有很多考虑的，尤其像需要处理返回的<code>future</code>时。推荐看看官方的这篇<a href="https://tokio.rs/blog/2021-05-14-inventing-the-service-trait" target="_blank" rel="noopener">inventing-the-service-trait</a>。</p><p>想了解中间件实现过程的话也推荐看看David Pedersen的<code>Rust live coding</code><a href="https://www.youtube.com/watch?v=16sU1q8OeeI&t=4227s" target="_blank" rel="noopener">Tower deep dive</a> （看不了的同学可以B站找找…）</p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust之tower如何构建请求中间件
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="tower" scheme="https://newbmiao.github.io/tags/tower/"/>
    
  </entry>
  
  <entry>
    <title>tokio之如何观测Rust异步任务的调度</title>
    <link href="https://newbmiao.github.io/2024/01/26/rust-tokio-task-tracing.html"/>
    <id>https://newbmiao.github.io/2024/01/26/rust-tokio-task-tracing.html</id>
    <published>2024-01-26T11:02:37.000Z</published>
    <updated>2024-01-26T11:52:02.510Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>Rust</code>的异步是以<code>task</code>的调度来构建的。<code>task</code>作为抽象在语言层面的调度单元。</p><p>那如果想要观测其的调度执行有没有办法呢？。</p><p>有的！异步<code>runtime</code>库<code>tokio</code>就有个<code>tokio-console</code>可以实现对异步调度的观测和分析，其对了解调度的机制和性能分析都很有帮助。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>其调度的观测是需要依赖程序段添加 <code>console-subscriber</code> 来上报<code>runtime</code>的调度信息，然后由命令行程序<code>tokio-console</code>进行数据的统计展示。</p><p>这个功能还属于unstable，需要引入时做一些设置。</p><p>具体来说，需要在引入<code>tokio</code>时启用<code>tracing</code>, 如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">console-subscriber = <span class="string">"0.2.0"</span></span><br><span class="line">tokio = &#123; version = <span class="string">"1.35.1"</span>, features = [<span class="string">"full"</span>, <span class="string">"tracing"</span>] &#125;</span><br></pre></td></tr></table></figure><p>异步代码<code>main</code>中也需要初始化<code>console_subscriber</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    console_subscriber::init();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行时需要加上编译参数： <code>RUSTFLAGS=&quot;--cfg tokio_unstable&quot; cargo run</code></p><p>也可以在项目根目录用<code>.cargo/config.toml</code>全局配置, 如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[build]</span><br><span class="line">rustflags = [<span class="string">"--cfg"</span>, <span class="string">"tokio_unstable"</span>]</span><br></pre></td></tr></table></figure><p>这样同时运行<code>tokio-console</code>就能观测异步任务的调度了。</p><p>（<code>cargo install tokio-console</code>可以安装）</p><h2 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h2><p>以之前《Rust并发控制之Semaphore-两线程交替打印》代码来观测为例</p><p>修改部分详见代码注释:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;sync::Arc, time::Duration&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::&#123;sync::Semaphore, task, time::sleep&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 注意. 初始化tracing收集</span></span><br><span class="line">    console_subscriber::init();</span><br><span class="line">    <span class="comment">// 线程1的令牌桶1初始一个令牌，可以先打印1</span></span><br><span class="line">    <span class="keyword">let</span> semaphore = Arc::new(Semaphore::new(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> semaphore2 = semaphore.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2的令牌桶2初始没有令牌，直到1打印后增加令牌</span></span><br><span class="line">    <span class="keyword">let</span> semaphore_wait = Arc::new(Semaphore::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> semaphore_wait2 = semaphore_wait.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意. 使用task::Builder来增加task名字，否则等同tokio::spawn</span></span><br><span class="line">    <span class="keyword">let</span> t1 = task::Builder::default()</span><br><span class="line">        .name(<span class="string">"t1"</span>)</span><br><span class="line">        .spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="keyword">let</span> permit = semaphore.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">                 <span class="comment">// 注意. 增加等待时间，便于观测</span></span><br><span class="line">                sleep(Duration::from_secs(i)).<span class="keyword">await</span>;</span><br><span class="line">                <span class="comment">// 消耗令牌，不放回令牌桶1</span></span><br><span class="line">                permit.forget();</span><br><span class="line">                <span class="comment">// 令牌桶2增加令牌，可以打印2</span></span><br><span class="line">                semaphore_wait2.add_permits(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = task::Builder::default()</span><br><span class="line">        .name(<span class="string">"t2"</span>)</span><br><span class="line">        .spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="keyword">let</span> permit = semaphore_wait.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">                <span class="comment">// 注意. 增加等待时间，便于观测</span></span><br><span class="line">                sleep(Duration::from_secs(i)).<span class="keyword">await</span>;</span><br><span class="line">                <span class="comment">// 消耗令牌，不放回令牌桶2</span></span><br><span class="line">                permit.forget();</span><br><span class="line">                <span class="comment">// 令牌桶1增加令牌，可以打印1</span></span><br><span class="line">                semaphore2.add_permits(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    tokio::try_join!(t1, t2).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观测效果"><a href="#观测效果" class="headerlink" title="观测效果"></a>观测效果</h2><p>得到的观测结果如下，可以切换为<code>task</code>视图(按键<code>t</code>)和<code>resource</code>视图(按键<code>r</code>)：</p><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>对于<code>task</code>能看到调度时间（<code>Total, Busy, Sched, Idle</code>），次数(<code>Polls</code>)，状态(<code>state</code>)等。</p><blockquote><p>想详细了解时间可以看看这篇博客：<a href="https://hegdenu.net/posts/task-scheduled-time-in-console/" target="_blank" rel="noopener">task-scheduled-time-in-console</a></p></blockquote><p><img src="/images/rust/async-task.png" alt="task"></p><p>左右按键可以选择列，上下按键可以选择行，回车会展开对应行详情， 比如<code>task-t2</code></p><p>里边能看到相应waker的一些信息，也会有更细粒度的时间分布图</p><p>比较容易发现耗时不正常的<code>task</code>。</p><p><img src="/images/rust/async-task-detail.png" alt="task-detail"></p><h3 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h3><p>对于<code>resource</code>, 能看到执行了哪些类型的异步操作</p><p><img src="/images/rust/async-resource.png" alt="resource"></p><p>详情中是对这个操作不同时间调用的详细展开。</p><p>比如<code>t2</code>中<code>semaphore_wait.acquire</code>的三次调用</p><p><img src="/images/rust/async-resource-detail.png" alt="resource-details"></p><p>本文代码详见<a href="https://github.com/NewbMiao/rust-koan/tree/master/tokio-play" target="_blank" rel="noopener">tokio-play</a></p><p>想查看更多异步观测的例子建议查看下<a href="https://github.com/tokio-rs/console/tree/main/console-subscriber/examples" target="_blank" rel="noopener">官方的例子</a></p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      tokio之如何观测Rust异步任务的调度
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="tokio" scheme="https://newbmiao.github.io/tags/tokio/"/>
    
      <category term="tracing" scheme="https://newbmiao.github.io/tags/tracing/"/>
    
  </entry>
  
  <entry>
    <title>Rayon魔法：使Rust并行编程变得轻而易举</title>
    <link href="https://newbmiao.github.io/2024/01/13/rust-rayon-parallel.html"/>
    <id>https://newbmiao.github.io/2024/01/13/rust-rayon-parallel.html</id>
    <published>2024-01-13T03:43:34.000Z</published>
    <updated>2024-01-13T10:05:36.180Z</updated>
    
    <content type="html"><![CDATA[<p><code>Rayon</code>库是一个数据并行化（<code>data-parallelism</code>）的 <code>Rust</code>库。在并行编程里是一个很有趣的存在， 且非常的容易上手。它可以很轻松的将同步计算流程转化为并行计算。而且基本能保证编译通过就不会有<code>data race</code>。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="同步转并行"><a href="#同步转并行" class="headerlink" title="同步转并行"></a>同步转并行</h2><p>假设有个如下的求和的同步代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> sum: <span class="built_in">i32</span> = (<span class="number">0</span>..<span class="number">100</span>)</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|i| &#123;</span><br><span class="line">            <span class="comment">// Simulate some computation</span></span><br><span class="line">            sleep(Duration::from_nanos(<span class="number">1</span>));</span><br><span class="line">            i</span><br><span class="line">        &#125;)</span><br><span class="line">        .sum();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">4950</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要转成并行，只需要<code>into_iter</code>变成<code>into_par_iter</code></p><p><code>Rayon</code>会将同步的遍历转成并行的遍历，而且保证返回的顺序是一致的，瞬间并行是不是！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sum: <span class="built_in">i32</span> = (<span class="number">0</span>..<span class="number">100</span>)</span><br><span class="line">        .into_par_iter() <span class="comment">// 这里</span></span><br><span class="line">        .map(|i| &#123;</span><br><span class="line">            <span class="comment">// Simulate some computation</span></span><br><span class="line">            sleep(Duration::from_nanos(<span class="number">1</span>));</span><br><span class="line">            i</span><br><span class="line">        &#125;)</span><br><span class="line">        .sum();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">4950</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>divan</code>在 10核的M1 pro上测试结果如下，一行改变让代码速度提升了不少。</p><table><thead><tr><th>Benchmark</th><th>Fastest</th><th>Slowest</th><th>Median</th><th>Mean</th><th>Samples</th><th>Iterations</th></tr></thead><tbody><tr><td>iter</td><td>549.2 µs</td><td>1.244 ms</td><td>687.4 µs</td><td>738.5 µs</td><td>100</td><td>100</td></tr><tr><td>par_iter</td><td>195 µs</td><td>488.1 µs</td><td>315.1 µs</td><td>321.9 µs</td><td>100</td><td>100</td></tr></tbody></table><!-- ![bench](/images/rust/rayon_par_bench.png) --><h2 id="背后的魔法"><a href="#背后的魔法" class="headerlink" title="背后的魔法"></a>背后的魔法</h2><p>这个并行遍历是怎么处理的呢？</p><p><code>Rayon</code>利用一个可伸缩线程池来执行并行任务，默认情况下，线程池的大小与系统的逻辑核心数量相匹配。</p><p>在进行并行任务时，<code>Rayon</code>将当前任务拆分成多个子任务（依据线程池大小），并尽可能地将它们分配给空闲的线程以执行，每个线程有自己的本地任务队列。</p><p>如果当前有空闲线程，但已分配的任务仍在等待其线程完成当前任务，空闲线程将尝试执行<code>work stealing</code>，从其他线程任务队列中中窃取一些任务来执行，以确保最大程度地利用CPU资源。</p><p>最终，将并行任务的结果进行两两合并，将线程结果全部汇总以完成整个并行计算过程。</p><p>这里任务拆分和<code>work stealing</code>就是将并行任务分而治之的精髓。</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>其底层很多使用了<code>join</code>, 将两个任务并行执行，并等待任务结果一起返回：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="built_in">vec!</span>[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (sum1, sum2) = rayon::join(</span><br><span class="line">        || v1.par_iter().sum::&lt;<span class="built_in">i32</span>&gt;(), </span><br><span class="line">        || v2.par_iter().sum::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"sum1: &#123;&#125;, sum2: &#123;&#125;"</span>, sum1, sum2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="par-bridge"><a href="#par-bridge" class="headerlink" title="par_bridge"></a>par_bridge</h2><p>常规能很容易并行化拆分的<code>par_iter</code>就可以了，但是如果遇到不容易并行化的（有阻塞等待等），如<code>channel</code>或者文件、网络IO的操作, 则可以用<code>par_bridge</code>。</p><p>性能会有些损耗，因为其执行的方式是每次获取下一个可遍历的内容，分发到线程池内可用线程上执行，同时也不保证结果返回的顺序。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::iter::ParallelBridge;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::ParallelIterator;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rx = &#123;</span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = channel();</span><br><span class="line"></span><br><span class="line">        (<span class="number">1</span>..=<span class="number">3</span>).into_iter().for_each(|i| &#123;</span><br><span class="line">            <span class="keyword">let</span> _ = tx.send(i);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rx</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> output: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = rx.into_iter().par_bridge().collect();</span><br><span class="line">    output.sort_unstable(); <span class="comment">// 重新保证顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;*output, &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，对于串行化遍历任务，一般都可以用<code>Rayon</code>转化为并行处理，当然也要看有没有转化的必要，常规简单遍历自然是不需要并行化的，毕竟线程和任务并行调度也是有开销的。</p><p>想了解更多，推荐看看<a href="https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/" target="_blank" rel="noopener">Rayon: data parallelism in Rust</a></p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rayon魔法：使Rust并行编程变得轻而易举
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rayon" scheme="https://newbmiao.github.io/tags/rayon/"/>
    
  </entry>
  
  <entry>
    <title>Rust异步编程之Future并发处理</title>
    <link href="https://newbmiao.github.io/2024/01/08/rust-async-multi-future-concurrency.html"/>
    <id>https://newbmiao.github.io/2024/01/08/rust-async-multi-future-concurrency.html</id>
    <published>2024-01-08T06:34:39.000Z</published>
    <updated>2024-01-06T17:02:59.781Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们知道，<code>Rust</code>的<code>Future</code>是异步执行，<code>await</code>时是阻塞在当前的异步任务<code>task</code>上，直到完成。</p><p>当多个异步任务执行时，如果只能都阻塞一个个执行，那就变成同步串行执行了，当然不是我们通常希望的并发处理方式，今天就来聊聊多个异步任务的一些并发处理方式。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>多个异步任务执行时，如果希望全部执行完成后统一返回，可以让他们都并发去执行，等全部完成后再一起返回。<code>join!</code>宏就可以实现它。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn1</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn2</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (first, second) = tokio::join!(async_fn1(), async_fn2());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(first, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(second, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-join"><a href="#try-join" class="headerlink" title="try_join"></a>try_join</h2><p>如果其中有失败的话，也会返回失败的<code>Err</code>。如果想一有失败就立马返回，不等待其他任务完成，可以使用<code>try_join!</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn1</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">u32</span>, &amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn2</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">u32</span>, &amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Err</span>(<span class="string">"async_fn2 failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> res = tokio::try_join!(async_fn1(), async_fn2());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> res &#123;</span><br><span class="line">        <span class="literal">Ok</span>((first, second)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"first = &#123;&#125;, second = &#123;&#125;"</span>, first, second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"error: &#123;&#125;"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p>上边<code>join</code>虽然是让多个异步任务并发执行，但其实际还是在同一个<code>task</code>上异步执行，如果想让每个异步任务都在一个新的<code>task</code>上<strong>独立</strong>执行，可以用<code>spawn</code>。</p><p>异步任务<code>spawn</code>后会在后台立即开始运行，即便没有对其返回的<code>JoinHandle</code>进行<code>await</code></p><p>这就有点像多线程里的<code>spawn</code>，只不过这里粒度不是线程，是<code>task</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::future::join_all;</span><br><span class="line"><span class="keyword">use</span> tokio::&#123;join, task::JoinHandle&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_op</span></span>(id: <span class="built_in">i32</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">"Start task &#123;&#125;"</span>, id);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> ops = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> tasks: <span class="built_in">Vec</span>&lt;JoinHandle&lt;<span class="built_in">String</span>&gt;&gt; = ops</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|op| tokio::spawn(async_op(op)))</span><br><span class="line">        .collect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// option 1</span></span><br><span class="line">    <span class="comment">// let outputs = join!(</span></span><br><span class="line">    <span class="comment">//     tasks.pop().unwrap(),</span></span><br><span class="line">    <span class="comment">//     tasks.pop().unwrap(),</span></span><br><span class="line">    <span class="comment">//     tasks.pop().unwrap()</span></span><br><span class="line">    <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!("&#123;:?&#125;", outputs);</span></span><br><span class="line">    <span class="comment">// tuple of results:</span></span><br><span class="line">    <span class="comment">// (Ok("Start task 3"), Ok("Start task 2"), Ok("Start task 1"))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// option 2</span></span><br><span class="line">    <span class="keyword">let</span> outputs = join_all(tasks).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, outputs);</span><br><span class="line">    <span class="comment">// vector of results:</span></span><br><span class="line">    <span class="comment">// [Ok("Start task 1"), Ok("Start task 2"), Ok("Start task 3")]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>如果是多个异步分支（<code>branch</code>）有一个完成就返回，并取消(<code>drop</code>来释放异步资源)其他异步分支的话，可以用<code>select</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn1</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn2</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        _ = async_fn1() =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"async_fn1() completed first"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        _ = async_fn2() =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"async_fn2() completed first"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><p>这里<code>select</code>会对每个分支随机执行，顺序是不保证的。如果期望顺序执行，可以用<code>biased</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            <span class="comment">// 顺序执行</span></span><br><span class="line">            biased;</span><br><span class="line"></span><br><span class="line">            _ = <span class="keyword">async</span> &#123;&#125;, <span class="keyword">if</span> count &lt; <span class="number">1</span> =&gt; &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">assert_eq!</span>(count, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            _ = <span class="keyword">async</span> &#123;&#125;, <span class="keyword">if</span> count &lt; <span class="number">2</span> =&gt; &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">assert_eq!</span>(count, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="precondition"><a href="#precondition" class="headerlink" title="precondition"></a>precondition</h3><p>上边例子中，分支使用了<code>if precondition</code>，如果当前<code>select</code>循环中运行到该分支，条件满足则执行；不满足的话会标记分支为失效（<code>disabled</code>）本次<code>select</code>中不会执行。</p><p>如果在<code>loop</code>中，下一次进入<code>select</code>循环会重新标记<code>disabled</code>状态</p><p>另外当前循环如果所以分支都被标记为<code>disabled</code>状态，就必须要有<code>else</code>分支，使<code>select</code>仍可运行。不然就会收到<code>panic</code>: <code>all branches are disabled and there is no else branch</code>.</p><h3 id="分支修改"><a href="#分支修改" class="headerlink" title="分支修改"></a>分支修改</h3><p><code>select</code>的分支也可修改， 比如下边通过<code>Pin::set</code>来修改<code>Pin</code>住的异步任务。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">action</span></span>(input: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> input &#123;</span><br><span class="line">        <span class="literal">Some</span>(input) =&gt; <span class="literal">Some</span>(input.to_string()),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = tokio::sync::mpsc::channel(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> operation = action(<span class="literal">None</span>);</span><br><span class="line">    tokio::pin!(operation);</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">1</span>).<span class="keyword">await</span>;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">3</span>).<span class="keyword">await</span>;</span><br><span class="line">        <span class="keyword">let</span> _ = tx.send(<span class="number">2</span>).<span class="keyword">await</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">select!</span> &#123;</span><br><span class="line">            res = &amp;<span class="keyword">mut</span> operation, <span class="keyword">if</span> !done =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Got = &#123;:?&#125;"</span>, res);</span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(_) = res &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">Some</span>(v) = rx.recv() =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// `.set` is a method on `Pin`.</span></span><br><span class="line">                    operation.set(action(<span class="literal">Some</span>(v)));</span><br><span class="line">                    done = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第一个分支的<code>precondition</code>是必须的，不然就会有可能出现多次执行一个已完成的异步任务，会<code>panic</code>: <code>async fn resumed after completion</code>。</p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>最后在聊聊分支取消。</p><p>当<code>select</code>有分支完成时，其他分支会被取消。取消依托于<code>Drop</code>。当<code>future</code>被<code>drop</code>，其也会停止被异步调度。</p><p>比如下边代码，当<code>oneshot::Receiver</code>被取消而<code>Drop</code>时，会向<code>Sender</code>发送<code>close</code>通知，以便于清理<code>sender</code>并中断其执行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::oneshot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx1, rx1) = oneshot::channel::&lt;<span class="built_in">u32</span>&gt;();</span><br><span class="line">    <span class="keyword">let</span> (tx2, rx2) = oneshot::channel();</span><br><span class="line"></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">            _ = tx1.closed() =&gt; &#123;</span><br><span class="line">                <span class="comment">// `val = rx1` is canceled</span></span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"tx1 closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = tx2.send(<span class="string">"two"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        val = rx1 =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"rx1 completed first with &#123;:?&#125;"</span>, val);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        val = rx2 =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"rx2 completed first with &#123;:?&#125;"</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust异步编程之Future并发处理
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="future" scheme="https://newbmiao.github.io/tags/future/"/>
    
  </entry>
  
  <entry>
    <title>Rust异步编程之Future初探</title>
    <link href="https://newbmiao.github.io/2024/01/06/rust-async-future.html"/>
    <id>https://newbmiao.github.io/2024/01/06/rust-async-future.html</id>
    <published>2024-01-05T23:10:51.000Z</published>
    <updated>2024-01-06T06:10:26.965Z</updated>
    
    <content type="html"><![CDATA[<p><code>Rust</code>的<code>Future</code>是用来实现异步编程的。今天我们围绕其了解下<code>Rust</code>的异步编程是如何构建。</p><p><code>Rust</code>用<code>async</code>就能轻松创建开销很小的可异步执行的函数，在<code>await</code>时其才会被调度执行。</p><p>其比较轻量级，有别于异步多线程，依托在操作系统线程之上，构建大量并发则需要大量的线程资源，对资源的消耗比较大。</p><p>比如下边用<code>async</code>构建异步任务：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">async_fn</span></span>() &#123;</span><br><span class="line">    <span class="comment">// handle async logic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    async_fn().<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p><code>async</code>其实也是帮你自动实现了下边的<code>Future trait</code>，用结构体维护了一个状态机</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;,</span><br><span class="line">    ) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Future</code>定义一个<code>poll</code>方法，可以查询异步任务状态。对于异步任务，有<code>Pending</code>和<code>Ready</code>两种状态，<code>Pending</code>时会让出控制，等待可以处理时再被唤醒继续处理，如此重复，直到<code>Ready</code>。</p><p>我们来尝试通过实现一个<code>Delay</code>的<code>Future</code>了解这个状态流转的过程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Delay</span></span> &#123;</span><br><span class="line">    when: Instant,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> Delay &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = &amp;<span class="symbol">'static</span> <span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;&amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> Instant::now() &gt;= <span class="keyword">self</span>.when &#123;</span><br><span class="line">            Poll::Ready(<span class="string">"done"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 还未ready，注册下一次唤醒</span></span><br><span class="line">            cx.waker().wake_by_ref();</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> when = Instant::now() + Duration::from_millis(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> future = Delay &#123; when &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> out = future.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(out, <span class="string">"done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Delay</code>每次<code>poll</code>时会检查，时间是否满足，满足则<code>Ready</code>，否则schedule下一次执行并返回<code>Pending</code></p><p>状态机是有了，<code>Future</code>怎么调度呢？</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p><code>Rust</code>需要运行时<code>runtime</code>来调度异步任务<code>task</code>，<code>runtime</code>负责调度，检查<code>future</code>的状态。</p><p>调度一般在<code>Pending</code>时会交出<code>task</code>的控制，并<code>schedule</code>下一次什么时候唤醒（<code>wake</code>）。</p><p>流程处理展开来说，常规<code>Ready</code>处理：</p><pre class="mermaid">graph TD    executor --> task    task -- poll --> future    future -- ready --> task</pre><p>而<code>Pending</code>时, <code>future</code>要被<code>schedule</code>下一次唤醒，而每次唤醒可能不会都是在同一个<code>task</code>上执行。<br>这里用于唤醒的<code>waker</code>会在每次<code>poll</code>时以<code>context</code>传递下去，</p><pre class="mermaid">graph TD    executor --> task    executor --> waker    executor -.-> task    task -- poll with context (waker) --> future    future -- update --> waker    future -- pending --> task    waker -- wake --> executor</pre><h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>了解了调度，我们再展开说下运行时。<code>rust</code>的运行时没在标准库中实现，需要依赖第三方的运行时，常用的有<code>tokio</code>。</p><p>就比如如下的<code>tokio</code>宏实际是添加了一个多线程（<code>multi thread</code>）的运行时，会阻塞当前线程直到异步任务完成。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tranform to</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    tokio::runtime::Builder::new_multi_thread()</span><br><span class="line">        .enable_all()</span><br><span class="line">        .build()</span><br><span class="line">        .unwrap()</span><br><span class="line">        .block_on(<span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Hello world"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以用单线程的运行时（<code>current thread</code>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main(flavor = <span class="meta-string">"current_thread"</span>)]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tranform to</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    tokio::runtime::Builder::new_current_thread()</span><br><span class="line">        .enable_all()</span><br><span class="line">        .build()</span><br><span class="line">        .unwrap()</span><br><span class="line">        .block_on(<span class="keyword">async</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Hello world"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>其实一般很少直接去实现<code>Future trait</code>, 直接使用<code>async</code>去自动实现<code>Future trait</code>就足够了。上边<code>Delay</code>完全可以这么实现，简洁且高效</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Notify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">delay</span></span>(dur: Duration) &#123;</span><br><span class="line">    <span class="keyword">let</span> when = Instant::now() + dur;</span><br><span class="line">    <span class="keyword">let</span> notify = Arc::new(Notify::new());</span><br><span class="line">    <span class="keyword">let</span> notify_clone = notify.clone();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> now = Instant::now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> now &lt; when &#123;</span><br><span class="line">            thread::sleep(when - now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notify_clone.notify_one();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    notify.notified().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    delay(Duration::from_secs(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h2><p>还记得<code>future trait</code>上参数有个<code>Pin&lt;&amp;mut Self&gt;</code>, 为什么要<code>Pin future</code>的引用？</p><p>来看下边一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">my_async_fn</span></span>() &#123;</span><br><span class="line">    <span class="comment">// async logic here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> future = my_async_fn();</span><br><span class="line">    (&amp;<span class="keyword">mut</span> future).<span class="keyword">await</span>;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="comment">// within `impl Future&lt;Output = ()&gt;`, the trait `Unpin` is not implemented for `[async fn body@src/main.rs:1:24: 3:2]`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当尝试执行一个异步函数的引用时，编译器会报错要求其是<code>Unpin trait</code>。</p><p>为什么呢？</p><p><code>future</code>本质是一个封装的状态机结构体，调度时会被移动，如果其包含引用，引用的地址要能保证生命周期至少在其完成前还存活，不然就会出现引用一个已失效的地址。</p><p>所以Rust引入了<code>Unpin trait</code>。 这个<code>Unpin</code>是代表其不需要固定地址，可以安全引用。</p><p>常规的类型一般都是实现了的。对于未实现的<code>!Unpin</code>类型，一般可以将其<code>Box::pin</code>到堆上或用宏<code>pin!</code>到栈上来确保其地址在<code>future</code>移动期间是有效的。</p><p>代码如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::pin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">my_async_fn</span></span>() &#123;</span><br><span class="line">    <span class="comment">// async logic here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> future = my_async_fn();</span><br><span class="line">    <span class="comment">// option 1</span></span><br><span class="line">    pin!(future);</span><br><span class="line">    (&amp;<span class="keyword">mut</span> future).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// option 2</span></span><br><span class="line">    <span class="comment">// let pinned_fut = Box::pin(future);</span></span><br><span class="line">    <span class="comment">// pinned_fut.await;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>好了，今天就聊到这里，下一篇我们再聊聊多个异步同时怎么处理。</p><p>对<code>Pin</code>感兴趣可以看看官方更详细的文档：<a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html" target="_blank" rel="noopener">Pinning</a></p><p>异步编程更深入了解的话也推荐看下tokio的这篇：<a href="https://tokio.rs/tokio/tutorial/async" target="_blank" rel="noopener">Async in depth</a></p><!-- ---**欢迎关注公众号：[newbmiao](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=2145763210988224521&scene=173&subscene=91&sessionid=1702900175&enterid=1702900179&from_msgid=2247484338&from_itemidx=1&count=3&nolastread=1#wechat_redirect), 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust异步编程之Future
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="futures" scheme="https://newbmiao.github.io/tags/futures/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Rust的Atomic及Ordering</title>
    <link href="https://newbmiao.github.io/2023/12/16/rust-sync-atomic.html"/>
    <id>https://newbmiao.github.io/2023/12/16/rust-sync-atomic.html</id>
    <published>2023-12-16T08:23:50.000Z</published>
    <updated>2023-12-18T11:27:26.342Z</updated>
    
    <content type="html"><![CDATA[<p>之前提到的<code>Mutex</code>、<code>Condvar</code>是<code>Rust</code>中比较偏高层的共享数据型并发控制，更底层的并发控制也有，比如<code>Atomic</code>（原子操作）。</p><p>今天结合代码来深入聊聊<code>Atomic</code>及其相关的<code>Ordering</code></p><a id="more"></a><!-- **文章目录** --><!-- [TOC] --><p>首先为什么要有Atomic，用Mutex不就可以了吗，我们来对比下</p><h2 id="Mutex-vs-Atomic"><a href="#Mutex-vs-Atomic" class="headerlink" title="Mutex vs Atomic"></a>Mutex vs Atomic</h2><p>1.从数据操作上对比：</p><p><code>Mutex</code>是并发下对数据的<strong>互斥访问控制</strong>，多个线程尝试写入，同时必须只能有一个线程争得锁，进而写入成功，其他线程只能等待其释放锁后再争夺锁。</p><p><code>Atomic</code>本身就是并发下对数据的原子操作，其操作是构建在操作系统的原子指令上，比如<code>读取（Load），写入（Store），比较写入(CAS，compare and swap)，自增（fetch_add）</code>等，操作要么成功要么失败，不可能被其他线程打断，出现中间状态，避免操作中数据竞争状态的发生。</p><p>也就是说<code>Atomic</code>是依赖底层系统的指令不可拆分达到无需锁（<code>lock free</code>）就能直接对数据地址共享操作。</p><p>2.从临界区构建上对比：</p><p><code>Mutex</code>是在加锁和释放锁之间构建了并发访问的临界区，进而进行数据操作。</p><p><code>Atomic</code>本身对于数据地址操作就是原子的，如果临界区想操作就是数据本身，那就不需要额外的保证</p><p>但如果还有别的数据需要在临界区操作，则需要通过<code>load/store/cas</code>等组合<code>wait loop</code>才能实现，也就是常说的自旋（spin），这也是更底层的方式。一般在对性能要求更细致场景会需要。</p><p>下边先用伪代码举例常见临界区的样子（后边会结合Ordering用代码详细展开）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="number">1</span>: </span><br><span class="line">    <span class="comment">// 条件满足设置flag</span></span><br><span class="line">    store/CAS flag: <span class="literal">false</span>-&gt;<span class="literal">true</span></span><br><span class="line">thread <span class="number">2</span>: </span><br><span class="line">    <span class="comment">// wait flag满足条件，模拟类似锁的阻塞, spin</span></span><br><span class="line">    <span class="keyword">while</span> load flag == <span class="literal">false</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 执行临界区操作</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="Atomic初探"><a href="#Atomic初探" class="headerlink" title="Atomic初探"></a>Atomic初探</h2><p>了解了<code>Atomic</code>的作用，下边先从一个例子了解下如何使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::atomic::&#123;AtomicBool, Ordering&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化原子bool类型</span></span><br><span class="line"><span class="keyword">static</span> FLAG: AtomicBool = AtomicBool::new(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = thread::spawn(|| &#123;</span><br><span class="line">        <span class="comment">// 原子操作修改</span></span><br><span class="line">        FLAG.store(<span class="literal">true</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> b = thread::spawn(|| &#123;</span><br><span class="line">        <span class="comment">// 原子操作读取</span></span><br><span class="line">        <span class="keyword">if</span> FLAG.load(Ordering::Relaxed) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Relaxed: Flag is set!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    a.join().unwrap();</span><br><span class="line">    b.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，两个线程分别对Flag修改和读取，读取时会尝试判断是否满足打印条件。</p><p>不过运行代码，打印不一定会发生。你可能觉得多线程下，两线程执行顺序不能保证，执行顺序可能是先load后store，这样的结果也很正常。</p><p>这是一种可能，然而远没有那么简单。</p><p>这里要提下指令重排和<code>Atomic</code>的<code>Ordering</code>排序</p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(a: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>, b: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    *a += <span class="number">1</span>;</span><br><span class="line">    *b += <span class="number">1</span>;</span><br><span class="line">    *a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你写下这段代码，交给操作系统编译执行，但很可能你得到的是这样的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f</span></span>(a: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>, b: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    *a += <span class="number">2</span>;</span><br><span class="line">    *b += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么？</p><p>操作系统处理器和编译器悄悄的帮你优化了代码来让他运行更快，这里规则是：</p><p><strong>只要不影响程序语义，指令可以重排执行以优化，即不按代码顺序执行</strong>。</p><p>单线程下这样问题可能还不大，但如果多线程下，同一线程下多条原子指令，也是会有指令重排的可能，数据竞争很有可能发生，就是说加了原子操作也无法确定数据操作顺序。</p><p>如以下代码：</p><p><strong>b线程的1和2不互相依赖，可以指令重排成2和1</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::atomic::&#123;AtomicI32, Ordering&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> X: AtomicI32 = AtomicI32::new(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">static</span> Y: AtomicI32 = AtomicI32::new(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> x = X.load(Ordering::Relaxed);</span><br><span class="line">        Y.store(x, Ordering::Relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> b = thread::spawn(|| &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">let</span> y = Y.load(Ordering::Relaxed);</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        X.store(<span class="number">42</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">    a.join().unwrap();</span><br><span class="line">    b.join().unwrap();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(X.load(Ordering::Relaxed), <span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 有可能, b线程的1和2不互相依赖，可以指令重排成2和1</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(Y.load(Ordering::Relaxed), <span class="number">42</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层的原子操作当然不能坐视不理，提出了<code>Ordering</code>来约束当前原子操作修改在其他多线程下的可见性，希望能约束<strong>当前线程发生原子操作如何同步到其他线程</strong>，能在并发中并发数据操作能有更好的<strong>确定性</strong>。</p><h2 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h2><p><code>Rust</code>用于的内存访问顺序（<code>memory order</code>）的<code>Ordering</code>基本和<a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener"><code>C++ 20</code>的内存排序</a>的保持一致， 下边先挨个过一遍</p><ul><li>Relaxed</li></ul><p>最基础的内存排序要求，只要求当前原子操作是要么完全执行，要么还未执行，其操作结果的可见性同步在其他线程没有任何顺序的保证（如指令重排代码所示）</p><ul><li>Acquire</li></ul><p>适用于读取数据操作，要求：</p><p>当前线程不能有<strong>其他的读或写被reorder在load之前</strong><br>其他线程的同一数据已发生的Release写入操作都是对其可见的。</p><ul><li>Release</li></ul><p>适用于写数据操作，要求：</p><p>当前线程不能有<strong>其他的读或写被reorder在store之后</strong><br>当前写入后的结果对其他线程的同一数据Acquire读取操作是可见的。</p><p>也就是说，这里线程间可见性要求，<code>acquire load</code>总是可以同步到其他线程已发生的<code>release store</code></p><p>结合代码来看就是（指令重排部分见注释）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::atomic::&#123;AtomicBool, Ordering&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 更严谨的测试可以用loom</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100000</span> &#123;</span><br><span class="line">        acquire_release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">acquire_release</span></span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> FLAG: AtomicBool = AtomicBool::new(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mut</span> DATA: <span class="built_in">u64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> a = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; DATA = <span class="number">42</span> &#125;;</span><br><span class="line">        FLAG.store(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">        <span class="comment">// 不允许有读写重排到store之后</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> b = thread::spawn(|| &#123;</span><br><span class="line">        <span class="comment">// 不允许有读写重排到load之前</span></span><br><span class="line">        <span class="keyword">while</span> !FLAG.load(Ordering::Acquire) &#123;&#125;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="keyword">unsafe</span> &#123; DATA &#125;, <span class="number">42</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    a.join().unwrap();</span><br><span class="line">    b.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AcqRel</li></ul><p>适用于同时读写操作（Read and write）,读操作用Acquire，写操作用Release</p><ul><li>SeqCst</li></ul><p>在保证读写一定是Acquire和Release的约束外，还保证<strong>其他线程看到的原子操作顺序一致</strong>，即<strong>全局只有一种内存结果可见顺序（a single total order）</strong>。</p><p>也就是说多线程下，即使执行顺序不能保证，但执行完后全局只能有一种原子操作的结果顺序，可以每次是不一样的（因为执行的先后不同），但一旦执行顺序确定后，就不可能有第二种原子操作结果的可能性存在。如同将不同线程的原子操作执行给串行化了一样。</p><p>所以内存顺序的严格程度就是从<code>Relax-&gt;Acquire+Relase-&gt;SeqCst</code>。越严格当然也会带来越多的性能开销。</p><p>来个代码帮助理解下用<code>Ordering</code>组合构建临界区：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicBool, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> lock = Arc::new(AtomicBool::new(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> lock_clone_read = lock.clone();</span><br><span class="line">    <span class="keyword">let</span> lock_clone_store = lock.clone();</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 持有锁</span></span><br><span class="line">        lock.store(<span class="literal">true</span>, Ordering::SeqCst);</span><br><span class="line">        <span class="comment">// 执行临界区操作</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待锁被获取</span></span><br><span class="line">    <span class="keyword">while</span> !lock_clone_read.load(Ordering::Acquire) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入临界区，可以放心的执行临界区操作了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Critical section!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock_clone_store.store(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Ordering的可见性"><a href="#验证Ordering的可见性" class="headerlink" title="验证Ordering的可见性"></a>验证Ordering的可见性</h2><p>原子操作结果可见性同步严格程度不同影响大么？</p><p>眼见为实，下边在通过一段<code>Relaxed</code>的代码先来验证下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::&#123;</span><br><span class="line">        atomic::&#123;AtomicBool, AtomicU64, Ordering&#125;,</span><br><span class="line">        Arc,</span><br><span class="line">    &#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> S: AtomicU64 = AtomicU64::new(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">relaxed</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Arc::new(AtomicBool::new(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> b = Arc::new(AtomicBool::new(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> a_clone = a.clone();</span><br><span class="line">    <span class="keyword">let</span> b_clone = b.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        a.store(<span class="literal">true</span>, Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">if</span> !b.load(Ordering::Relaxed) &#123;</span><br><span class="line">            S.fetch_add(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        b_clone.store(<span class="literal">true</span>, Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">if</span> !a_clone.load(Ordering::Relaxed) &#123;</span><br><span class="line">            S.fetch_add(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.join().unwrap();</span><br><span class="line">    t2.join().unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">        relaxed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果可能大于10000</span></span><br><span class="line">    <span class="keyword">let</span> s = S.load(Ordering::SeqCst);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s: &#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是S基本大于10000，为什么？我们展开分析下</p><p>两个<code>AtomicBool</code> A和B初始是false，两个线程用<code>Relaxed</code>先修改一个为true和再去读取另一个的值，如果判断读取到的值还是false就增加结果长度一次。</p><p>两个线程在判断是否增加结果长度时，会有以下几种可能：</p><ol><li>其他线程指令重排</li></ol><ul><li>修改排到load之后还没执行修改，S+1 （Relaxed时）</li></ul><ol start="2"><li>其他线程指令不重排</li></ol><ul><li>还没开始修改，S+1 </li><li>其他线程修改了，但对当前load不可见，S+1（Relaxed时） </li><li>其他线程修改了，对当前load可见，S不变</li></ul><p>所以指令重排和读取对修改不可见都会让S+1， <code>Relaxed</code>会有更多可能让S+1</p><p>所以遍历一次，两线程并发的情况下，如果S增加了2，则说明对于修改的可见性同步要求较弱，即使另一个线程修改了值，也没能及时同步到当前值的load</p><p>对于<code>Relaxed</code>约束，那么执行100000次，S很容易大于100000。</p><p>如果换成<code>SeqCst</code>，不允许上边代码中指令重排，又全局串行化了不同的原子操作。</p><p>如果其他线程修改发生在当前线程load之前，其一定是对当前线程load可见的，不会同时都不可见的可能性。所以S最多只能是100000。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t1 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    a.store(<span class="literal">true</span>, Ordering::SeqCst);</span><br><span class="line">    <span class="keyword">if</span> !b.load(Ordering::SeqCst) &#123;</span><br><span class="line">        S.fetch_add(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t2 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    b_clone.store(<span class="literal">true</span>, Ordering::SeqCst);</span><br><span class="line">    <span class="keyword">if</span> !a_clone.load(Ordering::SeqCst) &#123;</span><br><span class="line">        S.fetch_add(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="fence"><a href="#fence" class="headerlink" title="fence"></a>fence</h2><p><code>Ordering</code>除了可以对绑定到<strong>单个原子数据类型</strong>的操作上，也可以用在<code>fence</code>约束多条原子操作上，防止编译器和处理器对内存操作的重排，添加内存屏障（memory barrier），这也是构建临界区的一种方式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.store(<span class="number">1</span>, Release);</span><br><span class="line"><span class="comment">// 可以替换为</span></span><br><span class="line">fence(Release);</span><br><span class="line">a.store(<span class="number">1</span>, Relaxed);</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.load(Acquire);</span><br><span class="line"><span class="comment">// 可以被替换为</span></span><br><span class="line">a.load(Relaxed);</span><br><span class="line">fence(Acquire);</span><br></pre></td></tr></table></figure><p>这样拆分后，可以被扩展用作多个数据操作组合在线程间可见性的保证。也可以<strong>可选的选择</strong>什么时候用<code>acquire/release/seqcst</code></p><p>比如下边用原子操作和fence模拟锁的实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::AtomicBool;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::fence;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mutex</span></span> &#123;</span><br><span class="line">    flag: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Mutex &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Mutex &#123;</span><br><span class="line">        Mutex &#123;</span><br><span class="line">            flag: AtomicBool::new(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// relaxed+acquire fence 来及时同步已发生的unlock (release)</span></span><br><span class="line">        <span class="comment">// cas时没有直接使用严格的acquire</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span></span><br><span class="line">            .flag</span><br><span class="line">            .compare_exchange_weak(<span class="literal">false</span>, <span class="literal">true</span>, Ordering::Relaxed, Ordering::Relaxed)</span><br><span class="line">            .is_err()</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        fence(Ordering::Acquire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.flag.store(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p><code>Atomic</code>也常用来做资源的延迟初始化，让多线程共享一份资源。</p><p>比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::atomic::&#123;AtomicPtr, Ordering&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_data</span></span>() -&gt; Data &#123;</span><br><span class="line">    Data &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_data</span></span>() -&gt; &amp;<span class="symbol">'static</span> Data &#123;</span><br><span class="line">    <span class="keyword">static</span> PTR: AtomicPtr&lt;Data&gt; = AtomicPtr::new(std::ptr::null_mut());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> p = PTR.load(Ordering::Acquire);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p.is_null() &#123;</span><br><span class="line">        p = <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(generate_data()));</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = PTR.compare_exchange(</span><br><span class="line">            std::ptr::null_mut(),</span><br><span class="line">            p,</span><br><span class="line">            Ordering::Release,</span><br><span class="line">            Ordering::Acquire,</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// Safety: p comes from Box::into_raw right above,</span></span><br><span class="line">            <span class="comment">// and wasn't shared with any other thread.</span></span><br><span class="line">            <span class="built_in">drop</span>(<span class="keyword">unsafe</span> &#123; <span class="built_in">Box</span>::from_raw(p) &#125;);</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Safety: p is not null and points to a properly initialized value.</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123; &amp;*p &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(|| get_data());</span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(|| get_data());</span><br><span class="line">    <span class="keyword">let</span> (ret1, ret2) = (t1.join().unwrap(), t2.join().unwrap());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(ret1 <span class="keyword">as</span> *<span class="keyword">const</span> _, ret2 <span class="keyword">as</span> *<span class="keyword">const</span> _);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过一般情况下我们都没有需要自己去实现，很多crate都能实现类似操作，比如<a href="https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data" target="_blank" rel="noopener">OneCell</a></p><p>综上，<code>Atomic</code>是更底层的原子操作，为了同步原子操作的结果在其他线程的可见性以及约束编译器和操作系统的指令重排，也支持<code>Ordering</code>来提供不同程度的可见性保证。</p><p>深入了解<code>Atomic</code>并不意味着我们一定会用他来做一些<code>lock free</code>的开发，毕竟轮子已经有好多了，但至少能更好理解一些并发控制代码中原子操作的实现，也不会对各种<code>Ordering</code>傻傻分不清了。</p><p>最后推荐两个不错的<code>Atomic</code>资料，非常有助于理解，感兴趣的可以去看看</p><ul><li><a href="https://marabos.nl/atomics/memory-ordering.html" target="_blank" rel="noopener">Rust Atomics and Locks: memory ordering</a></li><li><a href="https://www.youtube.com/watch?v=rMGWeSjctlY" target="_blank" rel="noopener">Crust of Rust: Atomics and Memory Ordering</a></li></ul><!-- ---**欢迎关注公众号：newbmiao, 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Atomic
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="atomic" scheme="https://newbmiao.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Channel</title>
    <link href="https://newbmiao.github.io/2023/12/08/rust-sync-channel.html"/>
    <id>https://newbmiao.github.io/2023/12/08/rust-sync-channel.html</id>
    <published>2023-12-08T12:55:42.000Z</published>
    <updated>2023-12-09T09:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rust官方<code>sync</code>包中提供了<code>mpsc</code>模式的 (多生产者，单消费者：multi-producer, single-consumer) channel，可以实现基于消息并发控制，而不是依赖控制内存共享（加锁）。这正是go语言作者 <code>R. Pike</code> 所推崇的方式：</p><blockquote><p>Don’t communicate by sharing memory; share memory by communicating. (R. Pike)</p></blockquote><p>今天就聊聊<code>mpsc</code>提供的<code>sync_channel</code>和<code>channel</code>。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>首先一般channel机制都保证了</p><ul><li>生产者（producer/sender） 可以发送（send）消息，消费者（consumer/receiver）可以接受（recv）消息，生产和消费的顺序一致（一般都有消息队列保证顺序<code>FIFO</code>）</li><li>消费者在没有消息可接收前会阻塞等待，直到有消息或channel关闭</li><li>channel可以限制同时可处理消息上限（buffer size）</li><li>生产者发送的消息累积到buffer上限时就要阻塞到有消息被消费</li></ul><p>从这些规则中，可以看出，channel保证了生产总是先于消费，消息处理总是先进先出（<code>FIFO</code>）。</p><h2 id="sync-channel-spsc"><a href="#sync-channel-spsc" class="headerlink" title="sync_channel - spsc"></a>sync_channel - spsc</h2><p>buffer size 最特别的情况就是0，就是单生产者单消费者模式(<code>mpsc</code>)： send后会阻塞，直到有recv处理，才能再send下一个消息。</p><p>这就能很好的实现对并发顺序的控制， 比如下边代码，用两组channel实现1和2的交替打印。</p><p>不同channel的send和recv交叉等待，保证了打印的顺序，就像这中间持有锁一样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::sync_channel;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = sync_channel(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> (sender2, receiver2) = sync_channel(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(&#123;</span><br><span class="line">        <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">                <span class="comment">// t1打印完，通知t2的receiver打印</span></span><br><span class="line">                sender.send(<span class="number">2</span>).unwrap();</span><br><span class="line">                <span class="comment">// 阻塞，等待t2打印结束</span></span><br><span class="line">                receiver2.recv().unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(&#123;</span><br><span class="line">        <span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="comment">// 阻塞，等待t1 sender的已打印的消息</span></span><br><span class="line">                receiver.recv().unwrap();</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">                <span class="comment">// t2打印完, 给t1 receiver2通知可以进行下一次打印</span></span><br><span class="line">                sender2.send(<span class="number">1</span>).unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.join().unwrap();</span><br><span class="line">    t2.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-channel-mpsc"><a href="#sync-channel-mpsc" class="headerlink" title="sync_channel - mpsc"></a>sync_channel - mpsc</h2><p>buffer size增加，就是正常<code>mpsc</code>摸式，可以控制同时能并发的上限（实际内部提前分配了数组来支持buffer）。</p><p>达到上限，sender就需要等待有receiver消费才能够继续发送消息。</p><p>当然没消息的话，别忘了drop也是可以结束recv一直等待消息的。</p><p>如下边代码所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::sync_channel;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = sync_channel(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sender2 = sender.clone();</span><br><span class="line">    <span class="keyword">let</span> sender3 = sender.clone();</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || sender.send(<span class="number">1</span>).unwrap());</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || sender2.clone().send(<span class="number">2</span>).unwrap());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drop</span>(sender3); <span class="comment">// 这里保证了第三个recv打印能成功</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, receiver.recv().unwrap());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, receiver.recv().unwrap());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, receiver.recv());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>明白了<code>sync_channel</code>，<code>channel</code>就简单了，就是buffer size无限模式（实际是内部维护了一个链表自动扩容）。 所有的send都不会阻塞，只有recv在没消息时需要阻塞等待channel中产生新的消息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::&#123;channel, sync_channel&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// let (sender, receiver) = sync_channel(1); // buffer为1的话，不会打印send no block</span></span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel(); <span class="comment">// 使用channel，send不阻塞，会打印</span></span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        sender.send(<span class="number">1</span>).unwrap();</span><br><span class="line">        sender.send(<span class="number">2</span>).unwrap();</span><br><span class="line">        sender.send(<span class="number">3</span>).unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"send no block"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, receiver.recv().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想及时check是否能recv消息时，可以用<code>try_recv</code></p><ul><li><code>TryRecvError::Empty</code>代表目前为空，但channel连接还在</li><li><code>TryRecvError::Disconnected</code>则是连接已关闭，不可能再受到消息了</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::&#123;channel, Receiver, RecvError, TryRecvError&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel();</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_recv_with_log</span></span>(receiver: &amp;Receiver&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">match</span> receiver.try_recv() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(v) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, v),</span><br><span class="line">            <span class="literal">Err</span>(TryRecvError::Empty) =&gt; <span class="built_in">println!</span>(<span class="string">"error: Empty"</span>),</span><br><span class="line">            <span class="literal">Err</span>(TryRecvError::Disconnected) =&gt; <span class="built_in">println!</span>(<span class="string">"error: Disconnected"</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error: Empty</span></span><br><span class="line">    try_recv_with_log(&amp;receiver);</span><br><span class="line">    sender.send(<span class="number">1</span>).unwrap();</span><br><span class="line">    receiver.recv().unwrap();</span><br><span class="line">    <span class="built_in">drop</span>(sender);</span><br><span class="line">    <span class="comment">// error: Disconnected</span></span><br><span class="line">    try_recv_with_log(&amp;receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Sender&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> Sender&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Receiver&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> Receiver&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>最后来看看rust如何保证channel的并发安全</p><p><code>Sender&lt;T&gt;</code>同时支持<code>Send</code>和<code>Sync</code>，其维护的消息队列可以安全的在线程间传递所有权，也可以了共享引用，即可以被多个线程同时进行send操作。</p><p>其中<code>T</code>需要实现<code>Send</code>, 以确保消息可以在线程间安全传递所有权，避免竞争条件或使用已释放的内存</p><p>而<code>Receiver&lt;T&gt;</code>只支持Send，只能在线程间传递自身所有权，但不能在线程间共享引用。同时只能有一个线程拥有其所有权，进而独占的去消费<code>Sender&lt;T&gt;</code>的消息队列。</p><p>依旧是巧妙的通过<code>Send</code>和<code>Sync</code>标记trait保证了并发的安全，轻松实现无畏并发。</p><!-- ---**欢迎关注公众号：newbmiao, 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Channel
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="channel" scheme="https://newbmiao.github.io/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Semaphore-两线程交替打印</title>
    <link href="https://newbmiao.github.io/2023/11/24/rust-sync-semaphore.html"/>
    <id>https://newbmiao.github.io/2023/11/24/rust-sync-semaphore.html</id>
    <published>2023-11-24T10:57:56.000Z</published>
    <updated>2023-12-08T12:53:11.120Z</updated>
    
    <content type="html"><![CDATA[<p>信号量（Semaphore）是一种对资源并发访问控制的方式。</p><p>区别于互斥锁（Mutex）是对共享资源的独占访问，Semaphore允许指定多个并发访问共享资源。</p><p>就是说Semaphore像一个持有令牌（permit/token）的桶，每一个并发访问需要持有（acquire）一个令牌来访问共享资源，</p><p>当没有令牌时，没法访问共享资源，直到有新的令牌加入（add）或者原来发出的令牌放回（release）桶中。</p><p>接下来，我们尝试用通过用它来实现两个线程交替打印1和2，来更直观了解如何使用semaphore</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><blockquote><p>Rust std库中没有正式发布的semaphore（std::sync::Semaphore在1.7.0废弃了）。下边用tokio库提供的semaphore</p></blockquote><p>首先安装 tokio库</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 手动添加tokio到cargo.toml</span><br><span class="line"># 或使用cargo-add: cargo add tokio --features sync,macros,rt-multi-thread</span><br><span class="line">[dependencies]</span><br><span class="line">tokio = &#123; version = <span class="string">"1.34.0"</span>, features = [<span class="string">"sync"</span>, <span class="string">"macros"</span>, <span class="string">"rt-multi-thread"</span>] &#125;</span><br></pre></td></tr></table></figure><p>先来一版常规实现，初始化一个只有一个令牌的semahore，两个线程去并发持有令牌，用后释放（通过drop）令牌，实现交替打印</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> semaphore = Arc::new(Semaphore::new(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> semaphore2 = semaphore.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">let</span> permit = semaphore.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">            <span class="comment">// 可不写，离开scope时自动释放，放回令牌桶</span></span><br><span class="line">            <span class="built_in">drop</span>(permit); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="comment">// 或用 _ ignore返回值，即时回收令牌</span></span><br><span class="line">            <span class="keyword">let</span> _ = semaphore2.acquire().<span class="keyword">await</span>.unwrap(); </span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::try_join!(t1, t2).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看没什么问题，但是打印其实不一定是<code>1 2 1 2 1 2</code>的顺序。</p><p>原因很简单，我们只是约束了令牌同时只能有一个线程获取到，但是没有约束谁先谁后啊。所以其实没有实现交替打印。</p><p>怎么交替打印呢？</p><p>要控制顺序，我们可以让每个线程所持有的semaphore里的令牌时动态增加和消耗，然后一个令牌桶数量的增加滞后于另一个。</p><p>增加可以用add_permits， 消耗后不放回可以用forgot， 代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 线程1的令牌桶1初始一个令牌，可以先打印1</span></span><br><span class="line">    <span class="keyword">let</span> semaphore = Arc::new(Semaphore::new(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> semaphore2 = semaphore.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2的令牌桶2初始没有令牌，直到1打印后增加令牌</span></span><br><span class="line">    <span class="keyword">let</span> semaphore_wait = Arc::new(Semaphore::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> semaphore_wait2 = semaphore_wait.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">let</span> permit = semaphore.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">            <span class="comment">// 消耗令牌，不放回令牌桶1</span></span><br><span class="line">            permit.forget();</span><br><span class="line">            <span class="comment">// 令牌桶2增加令牌，可以打印2</span></span><br><span class="line">            semaphore_wait2.add_permits(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t2 = tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">let</span> permit = semaphore_wait.acquire().<span class="keyword">await</span>.unwrap();</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">            <span class="comment">// 消耗令牌，不放回令牌桶2</span></span><br><span class="line">            permit.forget();</span><br><span class="line">            <span class="comment">// 令牌桶1增加令牌，可以打印1</span></span><br><span class="line">            semaphore2.add_permits(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::try_join!(t1, t2).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个动态的令牌桶（semaphore）线程的执行顺序就能交替执行了。</p><p>可以和上篇 <a href="https://mp.weixin.qq.com/s/5io-hBPlsO_buUILCjg7BA" target="_blank" rel="noopener">condvar实现的版本</a> 对比下， 感受下semaphore的魅力。</p><!-- ---**欢迎关注公众号：newbmiao, 获取及时更新**-->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Semaphore-两线程交替打印
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="semaphore" scheme="https://newbmiao.github.io/tags/semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Condvar-两线程交替打印</title>
    <link href="https://newbmiao.github.io/2023/11/23/rust-sync-condvar-2.html"/>
    <id>https://newbmiao.github.io/2023/11/23/rust-sync-condvar-2.html</id>
    <published>2023-11-23T15:30:59.000Z</published>
    <updated>2023-12-08T12:53:11.119Z</updated>
    
    <content type="html"><![CDATA[<p>在并发控制的面试里有个很喜欢考的点：如何控制两个并发线程交替打印1和2。</p><p>实现的方式有很多，今天我们先用上篇提到的condvar试试。</p><!-- **文章目录** --><!-- [TOC] --><a id="more"></a><p>思路是利用条件变量来控制两个线程：</p><ul><li>线程1：当且仅当条件为false时开始打印1，并修改条件为true, 通知等待的另一个线程打印2，否则while阻塞等待</li><li>线程2：条件为false时阻塞等待notify，直到条件为true，然后重置条件为false，并打印2</li></ul><p>代码及注释如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Arc::new((Mutex::new(<span class="literal">false</span>), Condvar::new()));</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> pair2 = pair.clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> t1 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair2;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(<span class="keyword">mut</span> v) = lock.lock() &#123;</span><br><span class="line">                <span class="comment">// 条件为false时开始打印1</span></span><br><span class="line">                <span class="comment">// 并修改条件为true, 通知等待的另一个线程打印2</span></span><br><span class="line">                <span class="keyword">if</span> !*v &#123;</span><br><span class="line">                    <span class="built_in">print!</span>(<span class="string">"1 "</span>);</span><br><span class="line">                    *v = <span class="literal">true</span>;</span><br><span class="line">                    cvar.notify_one();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 及时释放锁，不让mutexguard被scope结束时才释放</span></span><br><span class="line">                    <span class="comment">// 如果后续没操作的话，可以不用这里drop，等离开scope时自动释放也一样</span></span><br><span class="line">                    <span class="built_in">drop</span>(v);</span><br><span class="line">                    <span class="comment">// [2]</span></span><br><span class="line">                    <span class="comment">// std::thread::sleep(std::time::Duration::from_millis(1));</span></span><br><span class="line">                    <span class="comment">// [1]</span></span><br><span class="line">                    <span class="comment">// print!(" waitting... ");</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> t2 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">            <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> v = lock.lock().unwrap();</span><br><span class="line">            <span class="comment">// 条件为false时等待notify，直到条件为true</span></span><br><span class="line">            <span class="keyword">while</span> !*v &#123;</span><br><span class="line">                v = cvar.wait(v).unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置条件为false，并打印2</span></span><br><span class="line">            *v = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">"2 "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.join().unwrap();</span><br><span class="line">    t2.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果可以实现打印 <code>1 2 1 2 1 2</code></p><p>不过线程1用遍历阻塞其实还是消耗了不少cpu时间，恢复注释[1]的打印可以看出，又多次waitting输出</p><p>可以加一点等待 sleep 让出cpu占用，如注释[2]来减少频繁对锁的抢占。</p><p>其实这个题目用semaphore实现也很有意思，下一篇我们聊semaphore时再来看。</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Condvar-两线程交替打印
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="condvar" scheme="https://newbmiao.github.io/tags/condvar/"/>
    
  </entry>
  
  <entry>
    <title>博客地址已迁移到newbmiao.github.io</title>
    <link href="https://newbmiao.github.io/2023/11/20/blog-migrate-hostname.html"/>
    <id>https://newbmiao.github.io/2023/11/20/blog-migrate-hostname.html</id>
    <published>2023-11-20T04:49:22.000Z</published>
    <updated>2023-12-08T12:53:11.102Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p><strong>声明：博客地址已迁移到 <a href="https://newbmiao.github.io">https://newbmiao.github.io</a>, 原域名<del>blog.newbmiao.com</del>已不再使用。</strong></p><a id="more"></a><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      newbmiao.github.io
    
    </summary>
    
    
      <category term="blog" scheme="https://newbmiao.github.io/categories/blog/"/>
    
    
      <category term="blog" scheme="https://newbmiao.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Condvar</title>
    <link href="https://newbmiao.github.io/2023/11/18/rust-sync-condvar.html"/>
    <id>https://newbmiao.github.io/2023/11/18/rust-sync-condvar.html</id>
    <published>2023-11-18T11:44:31.000Z</published>
    <updated>2023-12-08T12:53:11.119Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>上次提到的<a href="https://mp.weixin.qq.com/s/X4hIhzggiv-nv4vAxvX6Rw" target="_blank" rel="noopener">Barrier</a>用到了Rust的condvar和mutex，今天来看下condvar的用法。</p><a id="more"></a><p>condvar即condition variable（条件变量），是一种线程同步的方式，用于线程间的通信。它可以阻塞（wait）线程，期间不消耗CPU，直到某个时间发生唤醒（notify）线程。</p><p>代码举例来说：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Arc::new((Mutex::new(<span class="literal">false</span>), Condvar::new()));</span><br><span class="line">    <span class="keyword">let</span> pair2 = Arc::clone(&amp;pair);</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> (lock, cvar) = &amp;*pair2;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> started = lock.lock().unwrap();</span><br><span class="line">        *started = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// We notify the condvar that the value has changed.</span></span><br><span class="line">        cvar.notify_one();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the thread to start up.</span></span><br><span class="line">    <span class="keyword">let</span> (lock, cvar) = &amp;*pair;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> started = lock.lock().unwrap();</span><br><span class="line">    <span class="keyword">while</span> !*started &#123;</span><br><span class="line">        started = cvar.wait(started).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，创建一个线程在修改started变量后唤醒等待的线程。main中等待的的线程会一直阻塞（wait）直到started的值被修改。</p><p>其中wait会需要一个锁的MutexGuard来配合，wait会自动释放锁，并阻塞当前线程，直到被唤醒时重新获取锁，并返回锁的MutexGuard，来获取锁当前保护的值</p><blockquote><p>Tips: MutexGuard实现了销毁时自动释放锁和可以通过解引用（deref）到它保护的值</p></blockquote><p>这里有两个有意思的点：</p><ul><li>为什么要和mutex一起使用？</li><li>为什么唤醒时要检查条件是否满足？</li></ul><p>这个要从condvar唤醒的机制说起。</p><h2 id="唤醒顺序不保证"><a href="#唤醒顺序不保证" class="headerlink" title="唤醒顺序不保证"></a>唤醒顺序不保证</h2><p>先来看下唤醒的顺序，我们起两批同样数目的线程，一批线程每个线程会修改一次变量并唤醒一个另一批等待的线程，为了观测唤醒顺序，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SharedData</span></span> &#123;</span><br><span class="line">    counter: Mutex&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">    condvar: Condvar,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> shared_data = Arc::new(SharedData &#123;</span><br><span class="line">        counter: Mutex::new(<span class="number">0</span>),</span><br><span class="line">        condvar: Condvar::new(),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> thread_num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> workers = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> waits = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..thread_num &#123;</span><br><span class="line">        do_wait(i, Arc::clone(&amp;shared_data), &amp;<span class="keyword">mut</span> waits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..thread_num &#123;</span><br><span class="line">        do_work(i, Arc::clone(&amp;shared_data), &amp;<span class="keyword">mut</span> workers)</span><br><span class="line">    &#125;</span><br><span class="line">    waits.into_iter().for_each(|w| w.join().unwrap());</span><br><span class="line">    workers.into_iter().for_each(|w| w.join().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_work</span></span>(i: <span class="built_in">i32</span>, data: Arc&lt;SharedData&gt;, workers: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;) &#123;</span><br><span class="line">    workers.push(thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> SharedData &#123; counter, condvar &#125; = &amp;*data;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> data = counter.lock().unwrap();</span><br><span class="line">        *data += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Woker thread &#123;&#125; before notify: Counter &#123;&#125;"</span>, i, data);</span><br><span class="line">        condvar.notify_one();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_wait</span></span>(i: <span class="built_in">i32</span>, data: Arc&lt;SharedData&gt;, waits: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;) &#123;</span><br><span class="line">    waits.push(thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> SharedData &#123; counter, condvar &#125; = &amp;*data;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> data = counter.lock().unwrap();</span><br><span class="line">        data = condvar.wait(data).unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"   Wait thread &#123;&#125; after wake up: Counter &#123;&#125;"</span>, i, data);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果不唯一，比如如下结果，五次修改触发了五次唤醒，但是wait唤醒顺序不一定是按照worker修改顺序（而修改顺序是符合预期的，因为是加锁保证的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Woker thread 0 before notify: Counter 1</span><br><span class="line">Woker thread 4 before notify: Counter 2</span><br><span class="line">Woker thread 2 before notify: Counter 3</span><br><span class="line">   Wait thread 1 after wake up: Counter 3</span><br><span class="line">   Wait thread 3 after wake up: Counter 3</span><br><span class="line">Woker thread 3 before notify: Counter 4</span><br><span class="line">   Wait thread 0 after wake up: Counter 4</span><br><span class="line">Woker thread 1 before notify: Counter 5</span><br><span class="line">   Wait thread 4 after wake up: Counter 5</span><br><span class="line">   Wait thread 2 after wake up: Counter 5</span><br></pre></td></tr></table></figure><p>甚至有可能是唤醒次数少于五次，导致有些线程一直阻塞，比如如下结果，只有四次唤醒，导致有1个线程一直阻塞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Woker thread 1 before notify: Counter 1</span><br><span class="line">   Wait thread 2 after wake up: Counter 1</span><br><span class="line">Woker thread 3 before notify: Counter 2</span><br><span class="line">Woker thread 0 before notify: Counter 3</span><br><span class="line">   Wait thread 4 after wake up: Counter 3</span><br><span class="line">Woker thread 4 before notify: Counter 4</span><br><span class="line">   Wait thread 3 after wake up: Counter 4</span><br><span class="line">   Wait thread 1 after wake up: Counter 4</span><br><span class="line">Woker thread 2 before notify: Counter 5</span><br><span class="line"><span class="comment"># 有一个线程一直阻塞在这里</span></span><br></pre></td></tr></table></figure><p>为什么顺序不保证呢？condvar实现是基于操作系统的条件变量实现，顺序取决于操作系统调度时当前可唤醒的线程是哪个，要保证唤醒顺序需要额外的开销，而这个开销是不必要的，因为唤醒顺序对于线程间的通信是没有意义的，所以底层实现并不保证唤醒顺序。<a href="https://www.reddit.com/r/C_Programming/comments/12itrvd/condition_variables_wakeup_ordering/" target="_blank" rel="noopener">这里</a>有相关讨论</p><p>所以多个线程等待同一条件变量时，notify_one唤醒和等待也不是一定是一对一的调用，每次唤醒也不能保证都是不同的等待线程。</p><p>至于为什么会有线程一直阻塞的情况，是因为唤醒次数少于等待次数，导致有些线程一直阻塞。<br>因为是多线程并发构建的notify_one和wait，存在调用notify_one时没有线程在等待的可能，导致唤醒次数少于等待次数的情况。</p><h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><p>还有就是虚假唤醒，即wait返回时，条件由于并发原因已经不满足，还可能因为唤醒并不是由于显示的notify调用，这个听起来很奇怪，但不是一个bug，是底层操作系统实现导致的，具体看看<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">wiki</a>上的说明吧。</p><p>综上这两点，condvar唤醒时是需要重新检查条件是否依旧满足，而且需要和mutex一起使用，来确保条件值获取的并发安全。</p><p>除此condvar还有一些方便的方法，比如提供了</p><ul><li>notify_all来广播唤醒所有等待的线程；</li><li>wait_while可以根据条件等待条件直到满足；</li><li>wait_timeout只等待一段时间如果不能及时被唤醒。</li></ul><p>官方文档都有例子，就不展开了。</p><p>关于condvar比较实际的例子有WaitGroup，不需要像Barrier一样初始化时指定线程数量，而是在运行时动态增加线程数量，在<a href="https://github.com/crossbeam-rs/crossbeam/blob/master/crossbeam-utils/src/sync/wait_group.rs" target="_blank" rel="noopener">crossbeam-utils</a>中有实现，代码很精炼，感兴趣可以看下</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Condvar
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="condvar" scheme="https://newbmiao.github.io/tags/condvar/"/>
    
  </entry>
  
  <entry>
    <title>Rust并发控制之Barrier</title>
    <link href="https://newbmiao.github.io/2023/11/12/rust-sync-barrier.html"/>
    <id>https://newbmiao.github.io/2023/11/12/rust-sync-barrier.html</id>
    <published>2023-11-12T11:44:31.000Z</published>
    <updated>2023-12-08T12:53:11.119Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>Rust有很多种控制并发的方式，Barrier（屏障）是其中一种用来同步多线程计算的方式。</p><p>今天拿代码来简单看下。</p><a id="more"></a><p>比如我们要多线程计算，期望所有线程都计算完毕再输出最终结果。常规多线程代码示例可以用线程join来等待</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numthreads = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> my_mutex = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handlers = <span class="built_in">Vec</span>::with_capacity(numthreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..numthreads &#123;</span><br><span class="line">        <span class="keyword">let</span> my_lock = my_mutex.clone();</span><br><span class="line">        handlers.push(std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> guard = my_lock.lock().unwrap();</span><br><span class="line">            *guard += <span class="number">1</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> handler <span class="keyword">in</span> handlers &#123;</span><br><span class="line">        handler.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> answer = &#123; *my_mutex.lock().unwrap() &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(answer, numthreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果用Barrier，我们可以这么写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Barrier, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numthreads = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> my_mutex = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We use a barrier to ensure the readout happens after all writing</span></span><br><span class="line">    <span class="keyword">let</span> barrier = Arc::new(Barrier::new(numthreads + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..numthreads &#123;</span><br><span class="line">        <span class="keyword">let</span> my_barrier = barrier.clone();</span><br><span class="line">        <span class="keyword">let</span> my_lock = my_mutex.clone();</span><br><span class="line">        std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> guard = my_lock.lock().unwrap();</span><br><span class="line">            *guard += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Release the lock to prevent a deadlock</span></span><br><span class="line">            <span class="built_in">drop</span>(guard);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"thread &#123;&#125; is ready"</span>, i);</span><br><span class="line">            <span class="comment">// Blocks the current thread until all threads have rendezvoused here.</span></span><br><span class="line">            my_barrier.wait();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"thread &#123;&#125; is done"</span>, i)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A barrier will block `n`-1 threads which call [`wait()`] and then wake</span></span><br><span class="line">    <span class="comment">// up all threads at once when the `n`th thread calls [`wait()`].</span></span><br><span class="line">    barrier.wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> answer = &#123; *my_mutex.lock().unwrap() &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(answer, numthreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Barrier可以用wait来控制n个线程的同步，数量需要提前指明。<br>当调用wait时，如果不是第n个，就会一直阻塞当前线程，直到第n个wait调用，才能进行后续操作。</p><p>这种机制就像在多个线程中插入了一道屏障，当所有线程都执行到这里时，才能解除屏障继续向后执行。</p><p>当然这样实现相较于第一种，在线程数量大的时候也是会有比较明显的性能开销的，底层是使用condvar+mutex来实现的。这种组合也是一种有意思的并发控制方式，下次我们再聊聊它们。</p><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      Rust并发控制之Barrier
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="barrier" scheme="https://newbmiao.github.io/tags/barrier/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Rust的并发约束：Send和Sync</title>
    <link href="https://newbmiao.github.io/2023/10/11/rust-send-and-sync-trait.html"/>
    <id>https://newbmiao.github.io/2023/10/11/rust-send-and-sync-trait.html</id>
    <published>2023-10-11T09:17:22.000Z</published>
    <updated>2023-12-08T12:53:11.119Z</updated>
    
    <content type="html"><![CDATA[<!-- **文章目录** --><!-- [TOC] --><p>不知道你有没有好奇过，<code>Rust</code>是怎么控制并发安全的。为什么编译器在编译时就能发现一些并发安全的问题。</p><p>今天拿例子聊聊这背后<code>Rust</code>的两个并发约束<code>trait</code>：<code>Sync</code>和<code>Send</code>，看看它们是怎么控制并发安全的。</p><a id="more"></a><h2 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h2><p>先来看看下边代码，尝试将<code>String</code>类型的引用计数<code>a</code>（<code>Rc&lt;String&gt;</code>）移动到另一个线程中去，会发现编译器报错了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, thread&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    <span class="comment">// 注意！这里move让闭包获取了a的所有权（Rc&lt;String&gt;）</span></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> b = a.clone();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// got error:</span></span><br><span class="line">    <span class="comment">// `Rc&lt;String&gt;` cannot be sent between threads safely</span></span><br><span class="line">    <span class="comment">// the trait `Send` is not implemented for `Rc&lt;String&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察编译器的报错和下边相关代码<code>trait</code>实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> Rc&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="built_in">FnOnce</span>() -&gt; T,</span><br><span class="line">    F: <span class="built_in">Send</span> + <span class="symbol">'static</span>,</span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="symbol">'static</span>,</span><br></pre></td></tr></table></figure><p>你会发现<code>thread::spawn</code>要求传入的闭包<code>F</code>必须实现<code>Send</code>，而<code>Rc</code>类型的<code>a</code>没有实现<code>Send</code>，所以编译器报错了。</p><p>我们知道<code>Rc</code>是引用计数，它为了性能没有实现原子操作的引用计数，如果在多个线程中共享，那么引用计数可能会出现计数错误，所以不能安全的跨线程共享。</p><p>那<code>Send</code>是干什么的呢？</p><p><code>Send</code>是一个<code>trait</code>，它标记了实现它的类型可以安全的在线程间<strong>传递</strong>所有权。也就是可以安全的<strong>移动</strong>（<code>move</code>）其所有权。</p><p><code>Send trait</code>是一个<strong>标记型（marker）</strong>的<code>trait</code>, 它没有实际方法，也不需要用户主动去实现，一般基本类型都实现了<code>Send</code>。而复合类型如果包含的所有成员都实现了<code>Send</code>，那么它也<strong>自动</strong>实现了<code>Send</code>。（后面的<code>Sync</code>也是这样的自动<code>trait</code>）</p><p>也就是说，需要并发中需要安全传递<strong>值</strong>都需要被标记实现<code>Send</code>，否则编译器会报错。</p><p>并发安全检查变成了<code>trait bound</code>检查，这样就能在编译时发现问题，而不是在运行时，是不是很巧妙！</p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>再来看看下边代码，尝试将<code>String</code>类型的引用计数<code>a</code>（<code>&amp;Rc&lt;String&gt;</code>）共享到一个线程中去，会发现编译器报错了。（注意没有移动，是共享）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, thread&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    <span class="comment">// 注意！这里没有用move，闭包获取的是a的引用（&amp;Rc&lt;String&gt;）</span></span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> b = a.clone();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// `Rc&lt;String&gt;` cannot be shared between threads safely</span></span><br><span class="line">    <span class="comment">// the trait `Sync` is not implemented for `Rc&lt;String&gt;`</span></span><br><span class="line">    <span class="comment">// required for `&amp;Rc&lt;String&gt;` to implement `Send`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然，<code>Rc</code>没有实现<code>Sync</code>，所有编译器报错了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> Rc&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Sync</code>也是一个标记型<code>trait</code>，它标记了实现它的类型可以安全的在线程间共享访问。</p><p>所谓共享，其实就是可以安全的引用。而如果<code>&amp;T</code>实现了<code>Send</code>（可安全移动），那么<code>T</code>就实现了<code>Sync</code>（可安全共享其的引用）。</p><p>也就是说，需要并发中需要安全<strong>引用</strong>（<code>&amp;T</code>）都需要<code>T</code>被标记实现了<code>Sync</code>，否则编译器会报错。</p><p>又是一个巧妙的设计，通过<code>trait bound</code>检查了引用是否满足并发安全。</p><p>总结一下：</p><ul><li><code>Send</code>标记了实现它的类型可以安全的在线程间传递所有权（<code>move</code>）。</li><li><code>Sync</code>标记了实现它的类型可以安全的在线程间共享引用（<code>&amp;T</code>）。</li></ul><p>最后推荐看看官方的这两篇文档来加深理解</p><ul><li><a href="https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html" target="_blank" rel="noopener">Extensible Concurrency with the Sync and Send Traits</a></li><li><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html" target="_blank" rel="noopener">Send and Sync</a></li></ul><!-- ---文章首发公众号：newbmiao![欢迎关注，获取及时更新内容](/images/qrcode/newbmiao.png) -->]]></content>
    
    <summary type="html">
    
      聊聊Rust的并发约束：Send和Sync
    
    </summary>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/categories/rust/"/>
    
    
      <category term="rust" scheme="https://newbmiao.github.io/tags/rust/"/>
    
      <category term="send" scheme="https://newbmiao.github.io/tags/send/"/>
    
      <category term="sync" scheme="https://newbmiao.github.io/tags/sync/"/>
    
  </entry>
  
</feed>
