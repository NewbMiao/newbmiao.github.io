<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟Miao</title>
  <icon>https://www.gravatar.com/avatar/644a62fb3ee1c60061ebca1d0996b0ae</icon>
  <subtitle>start from a newb...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.newbmiao.com/"/>
  <updated>2023-06-19T10:09:52.937Z</updated>
  <id>http://blog.newbmiao.com/</id>
  
  <author>
    <name>菜鸟Miao</name>
    <email>newbvirgil@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入解读-如何用keycloak管理external auth</title>
    <link href="http://blog.newbmiao.com/2023/06/18/auth-manage-via-keycloak.html"/>
    <id>http://blog.newbmiao.com/2023/06/18/auth-manage-via-keycloak.html</id>
    <published>2023-06-18T14:10:20.000Z</published>
    <updated>2023-06-19T10:09:52.937Z</updated>
    
    <content type="html"><![CDATA[<p>提到<code>OAuth2</code>，大家多少都有些了解。</p><blockquote><p>不了解的话可以先看下之前的<a href="http://blog.newbmiao.com/2021/09/19/tech-behind-authentication.html">简单聊聊鉴权背后的那些技术</a>先回顾一下基本概念和流程。</p></blockquote><p>简单来说，以<code>google</code>授权为例，一般就是通过用户授权页面登录<code>google</code>账号，再跳转用<code>code</code>换取到相应权限的<code>token</code>，就可以代表用户去发起一些<code>google api</code>的请求。</p><p>直接代码实现这套授权逻辑并不复杂，不过如果还需要接入<code>facebook</code>授权，<code>instagram</code>授权呢，总不能挨个去实现一遍吧。</p><p>最好能有一套通用的解决方案来解放双手， 今天我们就聊聊如何用<code>keycloak</code>实现一套通用的身份验证和授权管理方案。</p><blockquote><p>提前说明，无法本地复刻的技术方案不利于理解，也不利于方案探讨。虽然本文章所用代码是使用了<code>rust</code>的<code>axum</code>框架（为啥？因为<code>rust</code> is future！）+<code>keycloak</code>，但从服务启动到<code>keycloak</code>服务及相关配置，都用<code>docker-compose+terraform+shell</code> 脚本化管理，可100%本地复刻，欢迎本地尝试。（当然我说的是<code>Mac</code>下）代码地址： <a href="https://github.com/NewbMiao/axum-koans" target="_blank" rel="noopener">https://github.com/NewbMiao/axum-koans</a></p></blockquote><a id="more"></a><h2 id="初探OAuth"><a href="#初探OAuth" class="headerlink" title="初探OAuth"></a>初探<code>OAuth</code></h2><p>在引入<code>keycloak</code>之前我们以<code>google</code>为例先看下常规<code>OAuth</code>怎么接入，方便后边和<code>keycloak</code>接入对比。</p><blockquote><p>前置工作： 获取<code>google OAuth application</code>的<code>clientId</code>和<code>clientSecret</code>，不清楚的话，可以参考 <strong>Create a Google Application</strong> in <a href="https://keycloakthemes.com/blog/how-to-setup-sign-in-with-google-using-keycloak" target="_blank" rel="noopener">How to setup Sign in with Google using Keycloak</a></p></blockquote><p>如下图，一般授权流程（<code>standard flow</code>）中客户端和<code>auth server</code>主要是两个阶段</p><ul><li>生成<code>auth url</code>跳转登录后请求换取授权令牌的<code>code</code></li><li>在<code>auth callback</code>中用<code>code</code>换取<code>token</code>，得到能代表用户的<code>credentials</code>，一般是<code>accessToken</code></li></ul><p><img src="https://blog.postman.com/wp-content/uploads/2020/06/image5.png" alt="Authorization Code flow for OAuth"></p><p>这个流程自己也可以实现，但一般都用<code>oidc client</code>（其实现了<code>OpenID connect</code>协议，是建立在<code>OAuth2.0</code>上的身份验证协议，用来为应用提供用户身份信息）来实现。</p><p>编程语言实现上大同小异，下边代码以<code>rust</code>的<code>oauth2</code>库为例讲解</p><p>如果不熟悉<code>rust</code>，可以重点看<strong>代码注释</strong>，也不影响理解</p><h3 id="初始化oidc-client"><a href="#初始化oidc-client" class="headerlink" title="初始化oidc client"></a>初始化<code>oidc client</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::new</span></span><br><span class="line"><span class="comment">// 注册auth server 的授权登录地址，授权时会生成带有相应参数的 auth url</span></span><br><span class="line"><span class="keyword">let</span> auth_url =</span><br><span class="line">    AuthUrl::new(<span class="string">"https://accounts.google.com/o/oauth2/v2/auth"</span>.to_string()).unwrap();</span><br><span class="line"><span class="comment">// 注册auth server 的授权登录成功后要跳转到的客户端地址（auth callback url），会携带code</span></span><br><span class="line"><span class="keyword">let</span> redirect_url = RedirectUrl::new(config.redirect_url).unwrap();</span><br><span class="line"><span class="comment">// 注册auth server 的code换取token的地址</span></span><br><span class="line"><span class="keyword">let</span> token_url =</span><br><span class="line">    TokenUrl::new(<span class="string">"https://www.googleapis.com/oauth2/v3/token"</span>.to_string()).unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = BasicClient::new(</span><br><span class="line">    <span class="comment">// 注册google application client credentials, 会有相应权限和客户端限制，如web application类型会有访问地址origin及callback地址的白名单限制</span></span><br><span class="line">    ClientId::new(config.client_id),</span><br><span class="line">    <span class="literal">Some</span>(ClientSecret::new(config.client_secret)),</span><br><span class="line">    auth_url,</span><br><span class="line">    <span class="literal">Some</span>(token_url),</span><br><span class="line">)</span><br><span class="line">.set_redirect_uri(redirect_url);</span><br></pre></td></tr></table></figure><h3 id="生成auth-url"><a href="#生成auth-url" class="headerlink" title="生成auth url"></a>生成auth url</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::auth_url</span></span><br><span class="line"><span class="keyword">let</span> (url, csrf_token) = client</span><br><span class="line">    <span class="comment">// 参数是用于生成state的函数，这里用csrftoken,可以在auth callback中校验state参数是否合法</span></span><br><span class="line">    .authorize_url(CsrfToken::new_random)</span><br><span class="line">    <span class="comment">// auth请求需要的权限（scope）,一般获取用户信息的话，profile和email就好了</span></span><br><span class="line">    .add_scope(Scope::new(</span><br><span class="line">        <span class="string">"https://www.googleapis.com/auth/userinfo.profile"</span>.to_string(),</span><br><span class="line">    ))</span><br><span class="line">    .add_scope(Scope::new(</span><br><span class="line">        <span class="string">"https://www.googleapis.com/auth/userinfo.email"</span>.to_string(),</span><br><span class="line">    ))</span><br><span class="line">    <span class="comment">// 需要显示OAuth需要授权的内容给用户来确认是否同意，就是我们常见的google授权确认页面</span></span><br><span class="line">    .add_extra_param(<span class="string">"prompt"</span>, <span class="string">"consent"</span>)</span><br><span class="line">    <span class="comment">// 允许应用程序获得长期有效的访问令牌（accessToken）和刷新令牌(refreshToken)</span></span><br><span class="line">    .add_extra_param(<span class="string">"access_type"</span>, <span class="string">"offline"</span>)</span><br><span class="line">    .url();</span><br></pre></td></tr></table></figure><p>这里参数<code>access_type=offline</code>对于应用需要长期<code>accessToken</code>是很关键的。一般<code>accessToken</code>都有过期时间，如果没有有效的<code>refreshToken</code>来刷新<code>accessToken</code>，就会有<code>accessToken</code>失效后还要用户再登录的尴尬局面-_-!</p><p>另外为安全考虑除了可以用<code>state</code>做请求合法校验，还可以用<a href="https://blog.postman.com/pkce-oauth-how-to" target="_blank" rel="noopener"><code>PKCE(Proof Key for Code Exchange)</code></a>来加强, 实际用到的代码有实现，感兴趣可以看下</p><h3 id="auth-callback换取token"><a href="#auth-callback换取token" class="headerlink" title="auth callback换取token"></a>auth callback换取token</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/google_auth.rs@GoogleAuth::get_tokens</span></span><br><span class="line"><span class="comment">// 校验请求，state及pkce, 这里省略展示</span></span><br><span class="line"><span class="comment">// code 换取token</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> res = client.exchange_code(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求发送，axum中不能使用block请求，防止阻塞框架的异步事件循环</span></span><br><span class="line"><span class="keyword">let</span> res = res.request_async(async_http_client).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line"><span class="literal">Ok</span>(TokenInfo &#123;</span><br><span class="line">    refresh_token: res.refresh_token().unwrap().secret().to_string(),</span><br><span class="line">    access_token: res.access_token().secret().to_string(),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这部分不复杂，按文档配好本地，可以访问<code>http://localhost:8000/google/auth</code>来尝试上述<code>flow</code></p><h2 id="使用keycloak-IDP"><a href="#使用keycloak-IDP" class="headerlink" title="使用keycloak IDP"></a>使用keycloak IDP</h2><h3 id="keycloak-配置"><a href="#keycloak-配置" class="headerlink" title="keycloak 配置"></a>keycloak 配置</h3><p>上边流程怎么让keycloak这个身份和访问管理系统接管呢，答案是使用<code>keycloak IDP</code> (<code>Identity provider</code>)</p><p>我们先看下需要如何配置相应配置，这里先用<a href="https://registry.terraform.io/providers/mrparkers/keycloak/latest/docs" target="_blank" rel="noopener"><code>terraform - keycloak provider</code></a> 展示下配置。</p><blockquote><p>等效的页面配置可以后边参考之前的链接 <a href="https://keycloakthemes.com/blog/how-to-setup-sign-in-with-google-using-keycloak" target="_blank" rel="noopener">How to setup Sign in with Google using Keycloak</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 这里使用默认的admin-cli配置keycloak</span><br><span class="line"># 也可生成一个专门的client，用clientId+clientSecret的方式</span><br><span class="line">provider &quot;keycloak&quot; &#123;</span><br><span class="line">  client_id &#x3D; &quot;admin-cli&quot;</span><br><span class="line">  url       &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&quot;</span><br><span class="line">  username  &#x3D; &quot;***&quot;</span><br><span class="line">  password  &#x3D; &quot;***&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 1. 创建一个realm（领域），并启用, 类似命名空间，代表一个安全的独立区域</span><br><span class="line">resource &quot;keycloak_realm&quot; &quot;realm_axum_koans&quot; &#123;</span><br><span class="line">  realm   &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  enabled &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 2. 添加google idp， 这里需要google client credentials</span><br><span class="line"></span><br><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  realm         &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  # client_id和secret通过环境变量获取</span><br><span class="line">  client_id     &#x3D; var.google_client_id</span><br><span class="line">  client_secret &#x3D; var.google_client_secret</span><br><span class="line">  trust_email   &#x3D; true</span><br><span class="line">  # &quot;*&quot; 则不约束使用此idp的domain</span><br><span class="line">  hosted_domain &#x3D; &quot;*&quot;</span><br><span class="line">  sync_mode     &#x3D; &quot;IMPORT&quot;</span><br><span class="line">  provider_id   &#x3D; &quot;google&quot;</span><br><span class="line"></span><br><span class="line">  default_scopes &#x3D; &quot;openid profile email&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 3. 添加将要用来google auth打交道的client</span><br><span class="line">resource &quot;keycloak_openid_client&quot; &quot;client_axum_koans&quot; &#123;</span><br><span class="line">  realm_id &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  name     &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  enabled  &#x3D; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  client_id             &#x3D; &quot;axum-koans&quot;</span><br><span class="line">  client_secret         &#x3D; &quot;***&quot;</span><br><span class="line">  standard_flow_enabled &#x3D; true</span><br><span class="line"></span><br><span class="line">  access_type &#x3D; &quot;CONFIDENTIAL&quot;</span><br><span class="line">  # 配置auth callback url</span><br><span class="line">  valid_redirect_uris &#x3D; [</span><br><span class="line">    &quot;http:&#x2F;&#x2F;localhost:8000&#x2F;keycloak&#x2F;login-callback&quot;</span><br><span class="line">  ]</span><br><span class="line">  web_origins        &#x3D; [&quot;*&quot;]</span><br><span class="line">  use_refresh_tokens &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看代码版的配置稍微有点多，主要配置其实就只有注释里的三处，然后google OAuth的代理设置就完成了，不信我们继续往下看怎么代码接入</p><h3 id="keycloak-auth接入"><a href="#keycloak-auth接入" class="headerlink" title="keycloak auth接入"></a>keycloak auth接入</h3><p>上边<code>keycloak</code>配置了<code>realm</code>，后边授权和<code>token</code>获取都会和这个<code>realm</code>下的<code>issueUrl</code>打交道，这里<code>issueUrl</code>就类似<code>google</code>的<code>auth server</code> 地址。</p><ol><li>初始化<code>keycloak oidc client</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::new</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们配置生成的issue_url将会是： http://localhost:8080/realms/axum-koans</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置token url, auth url 和auth callback url(redirect url)</span></span><br><span class="line"><span class="keyword">let</span> token_url = TokenUrl::new(get_url_with_issuer(</span><br><span class="line">    &amp;config.issuer_url,</span><br><span class="line">    <span class="string">"/protocol/openid-connect/token"</span>,</span><br><span class="line">))</span><br><span class="line">.unwrap();</span><br><span class="line"><span class="keyword">let</span> auth_url = AuthUrl::new(get_url_with_issuer(</span><br><span class="line">    &amp;config.issuer_url,</span><br><span class="line">    <span class="string">"/protocol/openid-connect/auth"</span>,</span><br><span class="line">))</span><br><span class="line">.unwrap();</span><br><span class="line"><span class="keyword">let</span> redirect_url = RedirectUrl::new(config.redirect_url).unwrap();</span><br><span class="line"><span class="keyword">let</span> client = BasicClient::new(client_id, <span class="literal">Some</span>(client_secret), auth_url, <span class="literal">Some</span>(token_url))</span><br><span class="line">    .set_redirect_uri(redirect_url);</span><br></pre></td></tr></table></figure><ol start="2"><li>生成<code>auth_url</code></li></ol><p>方法基本和之前<code>google</code>配置一模一样。</p><p>这里也能看出为啥需要<code>oidc</code>协议，其实就是抽象化，提供了一种安全、标准化和可扩展的身份验证和授权协议。它简化了应用程序中的身份管理和访问控制，提供了一致的用户登录体验，并提高了应用程序的安全性。</p><p>这里<code>auth url</code>默认跳转的是<code>keycloak</code>登录页面，然后<code>google idp</code>是作为一种登录选项让用户选择。但如果就打算让用户直接<code>google</code>登录，可以跳过<code>keycloak</code>登录页。</p><p>方法是使用客户端建议的<code>idp（kc_idp_hint）</code>:<a href="https://www.keycloak.org/docs/latest/server_admin/#_client_suggested_idp" target="_blank" rel="noopener"><code>Client-suggested Identity Provider</code></a></p><p>这样就可以直接使用指定的<code>idp</code>进行授权登录</p><p>代码如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::auth_url</span></span><br><span class="line">client.add_extra_param(<span class="string">"kc_idp_hint"</span>, <span class="string">"google"</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li><code>auth callback</code>换取<code>token</code></li></ol><p>方法也同 <code>google auth callback</code>, 这里不赘述了。</p><p>不过这里拿到的是<code>keycloak</code>的<code>token</code>。要是需要<code>google</code>的<code>token</code>怎么办？</p><p>别急，有两种办法。</p><h2 id="方法一：-token-exchange"><a href="#方法一：-token-exchange" class="headerlink" title="方法一： token-exchange"></a>方法一： token-exchange</h2><p><a href="https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange" target="_blank" rel="noopener"><code>token-exchange</code></a> 是用于<code>token</code>交换场景，我们这里是用<code>keycloak token</code>换取外部<code>google token</code>（<code>external token</code>）</p><h3 id="相应keycloak配置"><a href="#相应keycloak配置" class="headerlink" title="相应keycloak配置"></a>相应<code>keycloak</code>配置</h3><blockquote><p><code>token-exchange</code>目前还是<code>keycloak</code>预览（<code>preview</code>）功能，需要至少在<code>features</code>中启用<code>admin-fine-grained-authz,token-exchange</code>才可使用(详见<code>keycloak docker-composer</code>配置 )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启用idp获取refresh token</span><br><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">  # for token exchange to get google access token</span><br><span class="line">  request_refresh_token &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启用 idp token exchange permission, 并用policy关联对应的client</span><br><span class="line">resource &quot;keycloak_identity_provider_token_exchange_scope_permission&quot; &quot;oidc_idp_permission&quot; &#123;</span><br><span class="line">  realm_id       &#x3D; keycloak_realm.realm_axum_koans.id</span><br><span class="line">  provider_alias &#x3D; keycloak_oidc_google_identity_provider.google.alias</span><br><span class="line">  policy_type    &#x3D; &quot;client&quot;</span><br><span class="line">  clients &#x3D; [</span><br><span class="line">    keycloak_openid_client.client_axum_koans.id</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> token_url =</span><br><span class="line">   <span class="built_in">format!</span>( <span class="string">"&#123;&#125;/protocol/openid-connect/token"</span>,&amp;<span class="keyword">self</span>.config.issuer_url);</span><br><span class="line"><span class="keyword">let</span> response = Client::new()</span><br><span class="line">    .post(token_url)</span><br><span class="line">    .form(&amp;[</span><br><span class="line">        <span class="comment">// token exchange type</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"grant_type"</span>,</span><br><span class="line">            <span class="string">"urn:ietf:params:oauth:grant-type:token-exchange"</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 传入keycloak access token</span></span><br><span class="line">        (<span class="string">"subject_token"</span>, &amp;access_token),</span><br><span class="line">        (<span class="string">"client_id"</span>, &amp;<span class="keyword">self</span>.config.client_id),</span><br><span class="line">        (<span class="string">"client_secret"</span>, &amp;<span class="keyword">self</span>.config.client_secret),</span><br><span class="line">        <span class="comment">// 请求换取google access token</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"requested_token_type"</span>,</span><br><span class="line">            <span class="string">"urn:ietf:params:oauth:token-type:access_token"</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 要换取的external idp: google</span></span><br><span class="line">        (<span class="string">"requested_issuer"</span>, <span class="string">"google"</span>),</span><br><span class="line">    ])</span><br><span class="line">    .send()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"><span class="comment">// json deserialized as access token</span></span><br><span class="line"><span class="literal">Ok</span>(from_str(&amp;response.text().<span class="keyword">await</span>?)?)</span><br></pre></td></tr></table></figure><p>这样就获取到了可用的<code>google access token</code>， 实际上内部是通过<code>google refresh token</code>换取到的。</p><p>这样常规请求没问题了，只要你有<code>keycloak access token</code>, 就能换取到<code>google access token</code>来请求<code>google api</code>。so easy?!</p><h2 id="方法二：broker-读取-stored-token"><a href="#方法二：broker-读取-stored-token" class="headerlink" title="方法二：broker 读取 stored token"></a>方法二：broker 读取 stored token</h2><p>然而，要是需要<code>google refresh token</code>怎么办？</p><p>有些场景是客户端需要自己通过<code>google refresh token</code>换取<code>access token</code>来发起请求的，难道这个时候客户端先去拿个<code>keycloak access token</code>么。。。？</p><p>这就可以用<a href="https://www.keycloak.org/docs/latest/server_admin/#retrieving-external-idp-tokens" target="_blank" rel="noopener">Retrieving external IDP tokens</a></p><p>底层实现是授权时存储了<code>external token</code>,再配合添加<code>broker read token</code>权限给生成的用户，就可以用<code>keycloak access token</code>换取存储的<code>external access token + refresh token</code>.</p><h3 id="相应keycloak配置-1"><a href="#相应keycloak配置-1" class="headerlink" title="相应keycloak配置"></a>相应keycloak配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;keycloak_oidc_google_identity_provider&quot; &quot;google&quot; &#123;</span><br><span class="line">  ...</span><br><span class="line">  # for retrieve idp token (with refresh token)</span><br><span class="line">  &#x2F;&#x2F; 存储idp token</span><br><span class="line">  store_token                   &#x3D; true</span><br><span class="line">  &#x2F;&#x2F; 用户生成是添加broker read token 权限</span><br><span class="line">  add_read_token_role_on_create &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题外话：这里<code>add_read_token_role_on_create</code>对应的配置在21.1.1版<code>keycloak admin</code>页面没有，但<code>admin api</code>确可以设置，也是很tricky</p></blockquote><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>就是直接换取<code>refresh_token</code>, 请求地址指明对应的<code>idp</code>即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/extensions/keycloak_auth.rs@KeycloakAuth::get_idp_token</span></span><br><span class="line"><span class="keyword">let</span> token_url = <span class="built_in">format!</span>( <span class="string">"&#123;&#125;/broker/google/token"</span>,&amp;<span class="keyword">self</span>.config.issuer_url);</span><br><span class="line"><span class="keyword">let</span> response = Client::new()</span><br><span class="line">    .get(token_url)</span><br><span class="line">    .bearer_auth(access_token)</span><br><span class="line">    .header(CONTENT_TYPE, HeaderValue::from_static(<span class="string">"application/json"</span>))</span><br><span class="line">    .send()</span><br><span class="line">    .<span class="keyword">await</span>?;</span><br><span class="line"><span class="keyword">let</span> res = response.text().<span class="keyword">await</span>?;</span><br><span class="line"><span class="literal">Ok</span>(from_str(&amp;res)?)</span><br></pre></td></tr></table></figure><blockquote><p>题外话：当然直接给用户这么获取<code>refresh token</code>的能力并不安全，还需要考虑对<code>broker read token</code>接口的访问约束等来更好的保证安全<code>token</code>换取。</p></blockquote><p>上边<code>keycloak</code>授权方案可以本地配好环境后，用<a href="http://localhost:8000/keycloak/login" target="_blank" rel="noopener">http://localhost:8000/keycloak/login</a> 来尝试。</p><hr><p>好了，<code>keycloak</code>如何管理<code>external auth</code>到这里就结束了。以上是我在使用<code>keycloak</code>的一些摸索和思考，欢迎大家一起探讨。</p><p>再次附上本文的代码地址以供验证：<a href="https://github.com/NewbMiao/axum-koans" target="_blank" rel="noopener">https://github.com/NewbMiao/axum-koans</a></p>]]></content>
    
    <summary type="html">
    
      深入解读-如何用keycloak管理external auth
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/categories/rust/"/>
    
      <category term="OIDC" scheme="http://blog.newbmiao.com/categories/rust/OIDC/"/>
    
      <category term="oauth2" scheme="http://blog.newbmiao.com/categories/rust/OIDC/oauth2/"/>
    
    
      <category term="terraform" scheme="http://blog.newbmiao.com/tags/terraform/"/>
    
      <category term="rust" scheme="http://blog.newbmiao.com/tags/rust/"/>
    
      <category term="oauth2" scheme="http://blog.newbmiao.com/tags/oauth2/"/>
    
      <category term="OIDC" scheme="http://blog.newbmiao.com/tags/OIDC/"/>
    
      <category term="axum" scheme="http://blog.newbmiao.com/tags/axum/"/>
    
      <category term="keycloak" scheme="http://blog.newbmiao.com/tags/keycloak/"/>
    
      <category term="token-exchange" scheme="http://blog.newbmiao.com/tags/token-exchange/"/>
    
      <category term="google-idp" scheme="http://blog.newbmiao.com/tags/google-idp/"/>
    
  </entry>
  
  <entry>
    <title>如何在docker中缓存加速Rust依赖构建</title>
    <link href="http://blog.newbmiao.com/2021/11/21/cache-rust-dependencies-with-docker-build.html"/>
    <id>http://blog.newbmiao.com/2021/11/21/cache-rust-dependencies-with-docker-build.html</id>
    <published>2021-11-21T09:14:23.000Z</published>
    <updated>2023-06-18T00:52:29.957Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习《陈天 · Rust 编程第一课》，在用<code>docker</code>镜像打包构建代码示例时，每次都会在更新<code>crate.io</code>索引上等上一会，即便在没有修改<code>Cargo.tomal</code>依赖的前提下。</p><p>想着难道没有办法缓存下更新么，于是就有了这篇新手踩坑指南。</p><a id="more"></a><h2 id="本地缓存-失败"><a href="#本地缓存-失败" class="headerlink" title="本地缓存 - 失败"></a>本地缓存 - 失败</h2><p>查阅有在<code>docker</code>中指定<code>CARGO_HOME</code>到宿主机来缓存<code>crate.io</code>索引</p><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --user "$(id -u)":"$(id -g)" -v "$PWD":/usr/src/myapp -w /usr/src/myapp -e CARGO_HOME=".cargo" rust cargo run</span><br></pre></td></tr></table></figure><p>结果，镜像run失败了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   Compiling libc v0.2.107</span><br><span class="line">   Compiling autocfg v1.0.1</span><br><span class="line">   Compiling siphasher v0.3.7</span><br><span class="line">   Compiling unicode-xid v0.2.2</span><br><span class="line">   Compiling memchr v2.4.1</span><br><span class="line">   Compiling lazy_static v1.4.0</span><br><span class="line">   Compiling ppv-lite86 v0.2.15</span><br><span class="line">   Compiling pin-project-lite v0.2.7</span><br><span class="line">   Compiling pkg-config v0.3.22</span><br><span class="line">error: failed to build archive: Input/output error</span><br><span class="line"></span><br><span class="line">error: error writing dependencies to `/usr/src/myapp/.target/debug/deps/pkg_config-8dafe7024c916ac6.d`: Input/output error (os error 5)</span><br></pre></td></tr></table></figure><p>一番查阅，应该是环境不一致时<code>pkg-config</code>编译时链接库有问题，详见 <a href="https://ttys3.dev/post/rust-cross-compile-darwin-target-troubleshooting/" target="_blank" rel="noopener">Rust 交叉编译 OSX 二进制失败原因分析</a> 和 <a href="https://stackoverflow.com/a/49173699/4431337" target="_blank" rel="noopener">Unable to run a Docker image with a Rust executable</a></p><h2 id="镜像缓存-成功"><a href="#镜像缓存-成功" class="headerlink" title="镜像缓存 - 成功"></a>镜像缓存 - 成功</h2><p>然后就搜到了这篇<a href="https://stackoverflow.com/a/58474618/4431337" target="_blank" rel="noopener">cache-rust-dependencies-with-docker-build</a></p><p>真是非常tricky！</p><p>思想很简单，就是缓存要在依赖不变的前提下，而docker build时源代码更改会使缓存的<code>docker layer</code>失效。</p><p>那就先用一个不会变得源代码编译依赖，编译好依赖缓存layer，再文件替换到实际代码，重新进行编译就正常运行加缓存两不误了。</p><p>具体构建方式如下：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> rust</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"fn main() &#123;&#125;"</span> &gt; dummy.rs</span></span><br><span class="line"><span class="keyword">ARG</span> SRC_DIR</span><br><span class="line"><span class="keyword">ENV</span> SRC_DIR=$&#123;SRC_DIR:-&#125;</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;SRC_DIR&#125;</span>/Cargo.toml .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s#src/main.rs#dummy.rs#'</span> Cargo.toml</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cargo build --release</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s#dummy.rs#src/main.rs#'</span> Cargo.toml</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$&#123;SRC_DIR&#125;</span>/. .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> cargo build --release</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"target/release/app"</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>这里构建参数<code>SRC_DIR</code>是为了指定不同代码，复用同一个<code>Dockerfile</code></p></blockquote><p>相应的<code>Cargo.toml</code>指定打包的程序名和路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[bin]]</span><br><span class="line">name = "app"</span><br><span class="line">path = "src/main.rs"</span><br></pre></td></tr></table></figure><p>打包和运行则可以一行命令搞定：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run.sh</span></span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">WORKSPACE=$(cd <span class="string">"$(dirname "</span>$<span class="number">0</span><span class="string">")"</span> &amp;&amp; pwd -P)</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --rm -it <span class="string">"<span class="variable">$(docker build --build-arg SRC_DIR="$SRC_DIR" -q "$WORKSPACE" -t "rust-$SRC_DIR")</span>"</span> <span class="comment">#"$@"</span></span></span><br></pre></td></tr></table></figure><p>运行时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> eg：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SRC_DIR=scrape_url sh run.sh https://www.rust-lang.org/ rust.md</span></span><br></pre></td></tr></table></figure><p>完美缓存了依赖更新，可以继续学习了</p><p>另外也推荐下陈天老师的rust课，由浅入深，感兴趣的同学可以试试</p><p><img src="http://media.newbmiao.com/assets/rust.jpeg" alt="陈天 · Rust 编程第一课"></p><blockquote><p>本文代码示例详见<a href="https://github.com/NewbMiao/rust-koan" target="_blank" rel="noopener">rust-koan</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      cache-rust-dependencies-with-docker-build
    
    </summary>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/categories/rust/"/>
    
    
      <category term="rust" scheme="http://blog.newbmiao.com/tags/rust/"/>
    
      <category term="docker" scheme="http://blog.newbmiao.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊鉴权背后的那些技术</title>
    <link href="http://blog.newbmiao.com/2021/09/19/tech-behind-authentication.html"/>
    <id>http://blog.newbmiao.com/2021/09/19/tech-behind-authentication.html</id>
    <published>2021-09-19T15:00:09.000Z</published>
    <updated>2023-06-18T15:04:08.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近弄了一个<code>keycloak</code>鉴权相关demo(地址附文末)， 可以让不熟悉的<code>keycloak</code>的同学有一个快速、直观的了解。</p><p>今天结合背后的技术概念，简单聊聊：鉴权（<code>authentication</code>）和授权（<code>authorization</code>）以及<code>Oauth2</code>、<code>OpenID Connect</code>、<code>JWT</code> 和 <code>JWKS</code>。</p><a id="more"></a><h2 id="鉴权-VS-授权"><a href="#鉴权-VS-授权" class="headerlink" title="鉴权 VS 授权"></a>鉴权 VS 授权</h2><p>这两个概念的英文太相近，真是傻傻分不清，不过中文还好。</p><p>鉴权（<code>Authentication</code>, 也作<code>AuthN</code>）：判断你是谁，通过密码或者授权码之类凭证</p><p>授权（<code>Authorization</code>，也作<code>AuthZ</code>）：授权用户或角色等访问资源的权限，</p><p>如下图：</p><p><img src="https://www.okta.com/sites/default/files/styles/1640w_scaled/public/media/image/2020-10/Authentication_vs_Authorization.png?itok=uBFRCfww" alt="Authentication VS Authorization"></p><p>举例来说会更清晰：</p><p>假如你需要让A帮忙喂宠物，你给A了一个一次性的密码Key让其可以通过你家门禁（鉴权）。<br>但A进去后，只有到厨房拿宠物粮和客厅喂宠物，不能到其他房间则是其持有密码Key的权限（授权）</p><h2 id="Oauth2"><a href="#Oauth2" class="headerlink" title="Oauth2"></a>Oauth2</h2><p><code>Oauth2</code>是一个授权的协议，为客户端授权提供了一系列授权的流程来获取授权的访问令牌（<code>AccessToken</code>），比如</p><ul><li><code>Authorization Code flow</code><br>需要提供注册的clientID和clientSecret<br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image5.png" alt="Authorization Code flow"></li><li><del><code>Implicit flow</code></del><br>省掉了<code>Code</code>环节, 放松了对客户端的校验，牺牲安全性来提高效率，<strong>已不推荐</strong><br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image1.png" alt="Implicit flow"></li><li><code>Authorization Code flow (with PKCE)</code><br>需要提供注册的clientID和即时生成的 <code>code challenge</code>（像一次性的secret，不可被篡改）<br><img src="https://blog.postman.com/wp-content/uploads/2020/06/image6.png" alt="PKCE flow"></li></ul><p>为什么需要<code>Oauth2</code>?</p><p>还拿喂宠物的例子来说，你找代理喂宠物，不会想把自己的密码直接给他，那太不安全，需要一个安全的机制来临时授予尽量少的权限给代理方。</p><h2 id="OpenID-connect-OIDC"><a href="#OpenID-connect-OIDC" class="headerlink" title="OpenID connect (OIDC)"></a>OpenID connect (OIDC)</h2><p><code>OIDC</code>是在<code>Oauth2</code>协议基础上扩展的认证层，提供ID令牌（<code>IDToken</code>）可以让客户端通过认证来识别用户.</p><p>应该是当今最常用的鉴权实现协议，有很多相关实现的通用类库。</p><h2 id="JWT-amp-amp-JWKS"><a href="#JWT-amp-amp-JWKS" class="headerlink" title="JWT &amp;&amp; JWKS"></a>JWT &amp;&amp; JWKS</h2><p>上边提到的<code>AccessToken</code>和<code>IDToken</code>都是用<code>Json Web Token（JWT）</code>技术来实现的。</p><p><code>JWT</code>分为三段（<code>.</code>分隔，各自<code>base64Url</code>编码）</p><ul><li>header<br>包含如签名算法<code>alg</code>，签名公钥ID <code>kid</code>, 类型等</li><li>payload<br>包含令牌签发相关数据如签发人<code>iss</code>，过期时间<code>exp</code>,签发时间<code>iat</code>等，及自定义的数据如权限及用户标识等<br>具体token所携带的信息可以通过<a href="https://jwt.io/" target="_blank" rel="noopener">jwt.io</a>来查看</li><li>signature<br>token前两部分的签名，防止被篡改</li></ul><p>这里校验可以用签名的公钥,可以在<code>JSON Web Key Set（JWKS）</code>中通过<code>header</code>的公钥id<code>kid</code>和<code>payload</code>的签发服务<code>iss</code>的配置服务中（<code>/.well-known/openid-configuration</code>）找到。</p><p>如demo中:</p><ul><li>签发服务（<code>iss</code>)<br><code>http://localhost/auth/realms/myrealm</code></li><li>配置发现（<code>discovery configuration</code>)<br><code>http://localhost/auth/realms/myrealm/.well-known/openid-configuration</code></li><li><code>JWK</code>公钥配置(<code>jwks_uri</code>)<br><code>http://localhost/auth/realms/myrealm/protocol/openid-connect/certs</code></li></ul><h2 id="Keycloak"><a href="#Keycloak" class="headerlink" title="Keycloak"></a>Keycloak</h2><p>说这么一圈，回到demo的主题，<code>keycloak</code>,一种开源的身份及访问管理（<code>IAM</code>）服务。官方称，“为现代应用系统和服务提供开源的鉴权和授权访问控制管理”。</p><p>实现了<code>Oauth2,OpenID Connet,Saml</code>协议的单点登陆<code>SSO</code>，支持多种第三方身份服务<code>Identity Provider(IdP)</code> （OpenID Connect, SAML2.0 IdPs，Github，Google等）来做鉴权，方便简单可以开箱即用。</p><p>在我提供的demo中，主要展示了鉴权相关：</p><ul><li>获取<code>token</code>：在客户端（<code>web</code>页面）使用推荐的<code>PKCE</code>方式获取`accessToken</li><li>校验<code>token</code>：用<code>token issuer</code>配置中<code>jwks</code>的公钥来验证token签名是否合法</li></ul><blockquote><p>相当于离线验证，只能知道<code>token</code>是否合法，不能知道token是否被失效等，更安全的方式是通过<code>token introspection</code>接口验证token是否还有效)</p></blockquote><p>其中<code>web</code>页面内用了<code>react</code>,获取<code>token</code>用了<code>@react-keycloak/web</code>, <code>token</code>校验用了<code>OpenPolicyAgent</code>(单纯为玩，不是推荐用法)<br>为了避免网页跨域<code>cors</code>问题加了<code>nginx</code>反向代理</p><p>动图如下：<br><img src="http://media.newbmiao.com/tech/kecloak-authN.gif" alt="demo"></p><p>具体示例详见：<strong><a href="https://github.com/NewbMiao/keycloak-authN" target="_blank" rel="noopener">https://github.com/NewbMiao/keycloak-authN</a></strong>, 有<code>readme</code>，一键启动。</p>]]></content>
    
    <summary type="html">
    
      tech-behind-authentication
    
    </summary>
    
    
      <category term="tech" scheme="http://blog.newbmiao.com/categories/tech/"/>
    
      <category term="OIDC" scheme="http://blog.newbmiao.com/categories/tech/OIDC/"/>
    
      <category term="oauth2" scheme="http://blog.newbmiao.com/categories/tech/OIDC/oauth2/"/>
    
    
      <category term="oauth2" scheme="http://blog.newbmiao.com/tags/oauth2/"/>
    
      <category term="OIDC" scheme="http://blog.newbmiao.com/tags/OIDC/"/>
    
      <category term="keycloak" scheme="http://blog.newbmiao.com/tags/keycloak/"/>
    
      <category term="authentication" scheme="http://blog.newbmiao.com/tags/authentication/"/>
    
      <category term="authorization" scheme="http://blog.newbmiao.com/tags/authorization/"/>
    
  </entry>
  
  <entry>
    <title>二分递归版or-channel模式的问题</title>
    <link href="http://blog.newbmiao.com/2021/08/22/recursive-ordone-issue.html"/>
    <id>http://blog.newbmiao.com/2021/08/22/recursive-ordone-issue.html</id>
    <published>2021-08-22T13:04:19.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<p>今天在修正昨天的文章《orDone的两种实现》中的压测代码时，无意发现其中的二分递归版的代码是有问题的。</p><p>主要是<code>goroutine</code>泄露的问题，下边简单说明下，也参考自文章<a href="https://tjjsjwhj.me/2021/04/25/go-or-done/" target="_blank" rel="noopener">记一次学习 orDone 模式爬坑经历</a></p><a id="more"></a><h2 id="goroutine泄露"><a href="#goroutine泄露" class="headerlink" title="goroutine泄露"></a>goroutine泄露</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">    <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 2个也是一种特殊情况</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//超过两个，二分法递归处理</span></span><br><span class="line">        m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-or(channels[:m]...):</span><br><span class="line">        <span class="keyword">case</span> &lt;-or(channels[m:]...):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>原代码递归时，没有将结束通道<code>orDone</code>合并，在<code>orDone</code>关闭后，没法通知递归中的<code>goroutine</code>退出，有<code>goroutine</code>泄露的可能</p><p>可修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrWithIssue(<span class="built_in">append</span>(channels[:m:m], orDone)...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrWithIssue(<span class="built_in">append</span>(channels[m:], orDone)...):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无限递归"><a href="#无限递归" class="headerlink" title="无限递归"></a>无限递归</h2><p>以上代码时，还有个问题是在参数为三个<code>chan</code>时会无限递归，(文末参考文章里有通过打印协程数来测试这个问题的代码，感兴趣可以去看下)</p><p>递归树如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3个时有无限递归的问题:</span></span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">    f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">       f(<span class="number">2</span>)  f(<span class="number">3</span>)</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure><p>所以需要对3这种<code>case</code>区分处理</p><p>最终代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrRecur</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 特殊情况，只有0个或者1个chan</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 特殊情况</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 特殊情况</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">2</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 超过3个，二分法递归处理</span></span><br><span class="line">   m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrRecur(<span class="built_in">append</span>(channels[:m:m], orDone)...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-OrRecur(<span class="built_in">append</span>(channels[m:], orDone)...):</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再补充下修正后压测结果，二分递归比反射性能更好些</p><p><img src="http://media.newbmiao.com/dig101/go/orDoneTime.png" alt="时间消耗"><br><img src="http://media.newbmiao.com/dig101/go/orDoneMemory.png" alt="内存消耗"></p><p>感兴趣可以自己跑下<a href="https://github.com/NewbMiao/Dig101-Go/tree/master/concurrency/channel/schedule/orDone" target="_blank" rel="noopener">压测代码</a></p><blockquote><p>虽然是常见的orDone模式，但还是有不少可以探究的地方，想要用好chan还是需要足够仔细啊。</p></blockquote>]]></content>
    
    <summary type="html">
    
      recursive-o-issue
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="or-channel-pattern" scheme="http://blog.newbmiao.com/tags/or-channel-pattern/"/>
    
  </entry>
  
  <entry>
    <title>or-channel模式的两种实现</title>
    <link href="http://blog.newbmiao.com/2021/08/19/2-way-of-or-done-pattern.html"/>
    <id>http://blog.newbmiao.com/2021/08/19/2-way-of-or-done-pattern.html</id>
    <published>2021-08-19T14:08:01.000Z</published>
    <updated>2023-06-18T00:52:29.950Z</updated>
    
    <content type="html"><![CDATA[<p><code>or</code> channel模式是一种并发控制模式，旨在多任务场景下实现，有一个任务成功返回即立即结束等待。</p><p>今天我们来看下两种不同的实现方式：</p><a id="more"></a><h2 id="方式一-递归"><a href="#方式一-递归" class="headerlink" title="方式一 递归"></a>方式一 递归</h2><p>利用二分法递， 将所有待监听信号的<code>chan</code>都<code>select</code>起来，</p><p>当有第一个<code>chan</code>返回时，<code>close orDone</code> 来通知读取方已有第一个任务返回</p><p>代码如下比较直观：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入多个并发chan，返回是否结束的 orDone chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Or</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 只有零个或者1个chan</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 返回nil， 让读取阻塞等待</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 返回时利用close做结束信号的广播</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用select监听第一个chan的返回</span></span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 直接select</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">   <span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 二分法递归处理</span></span><br><span class="line">   m := <span class="built_in">len</span>(channels) / <span class="number">2</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-Or(channels[:m]...):</span><br><span class="line">   <span class="keyword">case</span> &lt;-Or(channels[m:]...):</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二-利用反射"><a href="#方式二-利用反射" class="headerlink" title="方式二 利用反射"></a>方式二 利用反射</h2><p>这里要用到<code>reflect.SelectCase</code>, 他可以描述一种<code>select</code>的<code>case</code>,<br>来指明其接受的是<code>chan</code>的读取或发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SelectCase <span class="keyword">struct</span> &#123;</span><br><span class="line"> Dir  SelectDir <span class="comment">// direction of case</span></span><br><span class="line"> Chan Value     <span class="comment">// channel to use (for send or receive)</span></span><br><span class="line"> Send Value     <span class="comment">// value to send (for send)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个，就可以之间遍历，不用递归来实现有限的<code>select case</code>构造</p><p>最后用<code>reflect.Select(cases)</code>监听信号就可以了，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrInReflect</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> <span class="comment">// 只有0个或者1个</span></span><br><span class="line"> <span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line">  <span class="comment">// 利用反射构建SelectCase，这里是读取</span></span><br><span class="line">  <span class="keyword">var</span> cases []reflect.SelectCase</span><br><span class="line">  <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line">   cases = <span class="built_in">append</span>(cases, reflect.SelectCase&#123;</span><br><span class="line">    Dir:  reflect.SelectRecv,</span><br><span class="line">    Chan: reflect.ValueOf(c),</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机选择一个可用的case</span></span><br><span class="line">  reflect.Select(cases)</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h2><p>这两种都可以支持大量<code>chan</code>的信号监听，那性能差异大么</p><p>虽说递归开销肯定不小，反射也不一定效率高，拿个压测来试试吧</p><p>先构造一下<code>chan</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsStream</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, values ...<span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"> s := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 退出时关闭chan             </span></span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(s)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">case</span> s &lt;- v:</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后压测</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []<span class="keyword">struct</span> &#123;</span><br><span class="line"> name <span class="keyword">string</span></span><br><span class="line"> f    <span class="function"><span class="keyword">func</span><span class="params">(...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;&#123;</span><br><span class="line"> &#123;<span class="string">"reflection"</span>, OrInReflect&#125;,</span><br><span class="line"> &#123;<span class="string">"recursion"</span>, OrRecur&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkOr</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">  <span class="keyword">for</span> n := <span class="number">8</span>; n &lt;= <span class="number">1024</span>; n *= <span class="number">2</span> &#123;</span><br><span class="line">   b.Run(fmt.Sprintf(<span class="string">"%s/%d"</span>, f.name, n), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">     b.StopTimer()</span><br><span class="line">     done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">     <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">     streams := <span class="built_in">make</span>([]&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, n)</span><br><span class="line">     <span class="keyword">for</span> i := <span class="keyword">range</span> streams &#123;</span><br><span class="line">      streams[i] = AsStream(done, []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>&#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     b.StartTimer()</span><br><span class="line">     &lt;-f.f(streams...)</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了下结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/NewbMiao/Dig101-Go/concurrency/channel/schedule/or</span><br><span class="line">cpu: Intel(R) Core(TM) i7<span class="number">-8750</span>H CPU @ <span class="number">2.20</span>GHz</span><br><span class="line">BenchmarkOr/reflection/<span class="number">8</span><span class="number">-12</span>                    <span class="number">60044</span>             <span class="number">22924</span> ns/op            <span class="number">2839</span> B/op         <span class="number">28</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">16</span><span class="number">-12</span>                   <span class="number">82941</span>             <span class="number">27764</span> ns/op            <span class="number">4684</span> B/op         <span class="number">41</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">32</span><span class="number">-12</span>                   <span class="number">56890</span>             <span class="number">40326</span> ns/op            <span class="number">8397</span> B/op         <span class="number">66</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">64</span><span class="number">-12</span>                   <span class="number">33350</span>             <span class="number">90301</span> ns/op           <span class="number">16485</span> B/op        <span class="number">116</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">128</span><span class="number">-12</span>                  <span class="number">17476</span>            <span class="number">109545</span> ns/op           <span class="number">34300</span> B/op        <span class="number">230</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">256</span><span class="number">-12</span>                   <span class="number">8155</span>            <span class="number">257080</span> ns/op           <span class="number">68398</span> B/op        <span class="number">443</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">512</span><span class="number">-12</span>                   <span class="number">4018</span>            <span class="number">429550</span> ns/op          <span class="number">134260</span> B/op        <span class="number">842</span> allocs/op</span><br><span class="line">BenchmarkOr/reflection/<span class="number">1024</span><span class="number">-12</span>                  <span class="number">2131</span>            <span class="number">890946</span> ns/op          <span class="number">266877</span> B/op       <span class="number">1648</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">8</span><span class="number">-12</span>                    <span class="number">186949</span>              <span class="number">6770</span> ns/op            <span class="number">1190</span> B/op         <span class="number">12</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">16</span><span class="number">-12</span>                   <span class="number">127618</span>             <span class="number">10651</span> ns/op            <span class="number">2048</span> B/op         <span class="number">21</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">32</span><span class="number">-12</span>                    <span class="number">83200</span>             <span class="number">24578</span> ns/op            <span class="number">3405</span> B/op         <span class="number">35</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">64</span><span class="number">-12</span>                    <span class="number">69890</span>             <span class="number">33589</span> ns/op            <span class="number">5162</span> B/op         <span class="number">53</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">128</span><span class="number">-12</span>                   <span class="number">32719</span>             <span class="number">58391</span> ns/op            <span class="number">8301</span> B/op         <span class="number">86</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">256</span><span class="number">-12</span>                   <span class="number">10000</span>            <span class="number">162016</span> ns/op           <span class="number">13487</span> B/op        <span class="number">140</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">512</span><span class="number">-12</span>                    <span class="number">7225</span>            <span class="number">283879</span> ns/op           <span class="number">24199</span> B/op        <span class="number">252</span> allocs/op</span><br><span class="line">BenchmarkOr/recursion/<span class="number">1024</span><span class="number">-12</span>                   <span class="number">3112</span>            <span class="number">645105</span> ns/op           <span class="number">50744</span> B/op        <span class="number">528</span> allocs/op</span><br></pre></td></tr></table></figure><p>压测结果如图所示<br><img src="http://media.newbmiao.com/dig101/go/orBenchmark.png" alt="orBenchmark"></p><p>可以看出，大量并发<code>chan</code>场景下， 递归效率更好一些。</p>]]></content>
    
    <summary type="html">
    
      2-way-of-or-channel-pattern
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="or-channel-pattern" scheme="http://blog.newbmiao.com/tags/or-channel-pattern/"/>
    
  </entry>
  
  <entry>
    <title>举例来学cond原语</title>
    <link href="http://blog.newbmiao.com/2021/08/09/one-example-to-learn-cond.html"/>
    <id>http://blog.newbmiao.com/2021/08/09/one-example-to-learn-cond.html</id>
    <published>2021-08-09T13:04:19.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了鸟窝的《Go并发编程实战课》，写的挺有意思的，打算后边弄些例子再回顾下并发原语。</p><p>今天来看看<code>cond</code>原语。</p><p><code>cond</code> 是用于等待或通知场景下的并发原语，条件不满足时，阻塞(<code>wait</code>)一组<code>goroutine</code>；条件满足后，唤醒单个（<code>signal</code>）或所有(<code>broadcast</code>)阻塞的<code>goroutine</code>.</p><p>比如10个运动员跑步，都准备好了，裁判才发令的例子：</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化带锁的条件变量</span></span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> ready <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起10个协程，随机等待后模拟运动员就位，并记录就位人数（加锁更新）</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Duration(rand.Int63n(<span class="number">5</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">    ready++</span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"运动员#%d 已准备就绪\n"</span>, i)</span><br><span class="line">    <span class="comment">// 广播唤醒所有的等待者</span></span><br><span class="line">    <span class="comment">// 这里用signal也可以，因为等待者只有一个main goroutine</span></span><br><span class="line">    c.Broadcast()</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件满足：10人都就位</span></span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> ready != <span class="number">10</span> &#123;</span><br><span class="line">  c.Wait()</span><br><span class="line">  log.Println(<span class="string">"裁判员被唤醒一次"</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的运动员是否就绪</span></span><br><span class="line">log.Println(<span class="string">"所有运动员都准备就绪。比赛开始，3，2，1, ......"</span>)</span><br></pre></td></tr></table></figure><p>输出差不多如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 运动员#<span class="number">0</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 运动员#<span class="number">4</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">04</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">5</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">3</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 运动员#<span class="number">9</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">05</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">10</span> 运动员#<span class="number">7</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">10</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">11</span> 运动员#<span class="number">1</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">11</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 运动员#<span class="number">6</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 运动员#<span class="number">2</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">12</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 运动员#<span class="number">8</span> 已准备就绪</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 裁判员被唤醒一次</span><br><span class="line"><span class="number">2021</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">13</span> 所有运动员都准备就绪。比赛开始，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span>, ......</span><br></pre></td></tr></table></figure><p>可以看出<code>cond</code>在更改条件或者检查条件时需要加锁处理，避免并发下读写不一致问题。</p><p>里边<code>wait</code>等待条件满足时比较特殊，需要加锁并在<code>for</code>循环中等待，为什么呢？</p><p>根据源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line"> c.checker.check()</span><br><span class="line"> <span class="comment">// 更新等待groutine的计数： wait</span></span><br><span class="line"> t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line"> <span class="comment">// 释放锁，防止阻塞后别的goroutine拿不到锁</span></span><br><span class="line"> c.L.Unlock()</span><br><span class="line"> <span class="comment">// 切走当前goroutine，等待唤起</span></span><br><span class="line"> runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line"> <span class="comment">// 唤起后持有锁</span></span><br><span class="line"> c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wait</code>时，将当前<code>goroutine</code>加到等待队列（<code>notifyList</code>）前释放了锁，避免锁持有导致别的<code>goroutine</code>死锁；</p><p>唤起后，又持有锁，再持有锁前，可能有别的<code>goroutine</code>持有过锁，比如多次<code>signal</code>或者<code>broadcast</code>,<br>这里没法确定，当前<code>goroutine</code>唤起后条件没有改变，所以需要在<code>for</code>循环中检测条件是否依然满足</p><p>即，官方文档说明的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  c.L.Lock()</span></span><br><span class="line"><span class="comment">//  for !condition() &#123;</span></span><br><span class="line"><span class="comment">//      c.Wait()</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  ... make use of condition ...</span></span><br><span class="line"><span class="comment">//  c.L.Unlock()</span></span><br></pre></td></tr></table></figure><p>如果用<code>channel</code>来实现，也可以做类似的事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unbuffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  ch &lt;- <span class="number">1</span> <span class="comment">// i is ready</span></span><br><span class="line"> &#125;(i) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"all is ready!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// buffered</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(ch) != <span class="number">10</span> &#123;</span><br><span class="line">  time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"all is ready!"</span>)</span><br></pre></td></tr></table></figure><p>但<code>cond</code>的优势在于其同时支持<code>signal</code>和<code>broadcast</code>，<code>channel</code>同时只能实现一种（<code>close</code>算<code>broadcast</code>，但只能用一次，不可重复调用）</p><p>用<code>waitGroup</code>也可以模拟等待条件满足，但是针对的是主<code>goroutine</code>对确定数量<code>goroutine</code>的等待，不像<code>cond</code>只关心条件是否满足，对等待<code>goroutine</code>数目没有要求。</p><p>最后，推荐一个《concurrency-in-go》中提到的代码例子，<a href="https://github.com/kat-co/concurrency-in-go-src/blob/master/an-introduction-to-concurrency/why-is-concurrency-hard/deadlocks-livelocks-and-starvation/livelock/fig-livelock-hallway.go" target="_blank" rel="noopener">fig-livelock-hallway</a></p><p>展示了用<code>cond</code>模拟的狭路相逢谁也过不去的活锁问题。</p><blockquote><p>关于鸟窝的《Go并发编程实战课》，我链接放到<a href="https://time.geekbang.org/column/intro/355?code=pLKPP5Hiu4B61apPRONmbYHopf6Y0TlfGvbXwOEDKKc%3D&utm_term=SPoster" target="_blank" rel="noopener">这里</a>，感兴趣的同学可以去听听，质量很高！</p></blockquote>]]></content>
    
    <summary type="html">
    
      one-example-to-learn-cond
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="cond" scheme="http://blog.newbmiao.com/tags/cond/"/>
    
  </entry>
  
  <entry>
    <title>一个8bytes的内存优化</title>
    <link href="http://blog.newbmiao.com/2021/08/07/one-8-bytes-optimization.html"/>
    <id>http://blog.newbmiao.com/2021/08/07/one-8-bytes-optimization.html</id>
    <published>2021-08-07T07:36:13.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<p>最近看<a href="https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memor" target="_blank" rel="noopener">Dave Cheney的一篇文章</a>，发现一个有趣的代码片段，里面展示了一个8byte的内存优化。</p><p>代码片段是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSortStrings</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> s := []<span class="keyword">string</span>&#123;<span class="string">"heart"</span>, <span class="string">"lungs"</span>, <span class="string">"brain"</span>, <span class="string">"kidneys"</span>, <span class="string">"pancreas"</span>&#125;</span><br><span class="line"> b.ReportAllocs()</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  <span class="keyword">var</span> ss sort.StringSlice = s</span><br><span class="line">  <span class="keyword">var</span> si sort.Interface = ss</span><br><span class="line">  sort.Sort(si)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码很简单，是对一个<code>[]string</code>做排序的内存分配压测</p><p>其中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ss sort.StringSlice = s</span><br><span class="line"><span class="keyword">var</span> si sort.Interface = ss</span><br><span class="line">sort.Sort(si)</span><br></pre></td></tr></table></figure><p>等同于代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Strings(s)</span><br></pre></td></tr></table></figure><p>涉及了对 <code>[]string</code> 转换为实现排序的接口 <code>sort.Interface</code></p><p>了解<code>iface</code>实现的同学知道其<code>data</code>会存储底层数据，一般是一个机器字长的大小（<code>8bytes</code>）</p><p>而<code>slice</code>是<code>24bytes</code>: 底层数组指针（<code>8bytes</code>）+ 长度（<code>8bytes</code>）+ 容量（<code>8bytes</code>）</p><p>直接存不下，就只能<code>indirection</code>, 存指向切片的指针了</p><p>创建前片指针的过程中，切片escape到了heap上，因为不知道原切片<code>ss</code>是否会在<code>si</code>使用过程中消失。</p><p>即，内存分配发生在了这里！</p><p>看下压测结果（<code>go1.16</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test sort_test.<span class="keyword">go</span> -bench . -benchmem </span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i5<span class="number">-5257</span>U CPU @ <span class="number">2.70</span>GHz</span><br><span class="line">BenchmarkInts<span class="number">-4</span>         <span class="number">18846020</span>                <span class="number">90.09</span> ns/op           <span class="number">24</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  <span class="number">2.663</span>s</span><br></pre></td></tr></table></figure><p>结果就是<code>24bytes</code>啊，那所谓的<code>8bytes</code>优化在哪里呢</p><p>是相对于的<code>go1.16</code>前版本的<code>go</code>的, 比如<code>go1.15</code>下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go1<span class="number">.15</span> test sort_test.<span class="keyword">go</span> -bench . -benchmem </span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkSortStrings<span class="number">-4</span>           <span class="number">8617881</span>               <span class="number">172</span> ns/op              <span class="number">32</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  <span class="number">1.649</span>s</span><br></pre></td></tr></table></figure><p>找了下具体提交，其实就是在内存分配里针对三个机器字大小增加了<code>24bytes</code>的<code>sizeClass</code>，避免原来的向上取整到<code>32bytes</code></p><p>感兴趣的同学可以去看着具体实现：<br><a href="https://github.com/golang/go/commit/14c7caae5074fdf0d97a3ad995e20c63e4065cbf" target="_blank" rel="noopener">runtime: add 24 byte allocation size class</a></p><blockquote><p>题外话，好久没有更新了，不好意思了都，后边再捡起来😂</p></blockquote>]]></content>
    
    <summary type="html">
    
      one-8-bytes-optimization
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="memory" scheme="http://blog.newbmiao.com/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>2020年回顾</title>
    <link href="http://blog.newbmiao.com/2021/01/02/summary-of-2020.html"/>
    <id>http://blog.newbmiao.com/2021/01/02/summary-of-2020.html</id>
    <published>2021-01-02T09:23:34.000Z</published>
    <updated>2023-06-18T00:52:29.957Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，2020年就过去了，是时候说一声再见了。</p><p>2020对于我还是有比较多的新体验。</p><a id="more"></a><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>年初父母来西安一起过年，不料被疫情隔离在小区近一个多月，过了一个慵懒的年，也多了许多陪娃的时间。</p><p>因某些原因，公司不需要我在家办公，然后再大家都开始上班后，我又有近两周的赋闲时间。</p><p>一时兴起，就花时间倒腾了一系列<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1345369054160306177#wechat_redirect" target="_blank" rel="noopener">Go源码分析</a>, 让好久不用的公众号也有了更新。</p><p>那段时间，静下心刨根问底的去研究Go语言设计背后的逻辑，让自己多Go有了更深的理解。</p><p>期间也接触了许多Go社区活跃的大佬，有幸一起探讨一些问题，并做了一期分享，都是之前不曾尝试的体验。</p><p>不得不说，技术这东西只要你感兴趣肯花时间，确实是可以一直挖下去。</p><p>隔离结束后，上半年又搞了许多不曾接触的云原生自动化与策略配置。</p><p>从很有压力、略有排斥，到不去逃避，看英文文档自行解决遇到的技术问题。</p><p>这期间也分享一系列<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1345371288113725441#wechat_redirect" target="_blank" rel="noopener">云原生通用规则引擎（OPA）的入门教程</a>，推广了下这项自己很看好的策略描述语言。</p><p>然后下半年又面向需求开发，学习了前端，把以前只是听过的一些技术单词变成了能力。顺带把自己之前做的小程序云开发重新优化成了一期<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNzA2NzEzNw==&action=getalbum&album_id=1554691207543504896#wechat_redirect" target="_blank" rel="noopener">入门教程</a>。</p><p>这搁以前，怕是更不会去尝试的东西。</p><p>一路走来，现在的自己，对于技术已经不再执著于某一语言、前端或后端，面向需求开发，只看技术是否合适罢了。</p><h2 id="奶爸"><a href="#奶爸" class="headerlink" title="奶爸"></a>奶爸</h2><p>去年5月，喜提小可爱一枚。</p><p>如今小可爱都快两岁了，吃饭，走路，学本领都很快，不得不说，我和她妈的基因还是挺强大的，哈哈。（其实都是她妈带得好）</p><p>不过好久没能睡过懒觉了，另外抱娃哄睡这一技能也已经日益娴熟。所以前不久奖励了自己一个45千克的室内引体向上架，让（希望）自己臂力可以跟上娃日益上涨的体重。</p><p>现在耐心也好了许多（虽然有时还是容易急），渐渐开始适应奶爸这一角色。</p><p>偶尔生气时也懊恼为啥要生娃添堵，但过后看着娃的笑脸，觉得这一切都是值得的，一切都是最好的安排。</p><p>只要陪她一起快乐长大就好了。</p><h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><p>最后这一年的收益率跑赢了沪深300，虽对于翻倍的行情不是很完美，但至少跑赢了市场也学到一些去年做不到的东西。</p><p>用曾经看到的一句话作为投资的总结就是：</p><p>做投资一定要路子对，路子对的话，无非是三年成功还是五年成功。但如果路子不对，你永远不行。</p><p>感兴趣可以去看我的<a href="https://mp.weixin.qq.com/s/MJ3aujCNYjRYJ2x1SGBc8w" target="_blank" rel="noopener">2020投资回顾</a>，细节这里就不展开了</p><hr><p>2021，继续干就好了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉，2020年就过去了，是时候说一声再见了。&lt;/p&gt;&lt;p&gt;2020对于我还是有比较多的新体验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="summary" scheme="http://blog.newbmiao.com/categories/summary/"/>
    
    
      <category term="summary" scheme="http://blog.newbmiao.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>Dig101-Go之深入理解mutex</title>
    <link href="http://blog.newbmiao.com/2020/07/01/dig101-golang-understanding-mutex.html"/>
    <id>http://blog.newbmiao.com/2020/07/01/dig101-golang-understanding-mutex.html</id>
    <published>2020-06-30T23:38:33.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><p><code>sync.Mutex</code>是<code>Go</code>实现的互斥锁，提供了基本的同步操作，使用很方便。</p><p>不过，你是否好奇过，<code>Go</code>是如何实现的<code>Mutex</code>，又是为什么要这样实现？</p><p>今天跟随几个问题，我们一起探索下<code>Mutex</code>背后的设计。</p><p>（不用担心，不会有大段的源码分析出现在本文😳）</p><a id="more"></a><h2 id="0x01-为什么需要锁"><a href="#0x01-为什么需要锁" class="headerlink" title="0x01 为什么需要锁"></a>0x01 为什么需要锁</h2><p>锁当然是为了保证同步操作，或者应该这样问：没有锁的时候，为什么会有不同步？</p><p>这里导致不同步的原因主要有两点：</p><h3 id="非原子操作"><a href="#非原子操作" class="headerlink" title="非原子操作"></a>非原子操作</h3><p>如果一个线程的内存操作的<strong>中间状态</strong>（比如只完成一半），可以被<strong>另一个线程获取到</strong>，那么其操作就是非原子操作。</p><p>或者说其操作不是<strong>不可再分</strong>的。</p><p>比如自增操作<code>i++</code>, <code>i</code>的读取、修改、写入（<code>RMW</code>），其底层<strong>cpu和内存实际交互了两次</strong>，自然没法保证操作过程的原子性。</p><p><img src="http://media.newbmiao.com/dig101/go/self-incr.png" alt="自增操作"></p><p>那直接读取操作是否就能保证原子性呢？</p><p>也不一定，比如一般操作系统操作内存的最小粒度是一个机器字<code>machine word</code>(32位系统是<code>4B</code>,64位系统是<code>8B</code>)</p><p>内存对齐的情况下，在32位系统上读取一个<code>int64</code>(<code>8B</code>)就不可能是原子的，更别说如果内存是不对齐的了。</p><h3 id="内存重排"><a href="#内存重排" class="headerlink" title="内存重排"></a>内存重排</h3><p>我们写的代码顺序与实际执行的顺序可能并不一致。这是因为有内存重排的存在。他会发生在两个地方：</p><ul><li>语言编译时</li></ul><p>语言为了一些优化考虑，可能会在编译期间重排代码顺序。</p><ul><li>系统执行时</li></ul><p>这个完全取决于系统底层指令的实现，主要是为了更好利用那些原本要浪费掉的<strong>指令周期</strong>，提升程序的执行速度。</p><p>比如cpu和主存（<code>main memory</code>）访问延时是很高的。多核时代，每个cpu核为了加速访问，就增加了各自与主存交互的缓存(<code>cache</code>)。</p><p>如果缓存中有就无需再和主存交互了。如下图所示：</p><p><img src="http://media.newbmiao.com/dig101/go/cpu-cache-main-memory.png" alt="cpu的缓存与主存"></p><p>但有多份缓存，就需要有缓存一致（<code>cache coherency</code>）协议保证他们的结果一致。(具体可以了解<a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">MESI协议</a>)。</p><p>这种情况下，如果多个cpu核同时修改或读取同一份数据，且这份数据在各自的缓存中，为避免<strong>缓存间不一致</strong>，就不可避免有的cpu核要等待其他cpu核先操作数据。</p><p>所以在这些cpu核<strong>等待期间</strong>，他可以先执行其他内存指令。</p><blockquote><p>详细可以参考 <a href="https://www.internalpointers.com/post/understanding-memory-ordering" target="_blank" rel="noopener">Understanding memory reordering</a> 这篇文章。</p></blockquote><h2 id="0x02-mutex如何实现原子操作"><a href="#0x02-mutex如何实现原子操作" class="headerlink" title="0x02 mutex如何实现原子操作"></a>0x02 mutex如何实现原子操作</h2><p>利用<code>atomic</code>提供的<code>AddInt32</code>和<code>CompareAndSwapInt32</code>函数，其底层使用了系统架构提供的<code>LOCK</code>前缀指令。</p><p>该指令会设置处理器的<code>LOCK</code>信号。</p><p>这个信号会使总线锁定，阻止其他处理器接管总线访问内存，直到使用<code>LOCK</code>前缀指令执行结束，这会使这条指令的执行变为原子操作。</p><p>在多处理器环境下，设置<code>LOCK</code>信号能保证某个处理器对共享内存的独占使用。</p><p>具体指令参见：<code>runtime/internal/atomic/asm_amd64.s</code></p><p>如<code>Cas</code>的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bool Cas(int32 *val, int32 old, int32 new)</span></span><br><span class="line"><span class="comment">// Atomically:</span></span><br><span class="line"><span class="comment">//if(*val == old)&#123;</span></span><br><span class="line"><span class="comment">//*val = new;</span></span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="comment">//&#125; else</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$<span class="number">0</span><span class="number">-17</span></span><br><span class="line">MOVQptr+<span class="number">0</span>(FP), BX</span><br><span class="line">MOVLold+<span class="number">8</span>(FP), AX</span><br><span class="line">MOVL<span class="built_in">new</span>+<span class="number">12</span>(FP), CX</span><br><span class="line">LOCK</span><br><span class="line">CMPXCHGLCX, <span class="number">0</span>(BX)</span><br><span class="line">SETEQret+<span class="number">16</span>(FP)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><h2 id="0x03-mutex如何避免内存重排"><a href="#0x03-mutex如何避免内存重排" class="headerlink" title="0x03 mutex如何避免内存重排"></a>0x03 mutex如何避免内存重排</h2><p>上边提到的<code>LOCK</code>指令及<code>XCHG</code>等指令，会引入内存屏障（<code>memory barrier</code>）</p><p>内存屏障是强制处理器按照可预知的方式访问内存的CPU指令。</p><p>内存屏障的工作方式类似路障：内存屏障之前的指令保证先于内存屏障之后的指令执行。</p><blockquote><p>更多关于内存屏障可以看看这篇文章中对 <a href="https://my.oschina.net/chuqq/blog/3022854" target="_blank" rel="noopener">POSIX多线程程序设计-3.4节</a> 引用。</p></blockquote><h2 id="0x04-Go对mutex的优化点"><a href="#0x04-Go对mutex的优化点" class="headerlink" title="0x04 Go对mutex的优化点"></a>0x04 Go对mutex的优化点</h2><p>有了底层架构指令支持，如果<code>Go</code>直接基于<code>atomic.CAS</code>+cpu时钟周期阻塞，就可实现常见的自旋锁（<code>spinLock</code>）：</p><p>未获取锁前阻塞线程，每次等待一些cpu时钟周期，直到锁可用就好了。</p><p>但Go自己还是做了一些优化，一般情况下会优于常见的多线程互斥锁。</p><p>主要优化点是：</p><h3 id="不一直让cpu空转等待锁"><a href="#不一直让cpu空转等待锁" class="headerlink" title="不一直让cpu空转等待锁"></a>不一直让cpu空转等待锁</h3><p>一直自旋最大的问题就是浪费cpu时钟周期，会占用一些cpu，除非锁能很快获取到的。</p><p>所以Go在<strong>多核</strong>且<strong>不会影响其他<code>Goroutine</code>调度</strong>时，会最多自旋4次，且每次空转30个cpu时钟周期。以期能短期内获取锁。</p><p>详见<code>runtime_canSpin</code>和<code>runtime_doSpin</code> (源码见<code>runtime/proc.go</code>)</p><h3 id="用信号量实现睡眠的协程唤起"><a href="#用信号量实现睡眠的协程唤起" class="headerlink" title="用信号量实现睡眠的协程唤起"></a>用信号量实现睡眠的协程唤起</h3><p>上边说了不会一直空转cpu，那4次空转之后锁还没好，怎么办？</p><p>在多线程场景里一般就会基于信号量（<code>semaphore</code>）实现 <a href="https://zh.wikipedia.org/wiki/Futex" target="_blank" rel="noopener"><code>futex</code></a>，来让线程睡眠直至条件满足后唤醒。</p><p>Go也用信号量实现了类似<code>futex</code>的<code>wake</code>和<code>sleep</code>. 只不过他们管理的Go自己调度的<strong>协程</strong>而非线程。</p><p>这样好处是，让协程等待的代价要比线程更低，而且<strong>协程上下文切换</strong>也更快一些。</p><h3 id="避免过多无效的协程唤起"><a href="#避免过多无效的协程唤起" class="headerlink" title="避免过多无效的协程唤起"></a>避免过多无效的协程唤起</h3><p>如果一个锁有多个协程在抢，且已经有被挂起的协程在等待唤起。</p><p>这种情况下，当锁释放，等待被唤起的协程被唤醒时，他会和其他<strong>已经在cpu上运行的协程</strong>一起去抢锁，自然很容易失败而导致继续挂起。</p><p>为缓解这种极端情况的延迟。<code>Go</code>增加饥饿模式（<code>starvation mode</code>）：</p><p>正常情况按先进先出唤醒抢锁；如果有协程获取锁失败被挂起超过<strong>1ms</strong>，就将其放到队首，并转为饥饿模式。</p><p>这种模式下，下次唤醒就直接把锁<strong>交给</strong>（<code>handoff</code>）队首等待已久的协程。</p><p>了解这些，再去看<code>mutex</code>的源码可能会更好理解一些。</p><p>最后推荐一个talk，是英文版的，里边有很详细的关于<code>mutex</code>的讨论。</p><iframe src="//player.bilibili.com/player.html?aid=201155404&bvid=BV1kz411e7dL&cid=206127447&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      dig101-golang-understanding-mutex
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="mutex" scheme="http://blog.newbmiao.com/tags/mutex/"/>
    
      <category term="memory-reordering" scheme="http://blog.newbmiao.com/tags/memory-reordering/"/>
    
      <category term="atomic" scheme="http://blog.newbmiao.com/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>Go之如何操作结构体的非导出字段</title>
    <link href="http://blog.newbmiao.com/2020/06/13/dig101-golang-reflect-handle-unexport-field.html"/>
    <id>http://blog.newbmiao.com/2020/06/13/dig101-golang-reflect-handle-unexport-field.html</id>
    <published>2020-06-13T14:42:03.000Z</published>
    <updated>2023-06-18T00:52:29.950Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><p>我们都知道<code>Go</code>的<code>struct</code>里，小写字段是非导出的，即不可从包外部访问。</p><p>但非导出字段在外部也并不是没有办法访问，也不是不可以修改。</p><p>今天看下<code>reflect</code>包如何在包外操作非导出字段。</p><a id="more"></a><h2 id="取地址访问"><a href="#取地址访问" class="headerlink" title="取地址访问"></a>取地址访问</h2><p>先来看第一个函数<code>NewAt</code>：</p><p>对于结构体，通过其底层地址（指针p）和类型，返回指向该结构体的一个<strong>指针</strong>，</p><p>该值是可寻址的（<code>addressable</code>），即可<strong>访问</strong>该结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflect/value.go</span></span><br><span class="line"><span class="comment">// NewAt returns a Value representing a pointer to a value of the</span></span><br><span class="line"><span class="comment">// specified type, using p as that pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAt</span><span class="params">(typ Type, p unsafe.Pointer)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">  fl := flag(Ptr)</span><br><span class="line">  t := typ.(*rtype)</span><br><span class="line">  <span class="keyword">return</span> Value&#123;t.ptrTo(), p, fl&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个这个方法，就可以通过<code>struct</code>的反射获取非导出字段</p><p>比如访问，对于如下含有非导出字段的结构体<code>Example</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testData</span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line">  a <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便可以通过对结构体<code>eg</code>取地址的方式，获取其非导出字段<code>a</code>的内容</p><p>这里<code>Elem</code>是获取其底层数据对象的方式，</p><p>如果知道类型，也可显示指定调用，如<code>reflect.value.Interface,reflect.value.Int...</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eg testData.Example</span><br><span class="line">a:=GetStructPtrUnExportedField(&amp;eg, <span class="string">"a"</span>).String()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructPtrUnExportedField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取非导出字段反射对象</span></span><br><span class="line">  v := reflect.ValueOf(source).Elem().FieldByName(fieldName)</span><br><span class="line">  <span class="comment">// 构建指向该字段的可寻址（addressable）反射对象</span></span><br><span class="line">  <span class="keyword">return</span> reflect.NewAt(v.Type(), unsafe.Pointer(v.UnsafeAddr())).Elem()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意必须要对<code>eg</code><strong>取地址</strong>, 否则会<code>panic</code>:</p><p><code>panic: reflect: call of reflect.Value.Elem on struct Value</code></p><p>因为<code>reflect.Value.Elem</code>需要<code>reflect.Value</code>类型必须是<code>interface</code>或者<code>ptr</code>,</p><p>这样获取其<strong>底层的值</strong>才有意义：要么返回<code>interface</code>底层的值或者<code>ptr</code>指向的值</p><p>其注释如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Elem returns the value that the interface v contains</span></span><br><span class="line"><span class="comment">// or that the pointer v points to.</span></span><br><span class="line"><span class="comment">// It panics if v's Kind is not Interface or Ptr.</span></span><br><span class="line"><span class="comment">// It returns the zero Value if v is nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span> &#123;</span><br></pre></td></tr></table></figure><h2 id="取地址修改"><a href="#取地址修改" class="headerlink" title="取地址修改"></a>取地址修改</h2><p>那可以访问了，如何修改呢？</p><p>利用<code>reflect.value.Set</code>就可以：</p><p>上边<code>Elem</code>获取到的反射值是可修改的（<code>assignable</code>）,突破了非导出字段不能从外部修改的限制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eg testData.Example</span><br><span class="line">err := SetStructPtrUnExportedStrField(&amp;eg, <span class="string">"a"</span>, <span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetStructPtrUnExportedStrField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>, fieldVal <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  v := GetStructPtrUnExportedField(source, fieldName)</span><br><span class="line">  rv := reflect.ValueOf(fieldVal)</span><br><span class="line">  <span class="keyword">if</span> v.Kind() != rv.Kind() &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid kind: expected kind %v, got kind: %v"</span>, v.Kind(), rv.Kind())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改非导出字段值</span></span><br><span class="line">  v.Set(rv)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是以反射值来修改非导出字段值，内部类型须一致。修改后内容会直接反应到<code>eg</code>上</p><p>类似的还有指定类型的设置方法如<code>SetString,SetBool...</code></p><h2 id="非取地址访问"><a href="#非取地址访问" class="headerlink" title="非取地址访问"></a>非取地址访问</h2><p>当然不取地址也是可以访问非导出字段的。</p><p>这里用到的第二个函数是<code>New</code>:</p><p>基于指定类型创建一个可以表示该类型的<strong>指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns a Value representing a pointer to a new zero value</span></span><br><span class="line"><span class="comment">// for the specified type. That is, the returned Value's Type is PtrTo(typ).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(typ Type)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"reflect: New(nil)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  t := typ.(*rtype)</span><br><span class="line">  ptr := unsafe_New(t)</span><br><span class="line">  fl := flag(Ptr)</span><br><span class="line">  <span class="keyword">return</span> Value&#123;t.ptrTo(), ptr, fl&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体访问代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructUnExportedField</span><span class="params">(source <span class="keyword">interface</span>&#123;&#125;, fieldName <span class="keyword">string</span>)</span> <span class="params">(accessableField, addressableSourceCopy reflect.Value)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(source)</span><br><span class="line">  <span class="comment">// since source is not a ptr, get an addressable copy of source to modify it later</span></span><br><span class="line">    addressableSourceCopy = reflect.New(v.Type()).Elem()</span><br><span class="line">    <span class="comment">// make a copy of source</span></span><br><span class="line">  addressableSourceCopy.Set(v)</span><br><span class="line">  accessableField = addressableSourceCopy.FieldByName(fieldName)</span><br><span class="line">  accessableField = reflect.NewAt(accessableField.Type(), unsafe.Pointer(accessableField.UnsafeAddr())).Elem()</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样其实是内部构造了一个对该结构其取地址的指针，以满足后续调用<code>Elem</code>时可寻址!</p><h2 id="非取地址修改"><a href="#非取地址修改" class="headerlink" title="非取地址修改"></a>非取地址修改</h2><p>非取地址的方式访问没有问题，要还想修改就不会反应到原始结构体上了</p><p>毕竟是内部重新拷贝了一个结构体进行的操作。</p><p>具体操作类似取地址修改的方式，这里不赘述了。</p><p>实际使用中，还是通过<code>NewAt</code>获取可读写的非导出字段更方便一些。</p><blockquote><p>本文代码见 <a href="https://github.com/NewbMiao/Dig101-Go/blob/master/reflect" target="_blank" rel="noopener">NewbMiao/Dig101-Go</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      dig101-golang-reflect-handle-unexport-field
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="reflect" scheme="http://blog.newbmiao.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>Dig101-Go之如何在函数内修改指针指向</title>
    <link href="http://blog.newbmiao.com/2020/05/22/how-to-modify-a-pointer-of-go-inside.html"/>
    <id>http://blog.newbmiao.com/2020/05/22/how-to-modify-a-pointer-of-go-inside.html</id>
    <published>2020-05-22T13:51:32.000Z</published>
    <updated>2023-06-18T00:52:29.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><p>今天来看一个小问题：<strong>如何在函数内部修改一个指针（参数或接收者）指向，使其值的改变能反映在函数外部</strong>？</p><p>直接上代码，这样可以么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArgType <span class="keyword">struct</span> &#123;</span><br><span class="line">  A <span class="keyword">string</span></span><br><span class="line">  b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg1</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  arg = &amp;ArgType&#123;<span class="string">"arg1"</span>, <span class="number">1</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg1:"</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>答案是【不可以】</p><p>等会分析，再看一个，这个呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg2</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  *arg = ArgType&#123;<span class="string">"arg2"</span>, <span class="number">2</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg2:"</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是【可以】</p><p>仔细看下，你应该就明白了。</p><p>第一个替换的是<strong>指针变量本身</strong>,</p><p>也就是在函数<code>modifyPointerArg1</code>的作用域内，其修改是有效</p><p>函数返回后，并不影响指针<code>arg</code>所指向的值（别忘了，Go参数传递是值传递嘛！）</p><p>至于<code>modifyPointerArg2</code>则是对指针解引用，修改了<strong>其指向的值</strong></p><hr><p>这样的方式其实还有很多，比如这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg3</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  val := reflect.ValueOf(arg)</span><br><span class="line">  val.Elem().FieldByName(<span class="string">"A"</span>).SetString(<span class="string">"arg3"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"inside modifyPointerArg3:"</span>, arg)</span><br><span class="line">  <span class="comment">// val.Elem().FieldByName("b").SetInt(3)</span></span><br><span class="line">  <span class="comment">// panic: reflect: reflect.flag.mustBeAssignable using value obtained using unexported field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际是利用反射的<code>Elem()</code>获取<code>val</code>的值</p><ul><li>如果其为空接口（<code>empty interface</code>），则获取其内部值（空接口值字段的类型是指针哦）</li><li>如果其为指针（<code>pointer</code>），则获取其指向的值</li></ul><p>获取到的结构如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    typ *rtype</span><br><span class="line">    <span class="comment">// 值指针</span></span><br><span class="line">    ptr unsafe.Pointer</span><br><span class="line">    <span class="comment">// 标志位</span></span><br><span class="line">  flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对应类型修改时, 实际就是对指针解引用修改其指向的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetString</span><span class="params">(x <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  v.mustBeAssignable()</span><br><span class="line">  v.mustBe(String)</span><br><span class="line">  <span class="comment">// 这里</span></span><br><span class="line">  *(*<span class="keyword">string</span>)(v.ptr) = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips： 这里注意一点，不导出的字段（结构体内小写的字段）不能用此类方法修改，会panic！</p></blockquote><p>再如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointerArg4</span><span class="params">(arg *ArgType)</span></span> &#123;</span><br><span class="line">  jsonStr := <span class="string">`&#123;"A":"arg4","b":4&#125;`</span></span><br><span class="line">  json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部实际也是用了反射修改指针指向的值</p><p>另外，把上边几个测试函数由<strong>指针参数</strong>换为<strong>指针接受者</strong>，也是一样的</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arg *ArgType)</span> <span class="title">modifyPointerReceiver4</span><span class="params">()</span></span> &#123;</span><br><span class="line">  jsonStr := <span class="string">`&#123;"A":"arg4","b":4&#125;`</span></span><br><span class="line">  json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣可以去自行尝试下其他几个函数。</p><p>说了这么多，这样修改有啥用么？</p><p>常见的一个场景便是：</p><p><strong>测试时，可以通过对接口实现对应的mock函数，改变参数或接收者，以达到排除依赖，进行单元测试的目的。</strong></p>]]></content>
    
    <summary type="html">
    
      how-to-modify-a-pointer-inside-function
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="reflect" scheme="http://blog.newbmiao.com/tags/reflect/"/>
    
      <category term="dereference" scheme="http://blog.newbmiao.com/tags/dereference/"/>
    
  </entry>
  
  <entry>
    <title>记一次奇妙的go-protobuf包升级之旅</title>
    <link href="http://blog.newbmiao.com/2020/04/17/the-drama-of-updating-protobuf-go.html"/>
    <id>http://blog.newbmiao.com/2020/04/17/the-drama-of-updating-protobuf-go.html</id>
    <published>2020-04-17T14:58:00.000Z</published>
    <updated>2023-06-18T00:52:29.952Z</updated>
    
    <content type="html"><![CDATA[<p>今天聊一个最近升级go的<code>protobuf</code>的故事。过程很是奇妙（曲折）😳</p><p>前两天，一个项目的<code>dependabot</code>提示包<code>github.com/golang/protobuf</code> 可以从<code>V1.3.5</code>升级到<code>V1.4.0</code></p><a id="more"></a><h2 id="Round-One"><a href="#Round-One" class="headerlink" title="Round One"></a>Round One</h2><p>本以为直接升级就行，但是没过CI，是发现旧版（<code>V1.3.5</code>）测试代码用了pb生成代码的<code>XXX_Size()</code>方法计算消息大小</p><p>在新版（<code>v1.4.0</code>）里<code>panic</code>了</p><p>我们来看下他们有啥不同：</p><p>为简化，我们proto文件用官方的<a href="https://github.com/grpc/grpc-go/blob/master/examples/helloworld/helloworld/helloworld.proto" target="_blank" rel="noopener">helloworld.proto</a></p><p>通过以下方式生成<code>V1.3.5</code>版本的pb文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/grpc/grpc-go/master/examples/helloworld/helloworld/helloworld.proto</span><br><span class="line">brew install protobuf</span><br><span class="line">GO111MODULE=on go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.5</span><br><span class="line">protoc  --go_out=plugins=grpc:. helloworld.proto</span><br></pre></td></tr></table></figure><p>再替换<code>github.com/golang/protobuf/protoc-gen-go@v1.4.0</code>，生成新版pb文件</p><p>查找<code>XXX_Size</code>函数</p><p>旧版中没问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helloword.pb.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *HelloRequest)</span> <span class="title">XXX_Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> xxx_messageInfo_HelloRequest.Size(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xxx_messageInfo_HelloRequest proto.InternalMessageInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// github.com/golang/protobuf@v1.3.5/proto/table_marshal.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *InternalMessageInfo)</span> <span class="title">Size</span><span class="params">(msg Message)</span> <span class="title">int</span></span> &#123;</span><br></pre></td></tr></table></figure><p>新版pb文件中没有了<code>InternalMessageInfo</code>类型</p><p>但源码中能找到，是被废弃了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// github.com/golang/protobuf@v1.4.0/proto/deprecated.go</span></span><br><span class="line"><span class="comment">// Deprecated: Do not use.</span></span><br><span class="line"><span class="keyword">type</span> InternalMessageInfo <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*InternalMessageInfo)</span> <span class="title">Size</span><span class="params">(Message)</span> <span class="title">int</span></span> &#123; <span class="built_in">panic</span>(<span class="string">"not implemented"</span>) &#125;</span><br><span class="line"><span class="comment">// 同样废弃的还有： DiscardUnknown, Marshal, Merge, Unmarshal</span></span><br></pre></td></tr></table></figure><p>那新版代码中怎么获取大小？</p><p>查看源码中例子，<code>proto.Size(m Message) int</code>可以实现</p><p><code>InternalMessageInfo</code>也变成了接口<code>type Message = protoiface.MessageV1</code></p><p>这个<code>InternalMessageInfo</code>的废弃在版本升级中也提到了，详见<a href="https://github.com/protocolbuffers/protobuf-go/releases/tag/v1.20.0#v1.20-generated-code" target="_blank" rel="noopener">generated-code</a></p><p>好，替换方法，第一回合结束</p><p><img src="http://media.newbmiao.com/emoji/finish.gif" alt="准备收工"></p><h2 id="Round-Two"><a href="#Round-Two" class="headerlink" title="Round Two"></a>Round Two</h2><p>等等，再仔细看了下<code>github.com/golang/protobuf</code>文档，里边提到<code>v1.4.0</code>版本后, 后边代码将交由<code>google.golang.org/protobuf</code> Repo维护，看来谷歌要把pb的包都收到自己组织下</p><p>那我顺手直接把<code>grpc</code>生成工具也替换过去呗！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on <span class="keyword">go</span> get -u google.golang.org/protobuf/cmd/protoc-gen-<span class="keyword">go</span>@v1<span class="number">.21</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>再次生成代码</p><blockquote><p>新工具自动提示要求proto文件中增加：</p><p><code>option go_package = &quot;.;helloworld&quot;;</code></p></blockquote><p>居然失败了。。。提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--go_out: protoc-gen-go: plugins are not supported; use 'protoc --go-grpc_out=...' to generate gRPC</span><br></pre></td></tr></table></figure><p>难道是新增了flag，尝试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc  --go-grpc_out=. helloworld.proto</span><br></pre></td></tr></table></figure><p>What? 失败+1。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc-gen-go-grpc: program not found or is not executable</span><br><span class="line">Please specify a program using absolute path or make sure the program is available in your PATH system variable</span><br><span class="line">--go-grpc_out: protoc-gen-go-grpc: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure><p><img src="http://media.newbmiao.com/emoji/block.jpg" alt="心塞x1"></p><p><code>protoc-gen-go-grpc</code>是新工具？</p><p>搜了下，确实有这个工具，说新版本会用他来生成<code>grpc</code>，主要是为了更好支持<code>protobuf reflection</code></p><blockquote><p>这里说一下:</p><p>proto文件中的<code>service</code>是需要<code>grpc</code>的<code>plugin</code>才能生成对应pb代码<br>所以旧版工具有参数<code>--go_out=plugins=grpc:</code></p></blockquote><p>尝试安装下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on go get google.golang.org/protobuf/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><p>失败+2。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get google.golang.org/protobuf/cmd/protoc-gen-go-grpc: module google.golang.org/protobuf@upgrade found (v1.21.0), but does not contain package google.golang.org/protobuf/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><p><img src="http://media.newbmiao.com/emoji/block.jpg" alt="心塞x2"></p><p>goDoc里有<a href="https://pkg.go.dev/google.golang.org/protobuf/cmd/protoc-gen-go-grpc?tab=overview" target="_blank" rel="noopener">protoc-gen-go-grpc</a>，<a href="https://github.com/protocolbuffers/protobuf-go" target="_blank" rel="noopener">Repo</a>里没有，这是什么操作？</p><p>猜测这问题应该有人遇到吧，果然搜到了issue：<a href="https://github.com/golang/protobuf/issues/1070#issuecomment-607465055" target="_blank" rel="noopener">plugins are not supported:grpc</a></p><p>原来是<code>google.golang.org/protobuf</code>先发布了,里边也包含了新版的<code>protoc-gen-go</code>，</p><p>只是其不再支持<code>grpc</code>生成，需要另一个工具<code>protoc-gen-go-grpc</code></p><p>然而它还没有发布，还在<a href="https://github.com/grpc/grpc-go/pull/3453" target="_blank" rel="noopener">Review</a>中。。。（当然目前也不会是稳定版本）</p><p><img src="http://media.newbmiao.com/emoji/unbelieve.jpg" alt="令人窒息的操作"></p><p>不过，官方也说了，依然可以用旧包<code>github.com/golang/protobuf</code>的<code>protoc-gen-go-grpc</code>工具生成<code>grpc</code>代码</p><blockquote><p>因为旧包<code>protoc-gen-go-grpc</code>里依然可以用新包<code>protoc-gen-go-grpc</code>里生成grpc代码的<code>gengogrpc</code>, 见<a href="https://github.com/grpc/grpc-go/pull/3453#issuecomment-600879894" target="_blank" rel="noopener">comment</a></p></blockquote><h2 id="Round-Three"><a href="#Round-Three" class="headerlink" title="Round Three"></a>Round Three</h2><p>好吧，那就只升级代码中调用的protobuf为<code>google.golang.org/protobuf@v1.21.0</code>，代码生成工具还用旧版里<code>github.com/golang/protobuf/protoc-gen-go@v1.4.0</code>吧</p><p>再次生成pb文件, 终于没有问题了, peace finally</p><p><img src="http://media.newbmiao.com/emoji/peace.jpg" alt="peace"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proto <span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">grpc <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">codes <span class="string">"google.golang.org/grpc/codes"</span></span><br><span class="line">status <span class="string">"google.golang.org/grpc/status"</span></span><br><span class="line">protoreflect <span class="string">"google.golang.org/protobuf/reflect/protoreflect"</span></span><br><span class="line">protoimpl <span class="string">"google.golang.org/protobuf/runtime/protoimpl"</span></span><br></pre></td></tr></table></figure><p>只是看着生成代码里的依然需要<code>import</code>的旧包<code>github.com/golang/protobuf</code>，总感觉哪里怪怪的</p><p>升级完了，却依赖了两种<code>protobuf</code>包。。。</p><p>最后，劝大家不着急就再等等再升级吧</p><p>（另外没事干升级到新包干什么！）</p><p>当然这次protobuf的breaking change还是很有意义的，不仅让将protobuf反射作为pb的一级功能，还提供了很多处理工具，详细看下: <a href="https://github.com/protocolbuffers/protobuf-go/releases/tag/v1.21.0" target="_blank" rel="noopener">v1.21.0-release</a></p>]]></content>
    
    <summary type="html">
    
      记一次奇妙的go-protobuf包升级之旅
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="protobuf" scheme="http://blog.newbmiao.com/tags/protobuf/"/>
    
      <category term="protoc-gen-go" scheme="http://blog.newbmiao.com/tags/protoc-gen-go/"/>
    
      <category term="protoc-gen-go-grpc" scheme="http://blog.newbmiao.com/tags/protoc-gen-go-grpc/"/>
    
  </entry>
  
  <entry>
    <title>OPA进阶-分布式利器Bundle</title>
    <link href="http://blog.newbmiao.com/2020/04/16/opa-bundle.html"/>
    <id>http://blog.newbmiao.com/2020/04/16/opa-bundle.html</id>
    <published>2020-04-16T11:57:40.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<p><code>Bundle</code>是<code>OPA</code>管理<code>policy</code>和<code>data</code>的一种方式。</p><p><code>OPA</code>实现的轻量级策略引擎，一开始就是为了云原生环境的<code>service</code>提供解耦的策略服务，分布式是必然要考虑的问题。</p><p>在<code>Bundle api</code>的设计中，其实就全面考虑并体现了在分布式应用中如何更好的解耦策略引擎的管理。</p><p>比如：</p><ul><li>如何做集中配置管理</li><li>如何动态更新策略</li><li>如何监控策略引擎节点的状态以及决策日志收集</li></ul><p>有了这些功能，再加上其高效的策略描述语言<code>Rego</code>，<code>OPA</code>才真正称得上是<strong>云原生时代的通用策略引擎</strong>。</p><p>本文将带大家简单梳理一遍<code>Bundle</code>的组织方式、管理api、及监控方式。</p><p>考虑到一次性过完不易消化，文末会提供一个直接可实操的<code>docker-compose</code>版本的<code>demo</code>，将全面覆盖本文细节</p><p>建议大家看完本文，本机运行去体验一下，会有更直观的理解。</p><a id="more"></a><h2 id="Bundle-文件组织方式"><a href="#Bundle-文件组织方式" class="headerlink" title="Bundle 文件组织方式"></a>Bundle 文件组织方式</h2><p>下面我们先来看下<code>Bundle</code>的文件组织方式</p><p>在<code>Bundle</code>下的<code>data</code>,只能被识别<code>data.json</code>和<code>data.yaml</code>的文件, 而其上边的目录会作为其数据前缀</p><p>如下边<code>roles/data.json</code> (<code>bundle/example</code>作为一个<code>bundle</code>)，会将<code>data.json</code>的数据挂在<code>data.roles</code>节点下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd bundle/example</span><br><span class="line">tree -a</span><br><span class="line">.</span><br><span class="line">├── .manifest</span><br><span class="line">├── bindings</span><br><span class="line">│   └── data.json</span><br><span class="line">├── main.rego</span><br><span class="line">├── rbac.rego</span><br><span class="line">└── roles</span><br><span class="line">    └── data.json</span><br></pre></td></tr></table></figure><p>其中<code>.manifest</code>文件是<code>Bundle</code>的一个可选的元数据（<code>metadata</code>）配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat .manifest</span><br><span class="line">&#123;</span><br><span class="line">  "revision" : "9f160bcd446bf50b1b17b570c322198a68d8e106",</span><br><span class="line">  "roots": ["roles", "bindings","rbac","system"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是声明<code>Bundle</code>的版本<code>revision</code>及其下的路径前缀（<code>roots: path prefix</code>）</p><p><code>roots</code>不仅规定了<code>Bundle</code>应该有的路径前缀；在用<code>Bundle api</code>（后边会提到）更新文件时，也会按其规定的路径前缀来更新文件</p><p>然后<code>bundle</code>也支持<code>tarball</code>格式加载到<code>server</code></p><p>例如<code>opa run -b</code>的方式指定<code>Bundle</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd bundle/example</span><br><span class="line">tar -czf bundle.tar.gz .</span><br><span class="line">opa run -b bundle.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 关于如何在交互式命令行里传递<code>input</code>。<br>之前非bundle使用<br><code>opa run quick-start repl.input:quick-start/input.json</code><br>到bundle格式时，就需要构建 <strong><code>repl/input/data.json</code></strong> 文件格式作为输入</p></blockquote><p>具体可以用时参考文档<a href="https://www.openpolicyagent.org/docs/latest/management/#bundle-file-format" target="_blank" rel="noopener">bundle-file-format</a></p><h2 id="opa-server-api"><a href="#opa-server-api" class="headerlink" title="opa server api"></a>opa server api</h2><p>在了解<code>Bundle</code>支持的管理api前，我们先看下<a href="https://www.openpolicyagent.org/docs/latest/rest-api/" target="_blank" rel="noopener">opa server api</a></p><p>主要api如下：</p><table><thead><tr><th>type</th><th>用途</th></tr></thead><tbody><tr><td>Data api</td><td>查询文档（能被输出的规则、虚拟文档等）</td></tr><tr><td>Policy api</td><td>查询策略</td></tr><tr><td>Query api</td><td>执行命令</td></tr><tr><td>Compile api</td><td>执行部分查询计算（<code>partial evaluate query</code>）</td></tr><tr><td>Health api</td><td>健康检查</td></tr><tr><td>Metric api</td><td>指标统计（<code>prometheus</code>格式)</td></tr></tbody></table><p>下面我们以文档查询（<code>Data</code>）api为例尝试下：</p><p>我们先用之前<code>quick-start</code>的代码起一个<code>opa sever</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opa run --server quick-start</span><br></pre></td></tr></table></figure><p>(注意：<code>opa server api</code>的路径前缀为<code>/v1/</code>, 对应的，查询api路径前缀为<code>/v1/data/</code>,)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构造input输出请求</span></span><br><span class="line">cat &lt;&lt;EOF &gt; v1-data-input.json</span><br><span class="line">&#123;</span><br><span class="line">    "input": $(cat quick-start/input.json)</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询 example_rbac</span></span><br><span class="line">curl -s  http://0.0.0.0:8181/v1/data/example_rbac?pretty=true -d @v1-data-input.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "result": &#123;</span><br><span class="line">    "allow": true,</span><br><span class="line">    "role_has_permission": [</span><br><span class="line">      "widget-reader"</span><br><span class="line">    ],</span><br><span class="line">    "user_has_role": [</span><br><span class="line">      "widget-reader"</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips：不指定路径时，默认路径为<code>data.system.main</code>，这时输入不需要包裹在<code>input</code> key内。<br>也可以使用<code>--set</code> 和 <code>--set-file</code> 可以覆盖配置文件中的配置<br><code>opa run --server --set=default_decision=example_rbac/allow/ quick-start</code><br><code>curl -s http://0.0.0.0:8181/ -d @quick-start/input.json</code></p></blockquote><p>而且Data查询也支持组合参数如<code>explain</code>,<code>metrics</code>,<code>provenance</code>等，详细查看文档，这里就不展开了。</p><h2 id="Bundle-管理api"><a href="#Bundle-管理api" class="headerlink" title="Bundle 管理api"></a>Bundle 管理api</h2><p><code>Bundle</code>为了在分布式系统中更好的展现OPA的威力，提供了四种Api：</p><ul><li>Bundles<br>用于策略分发，可以定时轮训更新<code>Bundle</code>包</li><li>Decision Logs<br>定期上传日志包，支持按大小分片，开启后会有日志id，决策日志可追溯</li><li>Status<br>定期上传服务状态，包含<code>metrics</code>等信息</li><li>Discovery<br>服务发现，可以用于集中管理<code>OPA</code>的<code>Bundle</code>配置，各个节点下载定期同步配置后，按配置去更新<code>Bundle</code></li></ul><p>如下图：</p><p><img src="http://media.newbmiao.com/opa/bundle.png" alt="management api"></p><p>这里举个带注释<code>Bundle</code>的四种接口配置例子</p><p>（先扫一遍留个印象，具体使用时查看文档，后边会提供可实操的代码）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># opa/config-bundle.yaml</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 定义服务，支持多个</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example_bundle</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://demo-server:8888/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bundles:</span></span><br><span class="line">  <span class="comment"># 定义bundle, 支持多个</span></span><br><span class="line">  <span class="attr">authz:</span></span><br><span class="line">    <span class="comment"># bundle所处的服务</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">example_bundle</span></span><br><span class="line">    <span class="comment"># 这里指从resource处更新bundle文件包，即：</span></span><br><span class="line">    <span class="comment"># http://demo-server:8888/bundle/rbac.tar.gz</span></span><br><span class="line">    <span class="attr">resource:</span> <span class="string">bundle/rbac.tar.gz</span></span><br><span class="line">    <span class="attr">polling:</span></span><br><span class="line">      <span class="comment"># 300~600s间更新一次</span></span><br><span class="line">      <span class="attr">min_delay_seconds:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">max_delay_seconds:</span> <span class="number">600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">decision_logs:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">example_bundle</span></span><br><span class="line">  <span class="comment"># partition_name为区分上传地址,会跟到 /logs 后, 即：</span></span><br><span class="line">  <span class="comment"># http://demo-server:8888/logs/bundle</span></span><br><span class="line">  <span class="comment"># 注意上传的是gzip日志文件</span></span><br><span class="line">  <span class="attr">partition_name:</span> <span class="string">bundle</span></span><br><span class="line">  <span class="attr">reporting:</span></span><br><span class="line">    <span class="attr">min_delay_seconds:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">max_delay_seconds:</span> <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">example_bundle</span></span><br><span class="line">  <span class="comment"># 即 http://demo-server:8888/status/bundle</span></span><br><span class="line">  <span class="attr">partition_name:</span> <span class="string">bundle</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认查询路径</span></span><br><span class="line"><span class="attr">default_decision:</span> <span class="string">rbac/allow</span></span><br></pre></td></tr></table></figure><h2 id="Bundle-集成方式"><a href="#Bundle-集成方式" class="headerlink" title="Bundle 集成方式"></a>Bundle 集成方式</h2><p>这里我们简单过下集成方式</p><h3 id="opa-server-方式"><a href="#opa-server-方式" class="headerlink" title="opa server 方式"></a>opa server 方式</h3><p>运行方式很简单如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opa run -s -a 0.0.0.0:8181 -c opa/config-bundle.yaml</span><br></pre></td></tr></table></figure><p>运行后，opa server会根据配置自动拉取<code>Bundle</code>包：<code>rbac.tar.gz</code></p><p>下载成功后启动策略服务。同时定期上传决策日志和状态给服务端（即：<code>demo-server:8888</code>）</p><h3 id="go-lib-方式"><a href="#go-lib-方式" class="headerlink" title="go lib 方式"></a>go lib 方式</h3><p>使用lib <code>github.com/open-policy-agent/opa/rego</code>集成</p><p>关键代码举例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建查询，PrepareForEval可重用</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">query, err := rego.New(</span><br><span class="line">    rego.LoadBundle(<span class="string">"./rbac.tar.gz"</span>),</span><br><span class="line">    rego.Query(<span class="string">"x = data.rbac.allow"</span>),</span><br><span class="line">).PrepareForEval(context.Background())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">results, err := query.Eval(context.Background(), rego.EvalInput(input))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fatalln(<span class="string">"Opa eval error:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(results) == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Fatalln(<span class="string">"Opa eval error: no result"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Opa result:"</span>, results[<span class="number">0</span>].Expressions[<span class="number">0</span>].Value)</span><br></pre></td></tr></table></figure><p>具体组织方式官方推荐的有下边<strong>集中式</strong>和<strong>分布式</strong>这两种：</p><p><img src="http://media.newbmiao.com/opa/host-local.png" alt="host-local"></p><p><img src="http://media.newbmiao.com/opa/distributed-enforcement.png" alt="distributed-enforcement"></p><p>推荐感兴趣的同学再去看下官方go集成的demo: <a href="https://github.com/open-policy-agent/example-api-authz-go" target="_blank" rel="noopener">example-api-authz-go</a></p><h2 id="Bundle-的监控"><a href="#Bundle-的监控" class="headerlink" title="Bundle 的监控"></a>Bundle 的监控</h2><p>opa server 支持<code>metrics</code>, 而且是<code>prometheus</code>格式的</p><p>所以配合<code>prometheus</code>可以直接进行对其数据指标的监控，如下图：</p><p><img src="http://media.newbmiao.com/opa/prometheus.png" alt="prometheus"></p><p>再配合<code>grafana</code>的<code>dashbord</code>可以更好的展示<code>metrics</code>数据，如下图：</p><p><img src="http://media.newbmiao.com/opa/grafana.png" alt="grafana"></p><h2 id="Bundle-in-action"><a href="#Bundle-in-action" class="headerlink" title="Bundle in action"></a>Bundle in action</h2><p>上边说这么多，不实际试一下怎么知道<code>Bundle</code>究竟如何呢？</p><p>这里提供一个<code>docker-compose</code>版的demo给大家去本地验证尝试</p><p>里边提供了三种<code>Bundle</code>版本：</p><ul><li>opa-bundle</li><li>opa-discovery</li><li>demo-sever (go lib集成)</li></ul><p>也提供了两种版本的<code>monitor</code></p><ul><li>slim version</li><li>advance version</li></ul><p>代码见：<a href="https://github.com/NewbMiao/opa-koans/tree/master/bundle" target="_blank" rel="noopener">NewbMiao/opa-koans/bundle</a></p><p>里边有详细的操作文档，有问题可以在Repo里提issue</p><p>这个Repo包含了这一系列的<code>OPA</code>教程，欢迎感兴趣的同学 <strong><code>star</code></strong> 关注！</p><p>同时我在知乎也建了一个<a href="https://www.zhihu.com/club/1225433566832132096" target="_blank" rel="noopener">OPA技术圈</a>，也欢迎大家参与讨论。</p><p>好了，到此，<code>OPA</code>的基本教程就结束了。后边再抽空结合官方的例子写些实战教程吧。</p><hr><p>最后附上一个Repo中验证Bundle的过程，大家也可以从这里开始尝试哦</p><p><img src="http://media.newbmiao.com/opa/bundleVerify.gif" alt="scripts/bundleVerify.sh"></p>]]></content>
    
    <summary type="html">
    
      OPA进阶-分布式利器Bundle
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="bundle" scheme="http://blog.newbmiao.com/tags/bundle/"/>
    
  </entry>
  
  <entry>
    <title>OPA进阶-测试、性能分析和基准测试</title>
    <link href="http://blog.newbmiao.com/2020/04/05/opa-test-profile-and-benchmark.html"/>
    <id>http://blog.newbmiao.com/2020/04/05/opa-test-profile-and-benchmark.html</id>
    <published>2020-04-05T09:48:30.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<p>本文来讲讲<code>OPA</code>的测试（<code>test</code>）、性能分析（<code>profile</code>）和（<code>benchmark</code>）</p><p>掌握他们，对于保证策略代码的质量和决策效率有很大的帮助</p><a id="more"></a><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p><code>OPA</code>的测试很简单。</p><p>所有<code>test_</code>前缀的的规则（<code>rule</code>）都是测试。</p><blockquote><p>Tips: 虽然是测试，但其本质上其仍是规则，仍然可以被查询。<br>另外建议文件名遵循<code>_test.rego</code>后缀加以区分</p></blockquote><p>这里拿<code>quick-start</code>的测试例子来看下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example_rbac_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> data.example_rbac</span><br><span class="line"></span><br><span class="line">test_not_allow &#123;</span><br><span class="line">    not example_rbac.allow with input as &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_allow &#123;</span><br><span class="line">  example_rbac.allow with input as &#123;</span><br><span class="line">    <span class="string">"action"</span>: &#123;</span><br><span class="line">      <span class="string">"operation"</span>: <span class="string">"read"</span>,</span><br><span class="line">      <span class="string">"resource"</span>: <span class="string">"widgets"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"subject"</span>: &#123;<span class="string">"user"</span>: <span class="string">"inspector-alice"</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样即覆盖了<code>allow</code>规则的全部测试用例。</p><p>注意这里<code>with</code>起到了数据模拟的作用（<code>data mocking</code>）</p><blockquote><p>Tips: 函数不可用<code>with</code>替换</p></blockquote><p>对应的命令行是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd quick-start</span><br><span class="line">opa test . -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下</span></span><br><span class="line">data.example_rbac_test.test_not_allow: PASS (693.201µs)</span><br><span class="line">data.example_rbac_test.test_allow: PASS (562.02µs)</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">PASS: 2/2</span><br></pre></td></tr></table></figure><p>也可以查看测试覆盖率：</p><p><code>opa test . -c</code></p><p>设定测试覆盖率标准：</p><p><code>opa test . -c --threshold 100</code></p><p>（这里提示下别忘了<code>vscode-opa</code>支持可视化覆盖率展示哦）</p><p>也支持选择测试用例执行：</p><p><code>opa test -r test_allow . -v</code></p><h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cd quick-start</span><br><span class="line">opa eval --profile -d example.rego -d data.json -i input.json -f pretty <span class="string">"data.example_rbac.allow"</span>  </span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">+------------------------------+---------+</span><br><span class="line">|            METRIC            |  VALUE  |</span><br><span class="line">+------------------------------+---------+</span><br><span class="line">| timer_rego_data_parse_ns     | <span class="number">18332</span>   |</span><br><span class="line">| timer_rego_load_files_ns     | <span class="number">5506307</span> |</span><br><span class="line">| timer_rego_module_compile_ns | <span class="number">573408</span>  |</span><br><span class="line">| timer_rego_module_parse_ns   | <span class="number">5226456</span> |</span><br><span class="line">| timer_rego_query_compile_ns  | <span class="number">87390</span>   |</span><br><span class="line">| timer_rego_query_eval_ns     | <span class="number">292198</span>  |</span><br><span class="line">| timer_rego_query_parse_ns    | <span class="number">277932</span>  |</span><br><span class="line">+------------------------------+---------+</span><br><span class="line">+----------+----------+----------+-------------------------+</span><br><span class="line">|   TIME   | NUM EVAL | NUM REDO |        LOCATION         |</span><br><span class="line">+----------+----------+----------+-------------------------+</span><br><span class="line">| <span class="number">54.121</span>µs | <span class="number">1</span>        | <span class="number">1</span>        | data.example_rbac.allow |</span><br><span class="line">| <span class="number">42.776</span>µs | <span class="number">1</span>        | <span class="number">2</span>        | example.rego:<span class="number">15</span>         |</span><br><span class="line">| <span class="number">37.861</span>µs | <span class="number">1</span>        | <span class="number">1</span>        | example.rego:<span class="number">9</span>          |</span><br><span class="line">| <span class="number">35.81</span>µs  | <span class="number">1</span>        | <span class="number">1</span>        | example.rego:<span class="number">25</span>         |</span><br><span class="line">| <span class="number">22.469</span>µs | <span class="number">1</span>        | <span class="number">1</span>        | example.rego:<span class="number">10</span>         |</span><br><span class="line">| <span class="number">21.353</span>µs | <span class="number">2</span>        | <span class="number">2</span>        | example.rego:<span class="number">16</span>         |</span><br><span class="line">| <span class="number">16.888</span>µs | <span class="number">2</span>        | <span class="number">1</span>        | example.rego:<span class="number">17</span>         |</span><br><span class="line">| <span class="number">15.923</span>µs | <span class="number">2</span>        | <span class="number">1</span>        | example.rego:<span class="number">23</span>         |</span><br><span class="line">| <span class="number">14.736</span>µs | <span class="number">1</span>        | <span class="number">2</span>        | example.rego:<span class="number">22</span>         |</span><br><span class="line">| <span class="number">8.798</span>µs  | <span class="number">1</span>        | <span class="number">1</span>        | example.rego:<span class="number">24</span>         |</span><br><span class="line">+----------+----------+----------+-------------------------+</span><br></pre></td></tr></table></figure><blockquote><p>Tips: –profile还支持结果排序和限制显示条数</p><ul><li><code>--profile-sort</code>：对性能分析结果排序，默认按<code>total_time_ns =&gt; num_eval =&gt; num_redo =&gt; file =&gt; line</code>排序, 详见<a href="https://www.openpolicyagent.org/docs/latest/policy-performance/#sort-criteria-for-the-profile-results" target="_blank" rel="noopener">profile-sort文档</a></li><li><code>--profile-limit</code>：显示几条分析结果，默认10条</li></ul></blockquote><h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><p><code>opa</code> 也支持<code>benchmark</code>，基本实现了<code>go</code>的<code>benchmark</code>的使用方式, 甚至有更详细的结果（毕竟一直标榜性能么）</p><p>默认<code>benchmark</code>会展示内存（<code>--benchmem</code>）和查询(<code>--metrics</code>)的基准测试结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ opa bench --count <span class="number">1</span> -d example.rego -d data.json -i input.json -f pretty <span class="string">"data.example_rbac.allow"</span></span><br><span class="line">+-------------------------------------------+------------+</span><br><span class="line">| samples                                   |      <span class="number">14162</span> |</span><br><span class="line">| ns/op                                     |      <span class="number">93655</span> |</span><br><span class="line">| B/op                                      |      <span class="number">15117</span> |</span><br><span class="line">| allocs/op                                 |        <span class="number">311</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_75%    |      <span class="number">89900</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_90%    |     <span class="number">112253</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_95%    |     <span class="number">125465</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_99%    |     <span class="number">222404</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_99<span class="number">.9</span>%  |     <span class="number">549291</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_99<span class="number">.99</span>% |     <span class="number">550611</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_count  |      <span class="number">14162</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_max    |     <span class="number">550611</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_mean   |      <span class="number">76735</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_median |      <span class="number">68336</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_min    |      <span class="number">38896</span> |</span><br><span class="line">| histogram_timer_rego_query_eval_ns_stddev |      <span class="number">38828</span> |</span><br><span class="line">+-------------------------------------------+------------+</span><br></pre></td></tr></table></figure><p>当然也集成到了<code>opa test</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ opa test -v --bench  example.rego example_test.rego data.json </span><br><span class="line">data.example_rbac_test.test_not_allow      <span class="number">15139</span>             <span class="number">74172</span> ns/op             <span class="number">62044</span> timer_rego_query_eval_ns/op     <span class="number">14666</span> B/op     <span class="number">270</span> allocs/op</span><br><span class="line">data.example_rbac_test.test_allow          <span class="number">10000</span>            <span class="number">102658</span> ns/op             <span class="number">90779</span> timer_rego_query_eval_ns/op     <span class="number">17825</span> B/op     <span class="number">367</span> allocs/op</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">PASS: <span class="number">2</span>/<span class="number">2</span></span><br></pre></td></tr></table></figure><p>而且<code>--format</code>指定<code>gobench</code>的话，还支持了<a href="https://github.com/golang/perf" target="_blank" rel="noopener"><code>benchstat</code></a>, 是<code>Go</code>亲生的，无疑了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">opa test -v --bench --count <span class="number">5</span> --format gobench   example.rego example_test.rego data.json| tee b.txt</span><br><span class="line"></span><br><span class="line">BenchmarkDataExampleRbacTestTestNotAllow           <span class="number">15186</span>             <span class="number">87349</span> ns/op             <span class="number">73644</span> timer_rego_query_eval_ns/op     <span class="number">14663</span> B/op        <span class="number">270</span> allocs/op</span><br><span class="line">BenchmarkDataExampleRbacTestTestAllow      <span class="number">10000</span>            <span class="number">115857</span> ns/op            <span class="number">101565</span> timer_rego_query_eval_ns/op     <span class="number">17828</span> B/op        <span class="number">367</span> allocs/op</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">PASS: <span class="number">2</span>/<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">benchstat b.txt</span><br><span class="line"></span><br><span class="line">name                             time/op</span><br><span class="line">DataExampleRbacTestTestNotAllow                  <span class="number">92.9</span>µs ±<span class="number">40</span>%</span><br><span class="line">DataExampleRbacTestTestAllow                      <span class="number">123</span>µs ± <span class="number">8</span>%</span><br><span class="line"></span><br><span class="line">name                             timer_rego_query_eval_ns/op</span><br><span class="line">DataExampleRbacTestTestNotAllow                   <span class="number">79.0</span>k ±<span class="number">41</span>%</span><br><span class="line">DataExampleRbacTestTestAllow                       <span class="number">109</span>k ± <span class="number">9</span>%</span><br><span class="line"></span><br><span class="line">name                             alloc/op</span><br><span class="line">DataExampleRbacTestTestNotAllow                  <span class="number">14.7</span>kB ± <span class="number">0</span>%</span><br><span class="line">DataExampleRbacTestTestAllow                     <span class="number">17.8</span>kB ± <span class="number">0</span>%</span><br><span class="line"></span><br><span class="line">name                             allocs/op</span><br><span class="line">DataExampleRbacTestTestNotAllow                     <span class="number">270</span> ± <span class="number">0</span>%</span><br><span class="line">DataExampleRbacTestTestAllow                        <span class="number">367</span> ± <span class="number">0</span>%</span><br></pre></td></tr></table></figure><p>基准测试前后对比自然也是支持，如<code>benchstat old.txt new.txt</code>，就不详述了。</p><p>这些工具固然好，高性能还是需要follow一些经验法则的</p><p>这里引用官方对于性能优化的建议如下(<a href="https://www.openpolicyagent.org/docs/latest/policy-performance/#key-takeaways" target="_blank" rel="noopener">key-takeaways</a>)：</p><ul><li>编写策略（<code>policy</code>）要最大程度地减少迭代和搜索。<ul><li>使用的数组元素有唯一标识符时，改为唯一标识作为key的对象。</li><li>考虑利用部分评估（<a href="https://blog.openpolicyagent.org/partial-evaluation-162750eaf422" target="_blank" rel="noopener">partial-evaluation</a>）以将非线性策略编译为线性策略。</li></ul></li><li>利用规则索引优化（<a href="https://blog.openpolicyagent.org/optimizing-opa-rule-indexing-59f03f17caf3" target="_blank" rel="noopener">rule-indexing</a>）编写策略，以便规则索引有效。</li><li>使用探查器(<code>profiler</code>)可帮助确定策略的哪些部分将从提高的性能中受益最大。</li><li>使用基准测试工具（<code>benchmark tools</code>）来帮助获取真实世界的时序数据并检测策略性能变化。</li></ul><blockquote><p>里边提到的<code>partial-evaluation</code>和<code>rule-indexing</code>是保证<code>OPA</code>高性能的两个重要特性，感兴趣的同学可以自行查看下。</p></blockquote><p>下一篇，我们来谈谈<code>OPA</code>的一个重磅功能 - <code>bundle</code>, 一种将策略及数据进行包组织的方式，也支持丰富的管理<code>restful api</code>,适合分布式决策服务的构建。</p>]]></content>
    
    <summary type="html">
    
      OPA进阶-测试、性能分析和基准测试
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="test" scheme="http://blog.newbmiao.com/tags/test/"/>
    
      <category term="profile" scheme="http://blog.newbmiao.com/tags/profile/"/>
    
      <category term="benchmark" scheme="http://blog.newbmiao.com/tags/benchmark/"/>
    
  </entry>
  
  <entry>
    <title>OPA进阶-简洁的推导式</title>
    <link href="http://blog.newbmiao.com/2020/03/20/opa-comprehensions.html"/>
    <id>http://blog.newbmiao.com/2020/03/20/opa-comprehensions.html</id>
    <published>2020-03-20T06:58:18.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<p>本文来讲讲<code>OPA</code>推导式（comprehensions），主要涉及三类数据的推导式：<code>object，array，set</code></p><p>我们将以实现判断配置文件数据的不同聚合方式为例展开。</p><a id="more"></a><p>用到的输入(配置文件列表)为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input.json</span></span><br><span class="line"><span class="comment">// posix为常见路径格式</span></span><br><span class="line"><span class="comment">// traditional-mac为mac的一种文件路径格式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"posix"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/Users/newbmiao/Documents/1.yaml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"posix"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/Users/newbmiao/Documents/2.yaml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"traditional-mac"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.yml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"traditional-mac"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.json"</span></span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="comprehensions"><a href="#comprehensions" class="headerlink" title="comprehensions"></a>comprehensions</h2><p>推导式（<code>comprehensions</code>）提供了一种从子查询构建复合值（<code>Composite Values</code>）的简洁方法。</p><p>定义很晦涩，我们从例子来看会清晰许多</p><h3 id="object-comprehensions"><a href="#object-comprehensions" class="headerlink" title="object comprehensions"></a>object comprehensions</h3><p>首先看一个按文件路径类型聚合文件的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> input.files</span><br><span class="line"></span><br><span class="line">group_files_by_type := &#123;<span class="keyword">type</span>: paths |</span><br><span class="line">  file := files[_]</span><br><span class="line">  <span class="keyword">type</span> := file.<span class="keyword">type</span></span><br><span class="line">  paths := [path |</span><br><span class="line">    tmp := files[_]</span><br><span class="line">    tmp.<span class="keyword">type</span> == <span class="keyword">type</span></span><br><span class="line">    path := tmp.path</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即两层遍历，外层遍历获取<code>type</code></p><p>内层遍历按<code>type</code>匹配推导出<code>paths</code>数组</p><p>对应结果为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">opa eval -f values -d . -i input.json <span class="string">"data.example_comprehensions.group_files_by_type"</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"posix"</span>: [</span><br><span class="line">      <span class="string">"/Users/newbmiao/Documents/1.yaml"</span>,</span><br><span class="line">      <span class="string">"/Users/newbmiao/Documents/2.yaml"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"traditional-mac"</span>: [</span><br><span class="line">      <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.yml"</span>,</span><br><span class="line">      <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.json"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>忽略实现细节，对象的推导式语法为：</p><p><code>{ &lt;key&gt;: &lt;term&gt; | &lt;body&gt; }</code></p><p>定义的<code>key</code>和<code>term</code>需要在<code>body</code>内赋值，最后会复合出一个对象，包含有所有满足的<code>&lt;key&gt;: &lt;term&gt;</code></p><p>这里要注意的事<code>body</code>内条件要都满足才会返回</p><h3 id="array-comprehensions"><a href="#array-comprehensions" class="headerlink" title="array comprehensions"></a>array comprehensions</h3><p>上边例子中<code>paths</code>是一个数组推导式</p><p>其语法为: <code>[ &lt;term&gt; | &lt;body&gt; ]</code></p><p>注意这里的<code>[]</code>， 只有数组推导式用方括号</p><p>而且其内容是<strong>可重复的</strong></p><p>对应再举一个将所有文件路径转为<code>posix</code>的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">convert_all_to_posix_path_array := [path |</span><br><span class="line">  path1 := [p |</span><br><span class="line">    file := files[_]</span><br><span class="line">    file.<span class="keyword">type</span> == <span class="string">"posix"</span></span><br><span class="line">    p := file.path</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  path2 := [p |</span><br><span class="line">    file := files[_]</span><br><span class="line">    file.<span class="keyword">type</span> == <span class="string">"traditional-mac"</span></span><br><span class="line">    p := replace(replace(file.path, <span class="string">"Macintosh HD"</span>, <span class="string">""</span>), <span class="string">":"</span>, <span class="string">"/"</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  paths := array.concat(path1, path2)</span><br><span class="line">  path = paths[_]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里按文件路径类型推导出<code>path1</code>和<code>path2</code>两个数组</p><p>其内部对于<code>file.type</code>的判断达到了过滤匹配的作用</p><h3 id="set-comprehensions"><a href="#set-comprehensions" class="headerlink" title="set comprehensions"></a>set comprehensions</h3><p>上边功能也可以用集合推导式实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">convert_all_to_posix_path_sets := &#123;path |</span><br><span class="line">  path1 := &#123;p |</span><br><span class="line">    file := files[_]</span><br><span class="line">    file.<span class="keyword">type</span> == <span class="string">"posix"</span></span><br><span class="line">    p := file.path</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  path2 := &#123;p |</span><br><span class="line">    file := files[_]</span><br><span class="line">    file.<span class="keyword">type</span> == <span class="string">"traditional-mac"</span></span><br><span class="line">    p := replace(replace(file.path, <span class="string">"Macintosh HD"</span>, <span class="string">""</span>), <span class="string">":"</span>, <span class="string">"/"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  paths := path1 | path2</span><br><span class="line">  path = paths[_]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合推导式语法为：</p><p><code>{ &lt;term&gt; | &lt;body&gt; }</code></p><p>其特点是<strong>不会重复</strong></p><p>可以看出同样功能，集合做组合操作比较表意</p><p>类似的，交集可以用<code>&amp;</code>,差集可以用<code>-</code></p><p>以上就是<code>OPA</code>三类推导式的使用方式。推导式最大的特点就是简洁。</p><p>一旦你熟悉了，就可以写出很多优雅的聚合方式。</p><p>最后出一个题目，大家可以自己练习下(答案可以去<code>opa-koans</code>中查看)</p><p>实现基于文件后缀聚合文件路径, 即输出为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"json"</span>: [</span><br><span class="line">    <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.json"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"yaml"</span>: [</span><br><span class="line">    <span class="string">"/Users/newbmiao/Documents/1.yaml"</span>,</span><br><span class="line">    <span class="string">"/Users/newbmiao/Documents/2.yaml"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"yml"</span>: [</span><br><span class="line">    <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.yml"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示, 对于文件后缀可以用如下两种方式获取</p><p>方式一： <code>hardcode</code></p><p><code>extSets := [&quot;yaml&quot;, &quot;yml&quot;, &quot;json&quot;]</code></p><p>方式二：<code>regex</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extSets := &#123;e |</span><br><span class="line">  e = regex.find_all_string_submatch_n(<span class="string">".*\\.(.*)$"</span>, files[_].path, <span class="number">-1</span>)[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文代码详见:<a href="https://github.com/NewbMiao/opa-koans/tree/master/syntax/comprehensions.rego" target="_blank" rel="noopener">NewbMiao/opa-koans</a></p></blockquote><p>下一篇，我们讲讲如何用<code>OPA</code>的测试和压测保证规则的正确性与效率。</p>]]></content>
    
    <summary type="html">
    
      OPA进阶-简洁的推导式
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="comprehensions" scheme="http://blog.newbmiao.com/tags/comprehensions/"/>
    
  </entry>
  
  <entry>
    <title>OPA进阶-函数与虚拟文档要分清</title>
    <link href="http://blog.newbmiao.com/2020/03/18/opa-func-and-virtual-doc.html"/>
    <id>http://blog.newbmiao.com/2020/03/18/opa-func-and-virtual-doc.html</id>
    <published>2020-03-18T14:27:00.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<p>本文来讲讲<code>OPA</code>常用的函数（<code>function</code>）和虚拟文档（<code>virtual document</code>），以及他们使用的场景。</p><p>我们将以实现判断配置文件为例展开。</p><a id="more"></a><p>用到的输入(配置文件列表)为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input.json</span></span><br><span class="line"><span class="comment">// posix为常见路径格式</span></span><br><span class="line"><span class="comment">// traditional-mac为mac的一种文件路径格式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"posix"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/Users/newbmiao/Documents/1.yaml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"posix"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/Users/newbmiao/Documents/2.yaml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"traditional-mac"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.yml"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"traditional-mac"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"Macintosh HD:Users:newbmiao:Documents:3.json"</span></span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数基本每个语言都会有，要说<code>OPA</code>里有啥特别的地方，那就是他也实现同名函数，类似“函数重载”，但简化了许多。</p><p>他的特点是：</p><ul><li>默认函数返回值为 true/false</li><li>可以指定函数返回值</li><li>可以存在同名函数, 但参数数目不能变</li><li>相同输入（参数）必须获得相同输出（返回值）</li></ul><p>举例来说，如果实现判断文件是否是配置文件后缀：</p><p>下边<code>is_config_file</code>就是不指定返回值</p><p>条件满足则返回true，三个实现只要满足一个就为true</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">is_config_file(str) &#123;</span><br><span class="line">  contains(str, <span class="string">".yaml"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_config_file(str) &#123;</span><br><span class="line">  contains(str, <span class="string">".yml"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_config_file(str) &#123;</span><br><span class="line">  contains(str, <span class="string">".json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以使用<code>else</code>关键字合并到一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">is_config_file2(str) &#123;</span><br><span class="line">  contains(str, <span class="string">".yaml"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  contains(str, <span class="string">".yml"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  contains(str, <span class="string">".json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果指定返回值怎么重载呢？</p><p>以实现不同路径格式的文件名为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getFileName(<span class="keyword">type</span>, str) = x &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">"posix"</span></span><br><span class="line">  str = trim(str)</span><br><span class="line">  tmp := split(str, <span class="string">"/"</span>)</span><br><span class="line">  x := tmp[minus(count(tmp), <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileName(<span class="keyword">type</span>, str) = x &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">"traditional-mac"</span></span><br><span class="line">  str = trim(str)</span><br><span class="line">  tmp := split(str, <span class="string">":"</span>)</span><br><span class="line">  x := tmp[minus(count(tmp), <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现两个函数输入和返回不是相同的么？</p><p>其实不是，仔细看他们内都做了 <code>type = {&quot;traditional-mac&quot;|&quot;posix&quot;}</code> 的判断</p><p>这实际类似函数声明为 <code>getFileName(&quot;posix&quot;, str) = x {}</code>, 所以输入是不同的</p><p>如果你省略了<code>type</code>的判断，会报错的：</p><p><code>eval_conflict_error: functions must not produce multiple outputs for same inputs</code></p><p>到此，将函数组合一下就可以实现判定是否为配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> input.files</span><br><span class="line"></span><br><span class="line">is_config &#123;</span><br><span class="line">  file := files[_]</span><br><span class="line">  x := getFileName(file.<span class="keyword">type</span>, file.path)</span><br><span class="line">  is_config_file(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 关于<code>OPA</code>的内置函数可以查看文档:<a href="https://www.openpolicyagent.org/docs/latest/policy-reference/#built-in-functions" target="_blank" rel="noopener">built-in-functions</a></p></blockquote><h2 id="虚拟文档"><a href="#虚拟文档" class="headerlink" title="虚拟文档"></a>虚拟文档</h2><p>虚拟文档是生成的文档（或者称为<strong>集合</strong>）</p><p>他的特点是：</p><ul><li>作为集合，输入和输出必须是有限的</li><li>可以遍历</li><li>可以查询</li></ul><p>举例来说，同样是获取文件名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> input.files</span><br><span class="line"></span><br><span class="line">getFileNames[x] &#123;</span><br><span class="line">  file := files[_]</span><br><span class="line">  file.<span class="keyword">type</span> = <span class="string">"posix"</span></span><br><span class="line">  file.path = trim(file.path)</span><br><span class="line">  tmp := split(file.path, <span class="string">"/"</span>)</span><br><span class="line">  x := tmp[minus(count(tmp), <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileNames[x] &#123;</span><br><span class="line">  file := files[_]</span><br><span class="line">  file.<span class="keyword">type</span> = <span class="string">"traditional-mac"</span></span><br><span class="line">  file.path = trim(file.path)</span><br><span class="line">  tmp := split(file.path, <span class="string">":"</span>)</span><br><span class="line">  x := tmp[minus(count(tmp), <span class="number">1</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>getFileNames[x] {}</code> 等价于 <code>getFileNames[x] = x {}</code></p><p>就是<code>x</code>作为了集合的一个结果，填充到<code>getFileNames</code>这个虚拟文档中，其<code>key</code>也是<code>x</code>的值。</p><p>有点抽象是不？</p><p>别怕，他可以查询，我们查询看下他的结果就好理解了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd syntax</span><br><span class="line">opa eval -f values -i input.json -d . <span class="string">"data.example_virtual_doc.getFileNames"</span></span><br><span class="line">[</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"1.yaml"</span>,</span><br><span class="line">    <span class="string">"2.yaml"</span>,</span><br><span class="line">    <span class="string">"3.yml"</span>,</span><br><span class="line">    <span class="string">"3.json"</span></span><br><span class="line">  ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后<strong>遍历</strong>虚拟文档，结合判定<code>is_config_file</code>就可实现判定：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> data.example_func.is_config_file</span><br><span class="line"><span class="keyword">import</span> input.files</span><br><span class="line"></span><br><span class="line">is_config &#123;</span><br><span class="line">  is_config_file(getFileNames[_])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里遍历<code>getFileNames[_]</code>,随即作为每一个输入参数传给<code>is_config_file</code>进行判断，是不是很方便！</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>具体到他们的适用场景，其实比较好区分，重点只要关注两点：</p><ul><li>是否需要<strong>遍历</strong>？</li><li>输入输出是否是<strong>有限</strong>的？</li></ul><p>如果有一个答案是肯定的，那么虚拟文档就更适合。</p><p><code>OPA</code>的函数和虚拟文档很简单、很清秀是不是？</p><p>今天就到这里，下一篇我们看看他更优雅的推导式（<code>Comprehensions</code>）。</p><blockquote><p>本文代码详见:<a href="https://github.com/NewbMiao/opa-koans/tree/master/syntax" target="_blank" rel="noopener">NewbMiao/opa-koans</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      OPA进阶-函数与虚拟文档
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="virtual-document" scheme="http://blog.newbmiao.com/tags/virtual-document/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的使用opa进行开发</title>
    <link href="http://blog.newbmiao.com/2020/03/14/how-to-use-opa-cli-elegantly.html"/>
    <id>http://blog.newbmiao.com/2020/03/14/how-to-use-opa-cli-elegantly.html</id>
    <published>2020-03-14T02:56:26.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<p>上文<a href="https://mp.weixin.qq.com/s/UYDOm7Exs1Rk0cKadOLkZw" target="_blank" rel="noopener">OPA-重新定义规则引擎-入门篇</a>一个简单的例子介绍了<code>OPA</code>如何使用。也提供了在线运行版代码供大家尝试。</p><p>本文趁热打铁，介绍如何优雅的使用<code>opa</code>进行开发。</p><a id="more"></a><h2 id="opa"><a href="#opa" class="headerlink" title="opa"></a>opa</h2><p><code>opa</code>（命令行工具）现在迭代比较快，为了性能和一些丰富的内置函数，推荐使用最新版</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mac</span></span><br><span class="line">curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_darwin_amd64</span><br><span class="line">chmod +x opa</span><br><span class="line">mv opa /usr/local/bin/opa</span><br></pre></td></tr></table></figure><p>查看命令帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opa -h</span></span><br><span class="line">An open source project to policy-enable your service.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  opa [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  build       Compile Rego policy queries</span><br><span class="line">  check       Check Rego source files</span><br><span class="line">  deps        Analyze Rego query dependencies</span><br><span class="line">  eval        Evaluate a Rego query</span><br><span class="line">  fmt         Format Rego source files</span><br><span class="line">  help        Help about any command</span><br><span class="line">  parse       Parse Rego source file</span><br><span class="line">  run         Start OPA in interactive or server mode</span><br><span class="line">  test        Execute Rego test cases</span><br><span class="line">  version     Print the version of OPA</span><br></pre></td></tr></table></figure><p>看介绍能知道每个命令是干啥的，用到时具体看help就行</p><p>这里边挑常用的命令讲下：</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p><code>opa run</code>是<code>OPA</code>实现的<strong>交互式运行</strong>（<code>REPL</code>）命令，本地学习或者调试会很方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opa run quick-start</span></span><br><span class="line">OPA 0.17.3 (commit 28ca58f3, built at 2020-03-03T18:07:55Z)</span><br><span class="line">Run 'help' to see a list of commands.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> data  <span class="comment">#获取上下文</span></span></span><br></pre></td></tr></table></figure><p>你会得到json格式的data下的所有节点内容</p><p>主要有两类，所有<code>quick-start</code>目录下的</p><ul><li>配置文件（<code>.json|.yaml|.yml</code>）</li></ul><p>对应的父节点是<code>data</code></p><ul><li><code>Rego</code>文件(包括test文件)</li></ul><p>对应的父节点是<code>data.&lt;package name&gt;</code></p><blockquote><p>Tips: 这样配置文件都挂在<code>data</code>这个根节点下了，如果想加载配置文件时增加父节点（如<code>data.example.file</code>）该怎么办？<br>可以文件的路径映射前缀 <code>opa run example.file:quick-start</code><br>注意<strong>只会改变配置文件</strong>的父节点<br>这一点很有用，以后讲<code>bundle</code>也会提到</p></blockquote><p>当然也可以指定输入文件<code>input</code>。这个比较特殊，命令行保留了包前缀<code>repl.input</code>给<code>input</code></p><p>也就是说，可以用<code>repl.input:&lt;path to input.json&gt;</code>的方式传递输入，而避免挂载到<code>data</code>根节点下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ opa run  quick-start  repl.input:quick-start/input.json</span><br><span class="line">&gt; data.example_rbac</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"allow"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"role_has_permission"</span>: [</span><br><span class="line">    <span class="string">"widget-reader"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"user_has_role"</span>: [</span><br><span class="line">    <span class="string">"widget-reader"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: <code>-w</code>支持交互式窗口内实时文件变更reload<br><code>-s</code>支持服务常驻式启动，启动后可以REST-Api查询；</p></blockquote><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p><code>opa eval</code>是用来查询策略结果</p><p><code>-d</code> 指定上下文，<code>-i</code> 指定输入</p><p><code>-f</code> 指定返回格式，默认json，还支持<code>values,bindings,pretty,source</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">opa eval -f values -d quick-start -i quick-start/input.json "data.example_rbac"</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"allow"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"role_has_permission"</span>: [</span><br><span class="line">      <span class="string">"widget-reader"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"user_has_role"</span>: [</span><br><span class="line">      <span class="string">"widget-reader"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--explain=notes</code> 配合 <code>trace(msg)</code> 可以<strong>调试</strong>执行过程</p><p>如下边规则增加<code>trace(role_name)</code>调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allow &#123;</span><br><span class="line">  trace(role_name)</span><br><span class="line">  user_has_role[role_name]</span><br><span class="line">  role_has_permission[role_name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>--explain=notes</code>时可以看到所有调用点note</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opa eval -f pretty -d quick-start -i quick-start/input.json <span class="string">"data.example_rbac.allow"</span> --explain=notes</span><br><span class="line"></span><br><span class="line">query:<span class="number">1</span>             Enter data.example_rbac.allow = _</span><br><span class="line">quick-start/exa:<span class="number">6</span>   | Enter data.example_rbac.allow</span><br><span class="line">note                | | Note <span class="string">"widget-reader"</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>除此，默认<code>--explain</code>支持<code>full</code>和<code>fails</code>的<code>trace</code>打印</p><blockquote><p>Tips: 还支持性能分析 <code>--metrics</code>, <code>--instrument</code>, <code>--profile</code></p></blockquote><h3 id="deps"><a href="#deps" class="headerlink" title="deps"></a>deps</h3><p><code>opa deps</code> 用来分析查询依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opa deps -d quick-start <span class="string">"data.example_rbac"</span></span></span><br><span class="line">+------------------------+---------------------------------------+</span><br><span class="line">|     BASE DOCUMENTS     |           VIRTUAL DOCUMENTS           |</span><br><span class="line">+------------------------+---------------------------------------+</span><br><span class="line">| data.bindings          | data.example_rbac.allow               |</span><br><span class="line">| data.roles             | data.example_rbac.role_has_permission |</span><br><span class="line">| input.action.operation | data.example_rbac.user_has_role       |</span><br><span class="line">| input.action.resource  |                                       |</span><br><span class="line">| input.subject.user     |                                       |</span><br><span class="line">+------------------------+---------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p><code>opa test</code> 用来跑测试，<code>-c</code>支持输出覆盖率，<code>--threshold</code> 可指定通过覆盖率</p><h3 id="check-amp-fmt"><a href="#check-amp-fmt" class="headerlink" title="check &amp; fmt"></a>check &amp; fmt</h3><p><code>opa check</code> 是语法检查;<code>opa fmt</code>是格式化</p><h2 id="vscode-opa"><a href="#vscode-opa" class="headerlink" title="vscode-opa"></a>vscode-opa</h2><p>命令虽少可还是要记啊，有没有不用敲命令这么费劲的</p><p>有！官方强大的交互式编辑器扩展<a href="https://marketplace.visualstudio.com/items?itemName=tsandall.opa" target="_blank" rel="noopener">vscode-opa</a>，了解下~~</p><p>安装后只要在<code>vscode</code>的配置里指定<code>OPA</code>执行文件路径就可以用了</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"opa.path": "/usr/local/bin/opa"</span><br></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>它基本支持上述大部分命令功能：</p><ul><li>在保存时检查语法（Check Syntax on Save）</li><li>计算包结果（Evaluate Packages）</li><li>计算选择部分结果（Evaluate Selections）</li><li>部分评估选择（Partially Evaluate Selections）</li><li>对选择部分代码运行追踪（Trace Selections）</li><li>对选择部分性能分析（Profile Selections）</li><li>在工作区中运行测试（Run Tests in Workspace）</li><li>切换工作区的测试覆盖（Toggle Coverage in Workspace）</li><li>切换选择部分的测试覆盖（Toggle Coverage of Selections）</li></ul><p>其中评估（<code>Evaluate</code>)和测试覆盖显示（<code>Coverage</code>）在日常开发中很实用</p><p>具体如下图：</p><p><img src="http://media.newbmiao.com/opa/vscode-opa.gif" alt="插件效果"></p><h3 id="快捷键配置"><a href="#快捷键配置" class="headerlink" title="快捷键配置"></a>快捷键配置</h3><p>这里可以配置用户快捷键方便直接调起命令：</p><p>（官方推荐的前两个<code>Evaluate</code>的，后边<code>Test</code>相关的也可以加上）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"cmd+e"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"opa.eval.selection"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorLangId == rego"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"shift+cmd+a"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"opa.eval.package"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorLangId == rego"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"shift+cmd+c"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"opa.test.coverage.workspace"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorLangId == rego"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"shift+cmd+t"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"opa.test.workspace"</span>,</span><br><span class="line">        <span class="attr">"when"</span>: <span class="string">"editorLangId == rego"</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>Tip: 插件默认<strong>只取项目根目录</strong>的<code>input.json</code>作为输入<br>配置<code>opa.bundleMode</code>默认为true，则会<strong>只获取目录</strong>里的所有<code>data.{json|yaml}</code><br>如果设置为false，则会获取目录中所有<code>.{json|yaml}</code></p></blockquote><p>好了，现在可以优雅的使用<code>opa</code>开发了。</p><p>下一篇我们来讲讲<code>OPA</code>的函数和虚拟文档，了解下他们各自适用的场景。</p><blockquote><p>本文代码详见:<a href="https://github.com/NewbMiao/opa-koans/tree/master/quick-start" target="_blank" rel="noopener">NewbMiao/opa-koans</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      如何优雅的使用opa进行开发
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="Rego" scheme="http://blog.newbmiao.com/tags/Rego/"/>
    
  </entry>
  
  <entry>
    <title>OPA-重新定义规则引擎-入门篇</title>
    <link href="http://blog.newbmiao.com/2020/03/13/opa-quick-start.html"/>
    <id>http://blog.newbmiao.com/2020/03/13/opa-quick-start.html</id>
    <published>2020-03-13T07:32:10.000Z</published>
    <updated>2023-06-18T00:52:29.955Z</updated>
    
    <content type="html"><![CDATA[<p><code>OPA</code>，全称<code>OpenPolicyAgent</code>, 底层用<code>Go</code>实现，它灵活而强大的声明式语言全面支持通用策略定义。</p><p>而且，2019年4月2号<code>OPA</code>正式进入了<code>CNCF</code>，作为孵化级托管项目，详见<a href="https://www.cncf.io/blog/2019/04/02/toc-votes-to-move-opa-into-cncf-incubator/" target="_blank" rel="noopener">声明</a></p><p>目前国内资料还比较少。</p><p>个人因为工作接触比较多，打算陆续分享些教程介绍下。</p><p>私以为策略引擎的技术选型完全可以多这个选择~~</p><h2 id="什么是OPA"><a href="#什么是OPA" class="headerlink" title="什么是OPA"></a>什么是OPA</h2><blockquote><p>具体看官方文档 <a href="https://www.openpolicyagent.org/docs/latest/philosophy/#what-is-opa" target="_blank" rel="noopener">OPA philosophy docs</a></p></blockquote><p>主要关键词是：</p><ul><li>轻量级的通用策略引擎</li><li>可与服务共存</li><li>集成方式可以是sidecar、主机级守护进程或库引入</li></ul><p><img src="http://media.newbmiao.com/opa/policy.png" alt="opa"></p><a id="more"></a><p>文字图片还是不够生动，看看OPA作者怎么说：</p><p><a href="https://www.youtube.com/watch?v=XEHeexPpgrA&feature=youtu.be" target="_blank" rel="noopener">OPA: The Cloud Native Policy Engine - Torin Sandall, Styra</a></p><p>或<a href="https://www.bilibili.com/video/av96102581/" target="_blank" rel="noopener">备用国内B站地址</a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>强大的声明式策略</p><ul><li>上下文感知</li><li>表达性强</li><li>快速</li><li>可移植</li></ul></li><li><p>输入和输出支持任意格式</p></li></ul><p>配合强大的声明式策略语言<code>Rego</code>，描述任意规则都不是问题</p><ul><li>全面支持规则和系统解耦</li></ul><p><img src="http://media.newbmiao.com/opa/OPA-why.png" alt="如图"></p><ul><li>集承方式多<ul><li>Daemon式服务</li><li>Go类库引入</li></ul></li><li>决策快<ul><li><a href="https://blog.openpolicyagent.org/optimizing-opa-rule-indexing-59f03f17caf3" target="_blank" rel="noopener">rule indexing</a><br><img src="https://miro.medium.com/max/780/0*d7_1BA-vVgb0WqAk." alt="决策树索引"></li><li><a href="https://blog.openpolicyagent.org/partial-evaluation-162750eaf422" target="_blank" rel="noopener">partial evaluation</a><br><img src="https://miro.medium.com/max/1400/0*FN2kZ9ay1duS2HPN." alt="将动态计算尽可能转为编译时确定的静态规则"></li></ul></li><li>应用广泛</li></ul><p>除了集成做<code>Auth</code>外，还可以应用到<code>k8s,terraform,docker,kafka,sql,linux</code>等上做规则决策</p><ul><li>工具齐全<ul><li>有命令行，有交互式运行环境</li><li>支持测试，性能分析（底层<code>Go</code>实现）</li><li>有强大的交互式编辑器扩展<a href="https://marketplace.visualstudio.com/items?itemName=tsandall.opa" target="_blank" rel="noopener">vscode-opa</a></li><li>有<a href="https://play.openpolicyagent.org/" target="_blank" rel="noopener">playground</a>分享代码</li></ul></li></ul><p>下面从一个RBAC鉴权例子来了解下<code>OPA</code></p><h2 id="一个RBAC例子"><a href="#一个RBAC例子" class="headerlink" title="一个RBAC例子"></a>一个RBAC例子</h2><p>以下json配置了role能操作的资源和user的绑定关系</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"roles"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"operation"</span>: <span class="string">"read"</span>,</span><br><span class="line">            <span class="attr">"resource"</span>: <span class="string">"widgets"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"widget-reader"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"operation"</span>: <span class="string">"write"</span>,</span><br><span class="line">            <span class="attr">"resource"</span>: <span class="string">"widgets"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"widget-writer"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"bindings"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"user"</span>: <span class="string">"inspector-alice"</span>,</span><br><span class="line">            <span class="attr">"role"</span>: <span class="string">"widget-reader"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"user"</span>: <span class="string">"maker-bob"</span>,</span><br><span class="line">            <span class="attr">"role"</span>: <span class="string">"widget-writer"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个请求读取widgets的user（如下json）过来操作资源，怎么判定他是否可以呢？</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"action"</span>:&#123;</span><br><span class="line">        <span class="attr">"operation"</span>:<span class="string">"read"</span>,</span><br><span class="line">        <span class="attr">"resource"</span>:<span class="string">"widgets"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"subject"</span>:&#123;</span><br><span class="line">        <span class="attr">"user"</span>:<span class="string">"inspector-alice"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能你习惯性在想用自己趁手的语言和框架，一顿遍历循环搞定。</p><p>且慢，<code>OPA</code>告诉我们：</p><p>几行代码就可以！（当然代码少不是重点。。。）</p><p>这里是可以在线运行的<a href="https://play.openpolicyagent.org/p/ZXkIlAEPCY" target="_blank" rel="noopener">代码示例</a></p><p><img src="http://media.newbmiao.com/opa/example_rbac.png" alt="example_rbac"></p><p>我们先抛开语法，代码其实就是<strong>描述</strong>了一条规则：</p><p><strong>用户是否有角色，角色是否有权限操作的资源</strong></p><p>下面我们开始学习<code>OPA</code>如何定义这条规则</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><code>OPA</code>基于一种数据查询语言<a href="https://zh.wikipedia.org/wiki/Datalog" target="_blank" rel="noopener">Datalog</a>实现了描述语言<code>Rego</code></p><p><code>OPA</code>的<code>Rego</code>基本语法如下表：</p><table><thead><tr><th>语法</th><th>例子</th></tr></thead><tbody><tr><td>上下文</td><td>data</td></tr><tr><td>输入</td><td>input</td></tr><tr><td>索引取值</td><td>data.bindings[0]</td></tr><tr><td>比较</td><td>“alice” == input.subject.user</td></tr><tr><td>赋值</td><td>user := input.subject.user</td></tr><tr><td>规则</td><td>&lt; Header &gt; { &lt; Body &gt; }</td></tr><tr><td>规则头</td><td>&lt; Name &gt; = &lt; Value &gt; { … } 或者 &lt; Name &gt; { … }</td></tr><tr><td>规则体</td><td>And运算的一个个描述</td></tr><tr><td>多条同名规则</td><td>Or运算的一个规则</td></tr><tr><td>规则默认值</td><td>default allow = false</td></tr><tr><td>函数</td><td>fun(x) { … }</td></tr><tr><td>虚拟文档</td><td>doc[x] { … }</td></tr></tbody></table><p>一点也不多。函数和虚拟文档我们后边再开文章展开，今天主要看明白他的规则定义。</p><p>首先<strong>输入</strong>会挂在<code>input</code>对象下，用到的<strong>上下文</strong>（就是规则决策基于的源数据）会挂在<code>data</code>对象下</p><h3 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h3><p>当定义规则时：</p><ul><li><p>每条规则都会有返回值</p><ul><li>格式1：<code>&lt; Name &gt; { ... }</code></li></ul><p>不声明返回值，则只返回true或false</p><ul><li>格式2 <code>&lt; Name &gt; = &lt; Value &gt; { ... }</code></li></ul><p>声明返回值 <code>&lt; Value &gt;</code> 则返回其值</p></li><li><p>规则体内每条描述会逐条<code>And</code>运算，全部成立才会返回值</p></li><li><p>多条<strong>同名</strong>规则相互之间是<code>Or</code>运算，满足其一即可</p></li></ul><p>具体到代码中规则<code>allow</code>, 默认值是false</p><p>要求<code>user_has_role</code>和<code>role_has_permission</code>同时满足</p><p>两者的<code>role_name</code>也是一样。</p><p>你可能发现，局部变量<code>role_name</code> 没声明啊！</p><p><code>Rego</code>里可以省略声明局部变量, 直接使用。</p><blockquote><p>Tips: 但要这样的变量可以被<strong>同名的全局变量</strong>修改。<br>局部变量必要时还是应该使用<code>some</code>声明<br>如 <code>some role_name</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> allow = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"># allow will be <span class="literal">true</span> when user has role and role has permission</span><br><span class="line">allow &#123;</span><br><span class="line">  user_has_role[role_name]</span><br><span class="line">  role_has_permission[role_name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后其中<code>user_has_role[role_name]</code>这种带参数的结构不是规则，叫虚拟文档(<strong>文档：可被查询的集合</strong>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># check user role binding exist</span><br><span class="line">user_has_role[role_name] &#123;</span><br><span class="line">  role_binding = data.bindings[_]</span><br><span class="line">  role_binding.role = role_name</span><br><span class="line">  role_binding.user = input.subject.user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 仔细同学会发现，线上运行版有<code>with</code> ： <code>role_binding = data.bindings[_] with data.bindings as data_context.bindings</code><br>with 是用来替换输入input或者上下文data里的数据。<br>因为线上版没法指定上边的 <code>data.json</code>, 所以通过变量<code>data_context</code>替换传入的。</p></blockquote><p>集合里边<code>role_binding = data.bindings[_]</code>是遍历<code>data.bindings</code></p><p><code>Rego</code>的遍历语法类似python，这里遍历流程是</p><p>将<code>data.bindings</code>一个值赋值给<code>role_binding</code></p><p>进行后续处理，处理完后再赋下一个值</p><blockquote><p>Tips: <code>_</code>是特殊变量名，当需要变量占位又不需要后边引用时使用（类似Go的<code>_</code>）</p></blockquote><p>至于<code>role_binding.role = role_name</code>这条你应该能猜到是判断请求过来的role名是否和配置一致</p><p>可是为什么是<code>=</code>操作符，不应该是<code>==</code>?</p><p><strong>这里是一个有趣的点！</strong></p><h3 id="unification"><a href="#unification" class="headerlink" title="unification"></a>unification</h3><p><code>Rego</code>中实际只有<code>=</code>，而且作用是为变量赋值使等式成立，叫<code>Unification</code></p><p>而<code>:=</code>局部变量赋值，<code>==</code>比较，是<code>=</code>的语法糖，为了实现局部变量赋值和比较，和编译错误更容易区分</p><p>所以<code>=</code>更像是<strong>数据查询</strong>。（毕竟<code>Rego</code>是一个数据查询语言嘛）</p><p>这里举个例子就好理解了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x, <span class="string">"world"</span>] = [<span class="string">"hello"</span>, y]</span><br><span class="line"># 之后，x值为hello，y为world</span><br></pre></td></tr></table></figure><p>总结一下，本文介绍什么是<code>OPA</code>，并借一个简单的RBAC例子初探了<code>Rego</code>强大的声明规则语法。</p><p>下一篇，将会介绍如何本地优雅的开发<code>OPA</code>，感兴趣同学可以先在<code>OPA</code>的playground玩玩。</p><blockquote><p>了解更多:<a href="https://www.openpolicyagent.org/docs/latest/policy-language/" target="_blank" rel="noopener">OPA的Rego文档</a><br>本文代码详见:<a href="https://github.com/NewbMiao/opa-koans/tree/master/quick-start" target="_blank" rel="noopener">NewbMiao/opa-koans</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      OPA-重新定义策略引擎-入门篇
    
    </summary>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/categories/OPA/"/>
    
    
      <category term="OPA" scheme="http://blog.newbmiao.com/tags/OPA/"/>
    
      <category term="Rego" scheme="http://blog.newbmiao.com/tags/Rego/"/>
    
  </entry>
  
  <entry>
    <title>Dig101-Go之interface调用的一个优化点</title>
    <link href="http://blog.newbmiao.com/2020/02/29/dig101-golang-interface-de-virtualize.html"/>
    <id>http://blog.newbmiao.com/2020/02/29/dig101-golang-interface-de-virtualize.html</id>
    <published>2020-02-29T02:47:57.000Z</published>
    <updated>2023-06-18T00:52:29.950Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><p>今天谈下上文( <a href="https://mp.weixin.qq.com/s/81mLETTbbNmA86qKHCGOZQ" target="_blank" rel="noopener">Dig101-Go之读懂interface的底层设计</a> )留下的那个问题：</p><p>为什么对于以下interface <code>Stringer</code> 和构造类型 <code>Binary</code></p><p>下面代码<code>conversion</code>会调用转换函数<code>convT64</code>，而<code>devirt</code>不会调用？</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">conversion</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b Stringer</span><br><span class="line">  <span class="keyword">var</span> i Binary = <span class="number">1</span></span><br><span class="line">  b = i <span class="comment">//convT64</span></span><br><span class="line">  _=b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">devirt</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b Stringer = Binary(<span class="number">1</span>)</span><br><span class="line">  _ = b.String() <span class="comment">//static call Binary.String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里可以使用ssa可视化工具查看，更容易了解每行代码的编译过程<br>如 <code>GOSSAFUNC=main go1.14 build types/interface/interface.go</code> 生成<code>ssa.html</code><br><img src="http://media.newbmiao.com/dig101/go/ssa.png" alt="ssa.html"></p></blockquote><p>事有蹊跷，必是优化！</p><p>搜索发现相关 issue <a href="https://github.com/golang/go/issues/19361" target="_blank" rel="noopener">Devirtualize calls when concrete type behind interface is statically known</a> 和提交 <a href="https://go-review.googlesource.com/c/go/+/37751" target="_blank" rel="noopener">De-virtualize interface calls</a></p><p>原来这个是为了优化如果interface内部的构造类型如果可以内联后被静态推断出来的话，就将其直接重写为静态调用</p><p>最初主要希望避免一些interface调用的gc压力（interface调用在逃逸分析时，会使函数的接受者(<code>receiver</code>)和参数(<code>argument</code>)逃逸到堆上（而不是留在栈上），增加gc压力。不过这一点目前还未实现，参见<a href="https://github.com/golang/go/issues/33160" target="_blank" rel="noopener">Use devirtualization in escape analysis</a>）</p><p>暂时先优化为静态调用避免转换调用（<code>convXXX</code>），减少代码大小和提升细微的性能</p><p>摘录主要处理点如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对iface=类指针（pointer-shaped）构造类型 记录itab</span></span><br><span class="line"><span class="comment">// 用于后续优化掉 OCONVIFACE</span></span><br><span class="line">cmd/compile/internal/gc/subr.<span class="keyword">go</span>:implements</span><br><span class="line">  <span class="keyword">if</span> isdirectiface(t0) &amp;&amp; !iface.IsEmptyInterface() &#123;</span><br><span class="line">    itabname(t0, iface)</span><br><span class="line">  &#125;</span><br><span class="line">cmd/compile/internal/gc/reflect.<span class="keyword">go</span>:itabname</span><br><span class="line">  itabs = <span class="built_in">append</span>(itabs, itabEntry&#123;t: t, itype: itype, lsym: s.Linksym()&#125;)</span><br><span class="line"><span class="comment">// 编译前，获取itabs</span></span><br><span class="line">cmd/compile/internal/gc/reflect.<span class="keyword">go</span>:peekitabs</span><br><span class="line"><span class="comment">// ssa时利用函数内联和itabs推断可重写为静态调用，避免convXXX</span></span><br><span class="line">cmd/compile/internal/ssa/rewrite.<span class="keyword">go</span>:devirt</span><br></pre></td></tr></table></figure><blockquote><p>Go编译步骤相关参见 <a href="https://github.com/golang/go/blob/7145f1c7c7dcd4506f2819166f073e92f57afbb7/src/cmd/compile/README.md" target="_blank" rel="noopener">Go compiler</a></p></blockquote><p>这种优化对于常见的返回interface的构造函数还是有帮助的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">Interface</span></span> &#123; <span class="keyword">return</span> &amp;impl&#123;...&#125; &#125;</span><br></pre></td></tr></table></figure><p>要注意返回构造类型需为<strong>类指针</strong>才可以。</p><p>我们可以利用这一点来应用此interface调用优化</p><p>想了解更多，可以查看<a href="https://golang.org/test/devirt.go" target="_blank" rel="noopener">Devirtualize的测试代码</a></p><blockquote><p>本文代码见 <a href="https://github.com/NewbMiao/Dig101-Go/blob/master/types/interface/interface.go" target="_blank" rel="noopener">NewbMiao/Dig101-Go</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      dig101-golang-interface-de-virtualize
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="de-virtualize" scheme="http://blog.newbmiao.com/tags/de-virtualize/"/>
    
      <category term="interface" scheme="http://blog.newbmiao.com/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Dig101-Go之读懂interface的底层设计</title>
    <link href="http://blog.newbmiao.com/2020/02/26/dig101-golang-interface.html"/>
    <id>http://blog.newbmiao.com/2020/02/26/dig101-golang-interface.html</id>
    <published>2020-02-26T02:46:54.000Z</published>
    <updated>2023-06-18T00:52:29.950Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dig101: dig more, simplified more and know more</p></blockquote><p>今天我们聊聊万物皆可为的接口（interface）的底层设计。</p><p>interface被定义为一组方法的签名。</p><p>有了它，我们可以订立方法契约，去抽象和约束实现。</p><p>而Go的基础类型，可以认为是没有实现任何方法的空interface，也就是万物皆为的interface。</p><p>（Go语言没有泛型，接口可以作为一种替代实现）</p><p>接口也被寄予厚望，主力开发Russ Cox曾说过：</p><blockquote><p>从语言设计的角度来看，Go的接口是静态的，在编译时检查过的，在需要时是动态的。如果我可以将Go的一个特性导出到其他语言中，那就是接口。<br><a href="https://research.swtch.com/interfaces" target="_blank" rel="noopener">Go Data Structures: Interfaces</a></p></blockquote><p>那到底interface是怎么设计的底层结构呢？</p><p>又怎么支持的<a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">duck typing</a>？</p><p>在类型断言时又发生了什么？</p><p>带着这些问题，我们往下看</p><a id="more"></a><h2 id="0x01-底层结构一样么"><a href="#0x01-底层结构一样么" class="headerlink" title="0x01 底层结构一样么"></a>0x01 底层结构一样么</h2><p>我们知道定义接口有这两种方式，那他们底层结构是一样的么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">  String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b Stringer</span><br></pre></td></tr></table></figure><p>答案是【不一样】</p><p>我们用gdb打印下对应类型（gdb相关见<a href="https://mp.weixin.qq.com/s/xfDydcpRCmX1dR5FybI0Rw" target="_blank" rel="noopener">Tips-如何优雅的使用GDB调试Go</a>）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口类型</span></span><br><span class="line">&gt;&gt;&gt; ptype a</span><br><span class="line"><span class="keyword">type</span> = <span class="keyword">struct</span> runtime.eface &#123;</span><br><span class="line">    runtime._type *_type;</span><br><span class="line">    void *data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有函数定义的接口类型</span></span><br><span class="line">&gt;&gt;&gt; ptype b</span><br><span class="line"><span class="keyword">type</span> = <span class="keyword">struct</span> runtime.iface &#123;</span><br><span class="line">    runtime.itab *tab;</span><br><span class="line">    void *data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// itable相关类型</span></span><br><span class="line">&gt;&gt;&gt; ptype b.tab</span><br><span class="line"><span class="keyword">type</span> = <span class="keyword">struct</span> runtime.itab &#123;</span><br><span class="line">    <span class="comment">// 接口相关信息</span></span><br><span class="line">    runtime.interfacetype *inter;</span><br><span class="line">    <span class="comment">// 构造类型</span></span><br><span class="line">    runtime._type *_type;</span><br><span class="line">    <span class="keyword">uint32</span> hash;</span><br><span class="line">    [<span class="number">4</span>]<span class="keyword">uint8</span> _;</span><br><span class="line">    <span class="comment">// 构造类型的函数列表</span></span><br><span class="line">    [<span class="number">1</span>]<span class="keyword">uintptr</span> fun;</span><br><span class="line">&#125; *</span><br><span class="line">&gt;&gt;&gt; ptype b.tab.inter</span><br><span class="line"><span class="keyword">type</span> = <span class="keyword">struct</span> runtime.interfacetype &#123;</span><br><span class="line">    <span class="comment">// 接口的类型</span></span><br><span class="line">    runtime._type typ;</span><br><span class="line">    runtime.name pkgpath;</span><br><span class="line">    <span class="comment">// 接口定义的函数列表</span></span><br><span class="line">    []runtime.imethod mhdr;</span><br><span class="line">&#125; *</span><br></pre></td></tr></table></figure><p>以此可见Go内部定义了两种interface（但都是两个机器字）</p><h3 id="eface"><a href="#eface" class="headerlink" title="eface"></a>eface</h3><p>空接口，指没有定义方法的接口</p><p>内部存储了构造类型（<code>concrete type</code>）<code>type</code>和<code>data</code></p><p><img src="http://research.swtch.com/gointer3.png" alt="eface"></p><h3 id="iface"><a href="#iface" class="headerlink" title="iface"></a>iface</h3><p>有方法的接口</p><p>有了相比<code>eface</code>的<code>type</code>更丰富的<code>itab</code>字段，其中记录了构造类型及所实现的interface类型的类型和方法</p><p><img src="http://research.swtch.com/gointer2.png" alt="iface"></p><h2 id="0x02-类型如何相互转换"><a href="#0x02-类型如何相互转换" class="headerlink" title="0x02 类型如何相互转换"></a>0x02 类型如何相互转换</h2><p>如下代码，当我们做接口赋值时，Go又会怎样填充底层结构呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> strconv.Itoa(<span class="keyword">int</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">conversion</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b Stringer</span><br><span class="line">  <span class="keyword">var</span> i Binary = <span class="number">1</span></span><br><span class="line">  b = i <span class="comment">// &lt;= 这里发生了什么</span></span><br><span class="line">  <span class="built_in">println</span>(b.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb 进到 <code>b = i</code> 这一步，会发现他调用了<code>runtime/iface.go:convT64</code>方法实现iface的赋值</p><p>查阅源码，会发现很多<code>convXXX</code>函数, 他们是干什么的?</p><h3 id="convXXX的命名"><a href="#convXXX的命名" class="headerlink" title="convXXX的命名"></a>convXXX的命名</h3><p><code>convFrom2To</code> 指代 <code>To=From</code> 的转换</p><p>From和To的类型有三种：<br>（参见<code>cmd/compile/internal/types/type.go:Tie</code>）</p><ul><li>E (eface)</li><li>I (iface)</li><li>T (Type)</li></ul><p>这一堆函数看的人眼晕，但参照提交<a href="https://go-review.googlesource.com/c/go/+/36476" target="_blank" rel="noopener">specialize convT2x, don’t alloc for zero vals</a>深入分析，就会清晰许多</p><h3 id="起初的convT2-I-E-和-convI2I"><a href="#起初的convT2-I-E-和-convI2I" class="headerlink" title="起初的convT2{I,E} 和 convI2I"></a>起初的convT2{I,E} 和 convI2I</h3><p>最初只有 <code>convT2{I,E} 和 convI2I</code></p><p>主要实现分配内存（<code>newobject</code>），然后拷贝赋值（<code>typedmemmove</code>）</p><p><code>convI2I</code> 还会有<code>getitab</code>, 具体是什么我们后边类型断言时说</p><p>然后也在调用他们前（<code>walkexpr</code>）做了优化</p><ul><li>减少值拷贝</li></ul><p>ToType为类指针(<code>pointer-shaped</code>)或者一个机器字内（<code>int</code>）的话，可以<strong>直接存入interface的data字段</strong>（主要优化在这里）</p><p><code>pointer-shaped类型: ptr, chan, map, func, unsafe.Pointer</code></p><p>再辅以type的存储，就只是两个字（<code>two-word</code>）的拷贝</p><ul><li>减少内存分配</li></ul><p>零值，<code>bool/byte</code> 可以不用分配内存，而用已存在值（<code>zerobase,staticbytes</code>）</p><p>只读的全局变量(<code>readonly global</code>)直接可以用</p><p>1kb以内，不<code>escape</code>到堆上，非<code>interface</code>的变量可以使用栈上分配的临时变量(<code>stack temporary initialized</code>)</p><p>这类value最后以取地址形式转化为interface： <code>{type/itab, &amp;value}.</code></p><ul><li>interface转空接口（eface）</li></ul><p>可以丢弃除<code>type</code>以外的<code>itab</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmp = i.itab</span><br><span class="line"><span class="keyword">if</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">  tmp = tmp.<span class="keyword">type</span></span><br><span class="line">&#125;</span><br><span class="line">e = iface&#123;tmp, i.data&#125;</span><br></pre></td></tr></table></figure><h3 id="针对类型优化后的convXXX"><a href="#针对类型优化后的convXXX" class="headerlink" title="针对类型优化后的convXXX"></a>针对类型优化后的convXXX</h3><p>但这里会有一些可以优化的点，如：</p><ul><li>分配内存是否可以需要清零？</li></ul><p>类指针的类型需要清零，不然内存可能有脏数据</p><p>但无指针类型(<code>pointer-free</code>)如拷贝时直接可以覆盖对应内存则不需要</p><p>如<code>int</code>其拷贝在一个机器字内完成，不需要分配时清零<br>（32位系统上不调用<code>convT64</code>,就可以保证访问内存是安全的原子操作）</p><ul><li>是否可以简化值拷贝？</li></ul><p><code>int，string，slice</code>这些Type分配的<code>x</code>拷贝<code>val</code>时,可以简化为 <code>*(*Type)(x) = val</code></p><ul><li>拷贝内存是否可以不增加gc调用(写屏障)？</li></ul><p>按ToType类型是否含指针区分<br>类指针类型(<code>pointer-shaped</code>): <code>convT2{E,I}</code> 需要拷贝时gc调用（<code>typedmemmove</code>）</p><p>无指针类型(<code>pointer-free</code>): <code>convT2{E,I}noptr</code> 不需要拷贝时gc调用（<code>memmove</code>）</p><p>这样一看就明白这些函数的用意了，还是为了针对性的提高转化效率</p><p>最后结合其调用处<code>convXXX</code>列表如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd/compile/internal/gc/walk.go:walkexpr</span></span><br><span class="line"><span class="keyword">case</span> OCONVIFACE:</span><br><span class="line">  ...</span><br><span class="line">  fnname, needsaddr := convFuncName(fromType, toType)</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数(fnname)</th><th>From类型</th><th>值取地址存(needsaddr)</th></tr></thead><tbody><tr><td>convI2I</td><td>iface</td><td>否</td></tr><tr><td>convT{16,32,64}</td><td>底层为整型数据(不含指针，对齐不大于机器字)</td><td>否</td></tr><tr><td>convTstring</td><td>string</td><td>否</td></tr><tr><td>convTslice</td><td>slice</td><td>否</td></tr><tr><td>convT2E</td><td>Type</td><td>是</td></tr><tr><td>convT2Enoptr</td><td>无指针Type</td><td>是</td></tr><tr><td>convT2I</td><td>Type</td><td>是</td></tr><tr><td>convT2Inoptr</td><td>无指针Type</td><td>是</td></tr></tbody></table><blockquote><p>不会存在 convE2E 和 convE2I<br>needsaddr: 类型不含指针，大小大于64位字或未知大小时，使用值的地址来存</p></blockquote><h2 id="0x03-类型断言如何实现"><a href="#0x03-类型断言如何实现" class="headerlink" title="0x03 类型断言如何实现"></a>0x03 类型断言如何实现</h2><p>interface支持类型断言，来<strong>动态判断</strong>其构造类型,</p><p>判定成功可返回对应构造类型，便于调用其方法</p><p>可构造类型实现interface不需要显示声明，</p><p>那如下代码是怎么确定interface <code>b</code>（构造类型是<code>Binary</code>)实现<code>Stringer</code>呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeAssert</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = Binary(<span class="number">1</span>)</span><br><span class="line">  v, ok := b.(Stringer)</span><br><span class="line">  <span class="built_in">println</span>(v, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试后会发现，其调用了<code>assertE2I2</code></p><blockquote><p>这里函数命名有两类，如下</p><p>assertE2I: v := eface1.(iface1)</p><p>assertE2I2: v,ok := eface1.(iface1)</p><p>这里有一点，类型断言非 <code>v,ok</code> 方式的，断言失败会panic）</p></blockquote><p>原来其内部进行了<code>itab</code>表(<code>itabTable</code>)查询interface和构造类型的映射表，如果匹配则说明实现</p><p>下边代码分析如下</p><p>首先初始512个entry的表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itabInitSize = <span class="number">512</span></span><br><span class="line"><span class="keyword">type</span> itabTableType <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 上限</span></span><br><span class="line">  size    <span class="keyword">uintptr</span></span><br><span class="line">  <span class="comment">// 当前用量</span></span><br><span class="line">  count   <span class="keyword">uintptr</span></span><br><span class="line">  entries [itabInitSize]*itab</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查表是否匹配"><a href="#查表是否匹配" class="headerlink" title="查表是否匹配"></a>查表是否匹配</h3><p>在类型断言中调用 <code>getitab(inter, typ, canfail)</code> 查表</p><ul><li>先不加锁atomic读取itabTable，找到返回</li><li>未找到加锁再查一遍，找到返回</li><li>还没有就创建一个itab添加到表中，添加完后解锁</li><li>期间如果判定不匹配则按是否可以panic（canfail）返回</li></ul><p>其中查表用到 <code>itabTable.find(inter, typ)</code>，</p><p>插入用到 <code>itabAdd(m)</code></p><h3 id="尝试插入更新"><a href="#尝试插入更新" class="headerlink" title="尝试插入更新"></a>尝试插入更新</h3><ul><li>插入前需先用<code>m.inter/m._type pair</code> 初始化 <code>m.fun</code> 数组，不匹配则<code>m.fun[0]==0</code></li></ul><p>(<code>m.fun</code> 类型 <code>[1]uintptr</code>，实际指向是大小为接口定义方法数的方法数组。详见 <code>func (m *itab) init()</code>)</p><ul><li><p>用量count超过上限的75%触发扩容，大小为2倍以上（要向上内存对齐），扩容后更新itabTable是原子操作</p></li><li><p>以itab m的interface类型和构造类型的hash计算对应itabTable的起始偏移，然后插入到其后第一个不为空的entry。如果已存在则直接返回</p></li></ul><p>这里用到了开放地址探测法，公式是：</p><p><code>h(i) = h0 + i*(i+1)/2 mod 2^k</code></p><p>具体插入用到 <code>itabTable.add(m)</code></p><p>这里和其实map插入的逻辑很相似</p><h3 id="动态判定效率优化"><a href="#动态判定效率优化" class="headerlink" title="动态判定效率优化"></a>动态判定效率优化</h3><p>不过，<strong>这里有一个问题？</strong></p><p>假定，interface定义了<code>ni</code>个方法，构造类型实现<code>nt</code>个方法，</p><p>常规匹配构造类型是否实现全部<code>ni</code>个方法需要两层遍历，复杂度为<code>O(ni*nt)</code></p><p>这样在初始化<code>itab.fun</code>或类型断言匹配是效率会比较低。</p><p>Go设计时也考虑了这个问题，把复杂度降低为<code>O(ni+nt)</code></p><p>这也是使用hashtable的原因之一：</p><ul><li><p>首先interface的函数定义列表<code>itab.inter.mhdr</code>和构造类型的函数列表<code>itab.fun</code>都是按函数名排好序的</p></li><li><p>这样第一次itab初始化时，判定构造类型是否实现函数列表可以<code>O(ni+nt)</code>内遍历完成</p></li><li><p>然后用开放地址探测法更新到itabtable中，查询时也可以用同样的方式定位到此itab是否存在。</p></li></ul><p>两个（有序）列表的遍历匹配代码精简如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/iface.go:init()</span></span><br><span class="line">j:=<span class="number">0</span></span><br><span class="line">imethods:</span><br><span class="line">  <span class="comment">// 遍历interface定义函数列表</span></span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">    <span class="comment">// 遍历构造类型函数列表</span></span><br><span class="line">    <span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">      <span class="comment">// 如果两者类型（type），包路径（pkgpath）,函数名（name）匹配</span></span><br><span class="line">      <span class="keyword">if</span> xxx &#123;</span><br><span class="line">          <span class="comment">// 将方法记录到 fun0 (最终全匹配则赋值给 m.fun)</span></span><br><span class="line">          <span class="keyword">continue</span> imethods</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未全匹配</span></span><br><span class="line">    m.fun[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  m.fun[<span class="number">0</span>] = <span class="keyword">uintptr</span>(fun0)</span><br></pre></td></tr></table></figure><p>总结一下interface的底层设计：</p><ul><li>interface 分为空接口（eface）和接口（iface）两类，但都是两机器字（two-word）存储结构</li><li>interface 转换中针对不同类型做了优化，主要集中于提升内存分配和值拷贝效率</li><li>interface 类型断言时动态判定，利用有序列表遍历+全局哈希表表缓存优化判定效率</li></ul><p>See More： 官方解释 <a href="https://github.com/golang/go/wiki/InterfaceSlice" target="_blank" rel="noopener">InterfaceSlice</a> 为什么不能直接转化​</p><hr><p>最后留个问题：</p><p>下边这段转换代码内部没有调<code>convT64</code>，为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b Stringer = Binary(<span class="number">1</span>)</span><br><span class="line">_ = b.String()</span><br></pre></td></tr></table></figure><p>这个问题下一篇文章再来给出解答。</p><blockquote><p>本文代码见 <a href="https://github.com/NewbMiao/Dig101-Go/blob/master/types/interface/interface.go" target="_blank" rel="noopener">NewbMiao/Dig101-Go</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      dig101-golang-interface
    
    </summary>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/categories/go/"/>
    
      <category term="dig101" scheme="http://blog.newbmiao.com/categories/go/dig101/"/>
    
    
      <category term="go" scheme="http://blog.newbmiao.com/tags/go/"/>
    
      <category term="interface" scheme="http://blog.newbmiao.com/tags/interface/"/>
    
  </entry>
  
</feed>
